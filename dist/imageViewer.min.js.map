{"version":3,"sources":["webpack:///imageViewer.min.js","webpack:///webpack/bootstrap 614d70d1db3077edc20f","webpack:///./src/lib/hammer.js","webpack:///./src/common/dom.js","webpack:///./src/common/debug.js","webpack:///./src/common/profile.js","webpack:///./src/common/lock.js","webpack:///./src/common/event.js","webpack:///./src/core/viewer.js","webpack:///./src/core/imageViewer.js","webpack:///./src/index.js","webpack:///(webpack)/buildin/harmony-module.js","webpack:///(webpack)/buildin/amd-options.js","webpack:///./src/css/index.css?1093","webpack:///./src/css/index.css","webpack:///./node_modules/.0.28.4@css-loader/lib/css-base.js","webpack:///./node_modules/.0.13.2@style-loader/addStyles.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_typeof","Symbol","iterator","obj","constructor","window","document","exportName","undefined","setTimeoutContext","fn","timeout","context","setTimeout","bindFn","invokeArrayArg","arg","Array","isArray","each","forEach","length","deprecate","method","message","deprecationMessage","e","Error","stack","replace","log","console","warn","apply","this","arguments","inherit","child","base","properties","childP","baseP","create","_super","assign","boolOrFn","val","args","TYPE_FUNCTION","ifUndefined","val1","val2","addEventListeners","target","types","handler","splitStr","type","addEventListener","removeEventListeners","removeEventListener","hasParent","node","parent","parentNode","inStr","str","find","indexOf","trim","split","inArray","src","findByKey","toArray","slice","uniqueArray","key","sort","results","values","push","a","b","prefixed","prefix","prop","camelProp","toUpperCase","VENDOR_PREFIXES","uniqueId","_uniqueId","getWindowForElement","element","doc","ownerDocument","defaultView","parentWindow","Input","manager","callback","self","options","inputTarget","domHandler","ev","enable","init","createInputInstance","inputClass","SUPPORT_POINTER_EVENTS","PointerEventInput","SUPPORT_ONLY_TOUCH","TouchInput","SUPPORT_TOUCH","TouchMouseInput","MouseInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","INPUT_START","isFinal","INPUT_END","INPUT_CANCEL","session","computeInputData","emit","recognize","prevInput","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","now","deltaTime","angle","getAngle","distance","getDistance","computeDeltaXY","offsetDirection","getDirection","deltaX","deltaY","overallVelocity","getVelocity","overallVelocityX","x","overallVelocityY","y","abs","scale","getScale","rotation","getRotation","maxPointers","computeIntervalInputData","srcEvent","offset","offsetDelta","prevDelta","velocity","velocityX","velocityY","direction","last","lastInterval","COMPUTE_INTERVAL","v","clientX","round","clientY","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","p1","p2","props","PROPS_XY","Math","sqrt","atan2","PI","start","end","PROPS_CLIENT_XY","evEl","MOUSE_ELEMENT_EVENTS","evWin","MOUSE_WINDOW_EVENTS","pressed","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","store","pointerEvents","SingleTouchInput","evTarget","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","started","normalizeSingleTouches","all","touches","changed","changedTouches","concat","TOUCH_TARGET_EVENTS","targetIds","getTouches","allTouches","INPUT_MOVE","identifier","targetTouches","changedTargetTouches","filter","touch","mouse","primaryTouch","lastTouches","recordTouches","eventData","setLastTouch","lastTouch","lts","removeLastTouch","splice","DEDUP_TIMEOUT","isSyntheticEvent","t","dx","dy","DEDUP_DISTANCE","TouchAction","value","set","cleanTouchActions","actions","TOUCH_ACTION_NONE","hasPanX","TOUCH_ACTION_PAN_X","hasPanY","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_AUTO","Recognizer","defaults","id","state","STATE_POSSIBLE","simultaneous","requireFail","stateStr","STATE_CANCELLED","STATE_ENDED","STATE_CHANGED","STATE_BEGAN","directionStr","getRecognizerByNameIfManager","otherRecognizer","recognizer","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","Hammer","recognizers","preset","Manager","handlers","oldCssProps","touchAction","toggleCssProps","item","add","recognizeWith","requireFailure","style","cssProps","triggerDomEvent","event","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","TEST_ELEMENT","createElement","Date","TypeError","output","index","source","nextKey","extend","dest","merge","keys","MOBILE_REGEX","test","navigator","userAgent","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","destroy","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","button","which","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","2","3","4","5","MSPointerEvent","PointerEvent","removePointer","eventTypeNormalized","toLowerCase","isTouch","storeIndex","pointerId","SINGLE_TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_INPUT_MAP","inputEvent","inputData","isMouse","sourceCapabilities","firesTouchEvents","PREFIXED_TOUCH_ACTION","NATIVE_TOUCH_ACTION","TOUCH_ACTION_MAP","touchMap","cssSupports","CSS","supports","compute","update","getTouchAction","join","preventDefaults","prevented","preventDefault","hasNone","isTapPointer","isTapMovement","isTapTouchTime","preventSrc","STATE_RECOGNIZED","dropRecognizeWith","dropRequireFailure","hasRequireFailures","canRecognizeWith","additionalEvent","tryEmit","canEmit","inputDataClone","reset","process","attrTest","optionPointers","isRecognized","isValid","threshold","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","clearTimeout","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","VERSION","domEvents","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","stop","force","stopped","curRecognizer","existing","remove","on","events","off","STATE_FAILED","Tap","Pan","Swipe","Pinch","Rotate","Press","define","query","selector","el","querySelectorAll","removeElement","parentElement","removeChild","setTranslateStyle","transformProp","setScaleAndTranslateStyle","_classCallCheck","instance","Constructor","event__classCallCheck","viewer__classCallCheck","imageViewer__classCallCheck","debug","msg","availProp","LOCK_NAME","_createClass","defineProperties","descriptor","writable","protoProps","staticProps","Lock","_locks","lock_defaultExport","event__createClass","Event","_enableMultiple","_handlers","enableMultiple","_this","_len","_key","exit","event_defaultExport","__WEBPACK_IMPORTED_MODULE_4__lib_hammer__","viewer__createClass","viewer_Viewer","Viewer","imageViewer","width","height","panelEl","firstElementChild","imageEl","displayIndex","realWidth","realHeight","translateX","translateY","currentScale","translatePanelX","translatePanelY","currentPanelX","currentPanelY","allowDistanceX","allowDistanceY","needResetX","needResetY","EVENT_NAME","_bindEvent","resetScale","needLoad","_initImage","display","clientWidth","clientHeight","_this2","mc","removeAnimation","getLockState","_translatePanel","_translatePanelEnd","willChange","isNaN","isScale","getLock","releaseLock","tempX","_dealWithMoveAction","_calculate","needSwipe","_dealWithMoveActionEnd","addAnimation","classList","viewer_defaultExport","imageViewer___WEBPACK_IMPORTED_MODULE_4__lib_hammer__","imageViewer__createClass","imageViewer_ImageViewer","ImageViewer","images","opt","headerEl","bodyEl","footerEl","currentNumberEl","totalNumberEl","imagesLength","container","enableScale","currentIndex","startIndex","viewers","scaleStart","itemList","hammer","divEl","innerHTML","imageViewerTemplate","appendChild","children","headerRender","footerRender","swipeInByIndex","createLock","innerText","hPinch","hPan","hTap","_dealWithMoveActionStart","bind","_dealWithScaleActionStart","_dealWithScaleAction","_dealWithScaleActionEnd","beforeSwipe","needBreak","swipeFirstRight","swipeLastLeft","_checkDistance","viewer","swipeToPrev","swipeToNext","_updateCountElement","afterSwipe","_pinchStart","_pinch","_pinchEnd","minuend","loop","addend","shift","pop","_getPrevImage","image","_getSpecificImage","loopViewers","_getNextImage","_getCurrentImage","_init","_create","imageViewer_defaultExport","__WEBPACK_IMPORTED_MODULE_1__css_index_css__","originalModule","webpackPolyfill","__webpack_amd_options__","content","locals","cssWithMappingToString","useSourceMap","cssMapping","btoa","sourceMapping","toComment","sources","map","sourceRoot","sourceMap","unescape","encodeURIComponent","JSON","stringify","list","toString","mediaQuery","alreadyImportedModules","addStylesToDom","styles","domStyle","stylesInDom","refs","j","parts","addStyle","listToStyles","newStyles","css","media","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","nextSibling","insertBefore","firstChild","removeStyleElement","idx","createStyleElement","createLinkElement","linkElement","rel","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","updateLink","href","applyToTag","newObj","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","setAttribute","blob","oldSrc","memoize","memo","isOldIE","getElementsByTagName","DEBUG","newList","mayRemove","textStore","replacement","Boolean"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAI,EAAAJ,EACAK,GAAA,EACAH,WAUA,OANAJ,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,QAvBA,GAAAD,KA4BAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,SAAAP,EAAAQ,EAAAC,GACAZ,EAAAa,EAAAV,EAAAQ,IACAG,OAAAC,eAAAZ,EAAAQ,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAf,GACA,GAAAQ,GAAAR,KAAAgB,WACA,WAA2B,MAAAhB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAJ,GAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDtB,EAAAyB,EAAA,GAGAzB,IAAA0B,EAAA,KDMM,SAAUtB,EAAQuB,EAAqB3B,GAE7C,cAC4B,SAASI,GAAS,GAAIwB,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,QAAUE,IAAQF,OAAON,UAAY,eAAkBQ,KEtEpT,SAAWE,EAAQC,EAAUC,EAAYC,GAmBrC,QAASC,GAAkBC,EAAIC,EAASC,GACpC,MAAOC,YAAWC,EAAOJ,EAAIE,GAAUD,GAY3C,QAASI,GAAeC,EAAKN,EAAIE,GAC7B,QAAIK,MAAMC,QAAQF,KACdG,EAAKH,EAAKJ,EAAQF,GAAKE,IAChB,GAWf,QAASO,GAAKhB,EAAKD,EAAUU,GACzB,GAAInC,EAEJ,IAAK0B,EAIL,GAAIA,EAAIiB,QACJjB,EAAIiB,QAAQlB,EAAUU,OACnB,IAAIT,EAAIkB,SAAWb,EAEtB,IADA/B,EAAI,EACGA,EAAI0B,EAAIkB,QACXnB,EAASvB,KAAKiC,EAAST,EAAI1B,GAAIA,EAAG0B,GAClC1B,QAGJ,KAAKA,IAAK0B,GACNA,EAAIP,eAAenB,IAAMyB,EAASvB,KAAKiC,EAAST,EAAI1B,GAAIA,EAAG0B,GAYvE,QAASmB,GAAUC,EAAQxC,EAAMyC,GAC7B,GAAIC,GAAqB,sBAAwB1C,EAAO,KAAOyC,EAAU,QACzE,OAAO,YACH,GAAIE,GAAI,GAAIC,OAAM,mBACdC,EAAQF,GAAKA,EAAEE,MAAQF,EAAEE,MAAMC,QAAQ,kBAAmB,IACrDA,QAAQ,cAAe,IACvBA,QAAQ,6BAA8B,kBAAoB,sBAE/DC,EAAMzB,EAAO0B,UAAY1B,EAAO0B,QAAQC,MAAQ3B,EAAO0B,QAAQD,IAInE,OAHIA,IACAA,EAAInD,KAAK0B,EAAO0B,QAASN,EAAoBG,GAE1CL,EAAOU,MAAMC,KAAMC,YAwElC,QAASC,GAAQC,EAAOC,EAAMC,GAC1B,GACIC,GADAC,EAAQH,EAAK3C,SAGjB6C,GAASH,EAAM1C,UAAYT,OAAOwD,OAAOD,GACzCD,EAAOpC,YAAciC,EACrBG,EAAOG,OAASF,EAEZF,GACAK,GAAOJ,EAAQD,GAUvB,QAASzB,GAAOJ,EAAIE,GAChB,MAAO,YACH,MAAOF,GAAGuB,MAAMrB,EAASuB,YAWjC,QAASU,GAASC,EAAKC,GACnB,WAAI,KAAOD,EAAP,YAAA9C,EAAO8C,KAAOE,GACPF,EAAIb,MAAMc,EAAOA,EAAK,IAAMvC,EAAYA,EAAWuC,GAEvDD,EASX,QAASG,GAAYC,EAAMC,GACvB,MAAQD,KAAS1C,EAAa2C,EAAOD,EASzC,QAASE,GAAkBC,EAAQC,EAAOC,GACtCpC,EAAKqC,EAASF,GAAQ,SAAUG,GAC5BJ,EAAOK,iBAAiBD,EAAMF,GAAS,KAU/C,QAASI,GAAqBN,EAAQC,EAAOC,GACzCpC,EAAKqC,EAASF,GAAQ,SAAUG,GAC5BJ,EAAOO,oBAAoBH,EAAMF,GAAS,KAWlD,QAASM,GAAUC,EAAMC,GACrB,KAAOD,GAAM,CACT,GAAIA,GAAQC,EACR,OAAO,CAEXD,GAAOA,EAAKE,WAEhB,OAAO,EASX,QAASC,GAAMC,EAAKC,GAChB,MAAOD,GAAIE,QAAQD,IAAS,EAQhC,QAASX,GAASU,GACd,MAAOA,GAAIG,OAAOC,MAAM,QAU5B,QAASC,GAAQC,EAAKL,EAAMM,GACxB,GAAID,EAAIJ,UAAYK,EAChB,MAAOD,GAAIJ,QAAQD,EAGnB,KADA,GAAI1F,GAAI,EACDA,EAAI+F,EAAInD,QAAQ,CACnB,GAAKoD,GAAaD,EAAI/F,GAAGgG,IAAcN,IAAWM,GAAaD,EAAI/F,KAAO0F,EACtE,MAAO1F,EAEXA,KAEJ,OAAQ,EAShB,QAASiG,GAAQvE,GACb,MAAOc,OAAMtB,UAAUgF,MAAMhG,KAAKwB,EAAK,GAU3C,QAASyE,GAAYJ,EAAKK,EAAKC,GAK3B,IAJA,GAAIC,MACAC,KACAvG,EAAI,EAEDA,EAAI+F,EAAInD,QAAQ,CACnB,GAAIyB,GAAM+B,EAAML,EAAI/F,GAAGoG,GAAOL,EAAI/F,EAC9B8F,GAAQS,EAAQlC,GAAO,GACvBiC,EAAQE,KAAKT,EAAI/F,IAErBuG,EAAOvG,GAAKqE,EACZrE,IAaJ,MAVIqG,KAIIC,EAHCF,EAGSE,EAAQD,KAAK,SAAyBI,EAAGC,GAC/C,MAAOD,GAAEL,GAAOM,EAAEN,KAHZE,EAAQD,QAQnBC,EASX,QAASK,GAASjF,EAAKT,GAKnB,IAJA,GAAI2F,GAAQC,EACRC,EAAY7F,EAAS,GAAG8F,cAAgB9F,EAASiF,MAAM,GAEvDlG,EAAI,EACDA,EAAIgH,GAAgBpE,QAAQ,CAI/B,GAHAgE,EAASI,GAAgBhH,IACzB6G,EAAQD,EAAUA,EAASE,EAAY7F,IAE3BS,GACR,MAAOmF,EAEX7G,KAEJ,MAAO+B,GASX,QAASkF,KACL,MAAOC,MAQX,QAASC,GAAoBC,GACzB,GAAIC,GAAMD,EAAQE,eAAiBF,CACnC,OAAQC,GAAIE,aAAeF,EAAIG,cAAgB5F,EAyCnD,QAAS6F,GAAMC,EAASC,GACpB,GAAIC,GAAOnE,IACXA,MAAKiE,QAAUA,EACfjE,KAAKkE,SAAWA,EAChBlE,KAAK2D,QAAUM,EAAQN,QACvB3D,KAAKmB,OAAS8C,EAAQG,QAAQC,YAI9BrE,KAAKsE,WAAa,SAAUC,GACpB5D,EAASsD,EAAQG,QAAQI,QAASP,KAClCE,EAAK9C,QAAQkD,IAIrBvE,KAAKyE,OAqCT,QAASC,GAAoBT,GACzB,GACIU,GAAaV,EAAQG,QAAQO,UAajC,OAAO,KAXHA,IAEOC,GACAC,EACAC,GACAC,EACCC,GAGDC,EAFAC,IAIOjB,EAASkB,GAS/B,QAASA,GAAalB,EAASmB,EAAWC,GACtC,GAAIC,GAAcD,EAAME,SAASpG,OAC7BqG,EAAqBH,EAAMI,gBAAgBtG,OAC3CuG,EAAWN,EAAYO,IAAgBL,EAAcE,GAAuB,EAC5EI,EAAWR,GAAaS,GAAYC,KAAkBR,EAAcE,GAAuB,CAE/FH,GAAMK,UAAYA,EAClBL,EAAMO,UAAYA,EAEdF,IACAzB,EAAQ8B,YAKZV,EAAMD,UAAYA,EAGlBY,EAAiB/B,EAASoB,GAG1BpB,EAAQgC,KAAK,eAAgBZ,GAE7BpB,EAAQiC,UAAUb,GAClBpB,EAAQ8B,QAAQI,UAAYd,EAQhC,QAASW,GAAiB/B,EAASoB,GAC/B,GAAIU,GAAU9B,EAAQ8B,QAClBR,EAAWF,EAAME,SACjBa,EAAiBb,EAASpG,MAGzB4G,GAAQM,aACTN,EAAQM,WAAaC,EAAqBjB,IAI1Ce,EAAiB,IAAML,EAAQQ,cAC/BR,EAAQQ,cAAgBD,EAAqBjB,GACnB,IAAnBe,IACPL,EAAQQ,eAAgB,EAG5B,IAAIF,GAAaN,EAAQM,WACrBE,EAAgBR,EAAQQ,cACxBC,EAAeD,EAAgBA,EAAcE,OAASJ,EAAWI,OAEjEA,EAASpB,EAAMoB,OAASC,EAAUnB,EACtCF,GAAMsB,UAAYC,KAClBvB,EAAMwB,UAAYxB,EAAMsB,UAAYN,EAAWM,UAE/CtB,EAAMyB,MAAQC,EAASP,EAAcC,GACrCpB,EAAM2B,SAAWC,EAAYT,EAAcC,GAE3CS,EAAenB,EAASV,GACxBA,EAAM8B,gBAAkBC,EAAa/B,EAAMgC,OAAQhC,EAAMiC,OAEzD,IAAIC,GAAkBC,EAAYnC,EAAMwB,UAAWxB,EAAMgC,OAAQhC,EAAMiC,OACvEjC,GAAMoC,iBAAmBF,EAAgBG,EACzCrC,EAAMsC,iBAAmBJ,EAAgBK,EACzCvC,EAAMkC,gBAAmBM,GAAIN,EAAgBG,GAAKG,GAAIN,EAAgBK,GAAML,EAAgBG,EAAIH,EAAgBK,EAEhHvC,EAAMyC,MAAQvB,EAAgBwB,EAASxB,EAAchB,SAAUA,GAAY,EAC3EF,EAAM2C,SAAWzB,EAAgB0B,EAAY1B,EAAchB,SAAUA,GAAY,EAEjFF,EAAM6C,YAAenC,EAAQI,UAAsCd,EAAME,SAASpG,OAC9E4G,EAAQI,UAAU+B,YAAe7C,EAAME,SAASpG,OAAS4G,EAAQI,UAAU+B,YADtC7C,EAAME,SAASpG,OAGxDgJ,EAAyBpC,EAASV,EAGlC,IAAIlE,GAAS8C,EAAQN,OACjBhC,GAAU0D,EAAM+C,SAASjH,OAAQA,KACjCA,EAASkE,EAAM+C,SAASjH,QAE5BkE,EAAMlE,OAASA,EAGnB,QAAS+F,GAAenB,EAASV,GAC7B,GAAIoB,GAASpB,EAAMoB,OACf4B,EAAStC,EAAQuC,gBACjBC,EAAYxC,EAAQwC,cACpBpC,EAAYJ,EAAQI,aAEpBd,GAAMD,YAAcO,IAAeQ,EAAUf,YAAcS,KAC3D0C,EAAYxC,EAAQwC,WAChBb,EAAGvB,EAAUkB,QAAU,EACvBO,EAAGzB,EAAUmB,QAAU,GAG3Be,EAAStC,EAAQuC,aACbZ,EAAGjB,EAAOiB,EACVE,EAAGnB,EAAOmB,IAIlBvC,EAAMgC,OAASkB,EAAUb,GAAKjB,EAAOiB,EAAIW,EAAOX,GAChDrC,EAAMiC,OAASiB,EAAUX,GAAKnB,EAAOmB,EAAIS,EAAOT,GAQpD,QAASO,GAAyBpC,EAASV,GACvC,GAEImD,GAAUC,EAAWC,EAAWC,EAFhCC,EAAO7C,EAAQ8C,cAAgBxD,EAC/BwB,EAAYxB,EAAMsB,UAAYiC,EAAKjC,SAGvC,IAAItB,EAAMD,WAAaU,KAAiBe,EAAYiC,IAAoBF,EAAKJ,WAAalK,GAAY,CAClG,GAAI+I,GAAShC,EAAMgC,OAASuB,EAAKvB,OAC7BC,EAASjC,EAAMiC,OAASsB,EAAKtB,OAE7ByB,EAAIvB,EAAYX,EAAWQ,EAAQC,EACvCmB,GAAYM,EAAErB,EACdgB,EAAYK,EAAEnB,EACdY,EAAYX,GAAIkB,EAAErB,GAAKG,GAAIkB,EAAEnB,GAAMmB,EAAErB,EAAIqB,EAAEnB,EAC3Ce,EAAYvB,EAAaC,EAAQC,GAEjCvB,EAAQ8C,aAAexD,MAGvBmD,GAAWI,EAAKJ,SAChBC,EAAYG,EAAKH,UACjBC,EAAYE,EAAKF,UACjBC,EAAYC,EAAKD,SAGrBtD,GAAMmD,SAAWA,EACjBnD,EAAMoD,UAAYA,EAClBpD,EAAMqD,UAAYA,EAClBrD,EAAMsD,UAAYA,EAQtB,QAASrC,GAAqBjB,GAK1B,IAFA,GAAIE,MACAhJ,EAAI,EACDA,EAAI8I,EAAME,SAASpG,QACtBoG,EAAShJ,IACLyM,QAASC,GAAM5D,EAAME,SAAShJ,GAAGyM,SACjCE,QAASD,GAAM5D,EAAME,SAAShJ,GAAG2M,UAErC3M,GAGJ,QACIoK,UAAWC,KACXrB,SAAUA,EACVkB,OAAQC,EAAUnB,GAClB8B,OAAQhC,EAAMgC,OACdC,OAAQjC,EAAMiC,QAStB,QAASZ,GAAUnB,GACf,GAAIa,GAAiBb,EAASpG,MAG9B,IAAuB,IAAnBiH,EACA,OACIsB,EAAGuB,GAAM1D,EAAS,GAAGyD,SACrBpB,EAAGqB,GAAM1D,EAAS,GAAG2D,SAK7B,KADA,GAAIxB,GAAI,EAAGE,EAAI,EAAGrL,EAAI,EACfA,EAAI6J,GACPsB,GAAKnC,EAAShJ,GAAGyM,QACjBpB,GAAKrC,EAAShJ,GAAG2M,QACjB3M,GAGJ,QACImL,EAAGuB,GAAMvB,EAAItB,GACbwB,EAAGqB,GAAMrB,EAAIxB,IAWrB,QAASoB,GAAYX,EAAWa,EAAGE,GAC/B,OACIF,EAAGA,EAAIb,GAAa,EACpBe,EAAGA,EAAIf,GAAa,GAU5B,QAASO,GAAaM,EAAGE,GACrB,MAAIF,KAAME,EACCuB,GAGPtB,GAAIH,IAAMG,GAAID,GACPF,EAAI,EAAI0B,GAAiBC,GAE7BzB,EAAI,EAAI0B,GAAeC,GAUlC,QAAStC,GAAYuC,EAAIC,EAAIC,GACpBA,IACDA,EAAQC,GAEZ,IAAIjC,GAAI+B,EAAGC,EAAM,IAAMF,EAAGE,EAAM,IAC5B9B,EAAI6B,EAAGC,EAAM,IAAMF,EAAGE,EAAM,GAEhC,OAAOE,MAAKC,KAAMnC,EAAIA,EAAME,EAAIA,GAUpC,QAASb,GAASyC,EAAIC,EAAIC,GACjBA,IACDA,EAAQC,GAEZ,IAAIjC,GAAI+B,EAAGC,EAAM,IAAMF,EAAGE,EAAM,IAC5B9B,EAAI6B,EAAGC,EAAM,IAAMF,EAAGE,EAAM,GAChC,OAA0B,KAAnBE,KAAKE,MAAMlC,EAAGF,GAAWkC,KAAKG,GASzC,QAAS9B,GAAY+B,EAAOC,GACxB,MAAOlD,GAASkD,EAAI,GAAIA,EAAI,GAAIC,IAAmBnD,EAASiD,EAAM,GAAIA,EAAM,GAAIE,IAUpF,QAASnC,GAASiC,EAAOC,GACrB,MAAOhD,GAAYgD,EAAI,GAAIA,EAAI,GAAIC,IAAmBjD,EAAY+C,EAAM,GAAIA,EAAM,GAAIE,IAiB1F,QAAShF,KACLlF,KAAKmK,KAAOC,GACZpK,KAAKqK,MAAQC,GAEbtK,KAAKuK,SAAU,EAEfvG,EAAMjE,MAAMC,KAAMC,WAoEtB,QAAS4E,KACL7E,KAAKmK,KAAOK,GACZxK,KAAKqK,MAAQI,GAEbzG,EAAMjE,MAAMC,KAAMC,WAElBD,KAAK0K,MAAS1K,KAAKiE,QAAQ8B,QAAQ4E,iBAoEvC,QAASC,KACL5K,KAAK6K,SAAWC,GAChB9K,KAAKqK,MAAQU,GACb/K,KAAKgL,SAAU,EAEfhH,EAAMjE,MAAMC,KAAMC,WAsCtB,QAASgL,GAAuB1G,EAAIhD,GAChC,GAAI2J,GAAM1I,EAAQ+B,EAAG4G,SACjBC,EAAU5I,EAAQ+B,EAAG8G,eAMzB,OAJI9J,IAAQsE,GAAYC,MACpBoF,EAAMxI,EAAYwI,EAAII,OAAOF,GAAU,cAAc,KAGjDF,EAAKE,GAiBjB,QAASrG,KACL/E,KAAK6K,SAAWU,GAChBvL,KAAKwL,aAELxH,EAAMjE,MAAMC,KAAMC,WA0BtB,QAASwL,GAAWlH,EAAIhD,GACpB,GAAImK,GAAalJ,EAAQ+B,EAAG4G,SACxBK,EAAYxL,KAAKwL,SAGrB,IAAIjK,GAAQoE,GAAcgG,KAAqC,IAAtBD,EAAWvM,OAEhD,MADAqM,GAAUE,EAAW,GAAGE,aAAc,GAC9BF,EAAYA,EAGxB,IAAInP,GACAsP,EACAR,EAAiB7I,EAAQ+B,EAAG8G,gBAC5BS,KACA3K,EAASnB,KAAKmB,MAQlB,IALA0K,EAAgBH,EAAWK,OAAO,SAAUC,GACxC,MAAOrK,GAAUqK,EAAM7K,OAAQA,KAI/BI,IAASoE,GAET,IADApJ,EAAI,EACGA,EAAIsP,EAAc1M,QACrBqM,EAAUK,EAActP,GAAGqP,aAAc,EACzCrP,GAMR,KADAA,EAAI,EACGA,EAAI8O,EAAelM,QAClBqM,EAAUH,EAAe9O,GAAGqP,aAC5BE,EAAqB/I,KAAKsI,EAAe9O,IAIzCgF,GAAQsE,GAAYC,WACb0F,GAAUH,EAAe9O,GAAGqP,YAEvCrP,GAGJ,OAAKuP,GAAqB3M,QAMtBuD,EAAYmJ,EAAcP,OAAOQ,GAAuB,cAAc,GACtEA,OAPJ,GAwBJ,QAAS7G,KACLjB,EAAMjE,MAAMC,KAAMC,UAElB,IAAIoB,GAAUzC,EAAOoB,KAAKqB,QAASrB,KACnCA,MAAKgM,MAAQ,GAAIjH,GAAW/E,KAAKiE,QAAS5C,GAC1CrB,KAAKiM,MAAQ,GAAI/G,GAAWlF,KAAKiE,QAAS5C,GAE1CrB,KAAKkM,aAAe,KACpBlM,KAAKmM,eAqCT,QAASC,GAAchH,EAAWiH,GAC1BjH,EAAYO,IACZ3F,KAAKkM,aAAeG,EAAU5G,gBAAgB,GAAGmG,WACjDU,EAAa7P,KAAKuD,KAAMqM,IACjBjH,GAAaS,GAAYC,KAChCwG,EAAa7P,KAAKuD,KAAMqM,GAIhC,QAASC,GAAaD,GAClB,GAAIL,GAAQK,EAAU5G,gBAAgB,EAEtC,IAAIuG,EAAMJ,aAAe5L,KAAKkM,aAAc,CACxC,GAAIK,IAAa7E,EAAGsE,EAAMhD,QAASpB,EAAGoE,EAAM9C,QAC5ClJ,MAAKmM,YAAYpJ,KAAKwJ,EACtB,IAAIC,GAAMxM,KAAKmM,YACXM,EAAkB,WAClB,GAAIlQ,GAAIiQ,EAAItK,QAAQqK,EAChBhQ,IAAK,GACLiQ,EAAIE,OAAOnQ,EAAG,GAGtBoC,YAAW8N,EAAiBE,KAIpC,QAASC,GAAiBP,GAEtB,IAAK,GADD3E,GAAI2E,EAAUjE,SAASY,QAASpB,EAAIyE,EAAUjE,SAASc,QAClD3M,EAAI,EAAGA,EAAIyD,KAAKmM,YAAYhN,OAAQ5C,IAAK,CAC9C,GAAIsQ,GAAI7M,KAAKmM,YAAY5P,GACrBuQ,EAAKlD,KAAK/B,IAAIH,EAAImF,EAAEnF,GAAIqF,EAAKnD,KAAK/B,IAAID,EAAIiF,EAAEjF,EAChD,IAAIkF,GAAME,IAAkBD,GAAMC,GAC9B,OAAO,EAGf,OAAO,EAsBX,QAASC,GAAYhJ,EAASiJ,GAC1BlN,KAAKiE,QAAUA,EACfjE,KAAKmN,IAAID,GAmGb,QAASE,GAAkBC,GAEvB,GAAItL,EAAMsL,EAASC,IACf,MAAOA,GAGX,IAAIC,GAAUxL,EAAMsL,EAASG,IACzBC,EAAU1L,EAAMsL,EAASK,GAM7B,OAAIH,IAAWE,EACJH,GAIPC,GAAWE,EACJF,EAAUC,GAAqBE,GAItC3L,EAAMsL,EAASM,IACRA,GAGJC,GA2DX,QAASC,GAAWzJ,GAChBpE,KAAKoE,QAAU1D,MAAWV,KAAK8N,SAAU1J,OAEzCpE,KAAK+N,GAAKvK,IAEVxD,KAAKiE,QAAU,KAGfjE,KAAKoE,QAAQI,OAASzD,EAAYf,KAAKoE,QAAQI,QAAQ,GAEvDxE,KAAKgO,MAAQC,GAEbjO,KAAKkO,gBACLlO,KAAKmO,eAwOT,QAASC,GAASJ,GACd,MAAIA,GAAQK,GACD,SACAL,EAAQM,GACR,MACAN,EAAQO,GACR,OACAP,EAAQQ,GACR,QAEJ,GAQX,QAASC,IAAa9F,GAClB,MAAIA,IAAaY,GACN,OACAZ,GAAaW,GACb,KACAX,GAAaS,GACb,OACAT,GAAaU,GACb,QAEJ,GASX,QAASqF,IAA6BC,EAAiBC,GACnD,GAAI3K,GAAU2K,EAAW3K,OACzB,OAAIA,GACOA,EAAQ7G,IAAIuR,GAEhBA,EAQX,QAASE,MACLhB,EAAW9N,MAAMC,KAAMC,WA6D3B,QAAS6O,MACLD,GAAe9O,MAAMC,KAAMC,WAE3BD,KAAK+O,GAAK,KACV/O,KAAKgP,GAAK,KA4Ed,QAASC,MACLJ,GAAe9O,MAAMC,KAAMC,WAsC/B,QAASiP,MACLrB,EAAW9N,MAAMC,KAAMC,WAEvBD,KAAKmP,OAAS,KACdnP,KAAKoP,OAAS,KAmElB,QAASC,MACLR,GAAe9O,MAAMC,KAAMC,WA8B/B,QAASqP,MACLT,GAAe9O,MAAMC,KAAMC,WA2D/B,QAASsP,MACL1B,EAAW9N,MAAMC,KAAMC,WAIvBD,KAAKwP,OAAQ,EACbxP,KAAKyP,SAAU,EAEfzP,KAAKmP,OAAS,KACdnP,KAAKoP,OAAS,KACdpP,KAAK0P,MAAQ,EAqGjB,QAASC,IAAOhM,EAASS,GAGrB,MAFAA,GAAUA,MACVA,EAAQwL,YAAc7O,EAAYqD,EAAQwL,YAAaD,GAAO7B,SAAS+B,QAChE,GAAIC,IAAQnM,EAASS,GAiIhC,QAAS0L,IAAQnM,EAASS,GACtBpE,KAAKoE,QAAU1D,MAAWiP,GAAO7B,SAAU1J,OAE3CpE,KAAKoE,QAAQC,YAAcrE,KAAKoE,QAAQC,aAAeV,EAEvD3D,KAAK+P,YACL/P,KAAK+F,WACL/F,KAAK4P,eACL5P,KAAKgQ,eAELhQ,KAAK2D,QAAUA,EACf3D,KAAKqF,MAAQX,EAAoB1E,MACjCA,KAAKiQ,YAAc,GAAIhD,GAAYjN,KAAMA,KAAKoE,QAAQ6L,aAEtDC,GAAelQ,MAAM,GAErBf,EAAKe,KAAKoE,QAAQwL,YAAa,SAAUO,GACrC,GAAIvB,GAAa5O,KAAKoQ,IAAI,GAAKD,GAAK,GAAIA,EAAK,IAC7CA,GAAK,IAAMvB,EAAWyB,cAAcF,EAAK,IACzCA,EAAK,IAAMvB,EAAW0B,eAAeH,EAAK,KAC3CnQ,MA4PP,QAASkQ,IAAejM,EAASmM,GAC7B,GAAIzM,GAAUM,EAAQN,OACtB,IAAKA,EAAQ4M,MAAb,CAGA,GAAInN,EACJnE,GAAKgF,EAAQG,QAAQoM,SAAU,SAAUtD,EAAOrQ,GAC5CuG,EAAOF,EAASS,EAAQ4M,MAAO1T,GAC3BuT,GACAnM,EAAQ+L,YAAY5M,GAAQO,EAAQ4M,MAAMnN,GAC1CO,EAAQ4M,MAAMnN,GAAQ8J,GAEtBvJ,EAAQ4M,MAAMnN,GAAQa,EAAQ+L,YAAY5M,IAAS,KAGtDgN,IACDnM,EAAQ+L,iBAShB,QAASS,IAAgBC,EAAOC,GAC5B,GAAIC,GAAexS,EAASyS,YAAY,QACxCD,GAAaE,UAAUJ,GAAO,GAAM,GACpCE,EAAaG,QAAUJ,EACvBA,EAAKxP,OAAO6P,cAAcJ,GAxgF9B,GA+FIlQ,IA/FA6C,IAAmB,GAAI,SAAU,MAAO,KAAM,KAAM,KACpD0N,GAAe7S,EAAS8S,cAAc,OAEtCpQ,GAAgB,WAEhBmI,GAAQW,KAAKX,MACbpB,GAAM+B,KAAK/B,IACXjB,GAAMuK,KAAKvK,GA0FXlG,IADyB,kBAAlB1D,QAAO0D,OACL,SAAgBS,GACrB,GAAIA,IAAW7C,GAAwB,OAAX6C,EACxB,KAAM,IAAIiQ,WAAU,6CAIxB,KAAK,GADDC,GAASrU,OAAOmE,GACXmQ,EAAQ,EAAGA,EAAQrR,UAAUd,OAAQmS,IAAS,CACnD,GAAIC,GAAStR,UAAUqR,EACvB,IAAIC,IAAWjT,GAAwB,OAAXiT,EACxB,IAAK,GAAIC,KAAWD,GACZA,EAAO7T,eAAe8T,KACtBH,EAAOG,GAAWD,EAAOC,IAKzC,MAAOH,IAGFrU,OAAO0D,MAWpB,IAAI+Q,IAASrS,EAAU,SAAgBsS,EAAMpP,EAAKqP,GAG9C,IAFA,GAAIC,GAAO5U,OAAO4U,KAAKtP,GACnB/F,EAAI,EACDA,EAAIqV,EAAKzS,UACPwS,GAAUA,GAASD,EAAKE,EAAKrV,MAAQ+B,KACtCoT,EAAKE,EAAKrV,IAAM+F,EAAIsP,EAAKrV,KAE7BA,GAEJ,OAAOmV,IACR,SAAU,iBASTC,GAAQvS,EAAU,SAAesS,EAAMpP,GACvC,MAAOmP,IAAOC,EAAMpP,GAAK,IAC1B,QAAS,iBAiNRmB,GAAY,EAgBZoO,GAAe,wCAEf7M,GAAiB,gBAAkB7G,GACnCyG,GAAyB1B,EAAS/E,EAAQ,kBAAoBG,EAC9DwG,GAAqBE,IAAiB6M,GAAaC,KAAKC,UAAUC,WAOlElJ,GAAmB,GAEnBnD,GAAc,EACdgG,GAAa,EACb9F,GAAY,EACZC,GAAe,EAEfqD,GAAiB,EACjBC,GAAiB,EACjBC,GAAkB,EAClBC,GAAe,EACfC,GAAiB,GAEjB0I,GAAuB7I,GAAiBC,GACxC6I,GAAqB5I,GAAeC,GACpC4I,GAAgBF,GAAuBC,GAEvCvI,IAAY,IAAK,KACjBO,IAAmB,UAAW,UA4BlClG,GAAMvG,WAKF4D,QAAS,aAMToD,KAAM,WACFzE,KAAKmK,MAAQjJ,EAAkBlB,KAAK2D,QAAS3D,KAAKmK,KAAMnK,KAAKsE,YAC7DtE,KAAK6K,UAAY3J,EAAkBlB,KAAKmB,OAAQnB,KAAK6K,SAAU7K,KAAKsE,YACpEtE,KAAKqK,OAASnJ,EAAkBwC,EAAoB1D,KAAK2D,SAAU3D,KAAKqK,MAAOrK,KAAKsE,aAMxF8N,QAAS,WACLpS,KAAKmK,MAAQ1I,EAAqBzB,KAAK2D,QAAS3D,KAAKmK,KAAMnK,KAAKsE,YAChEtE,KAAK6K,UAAYpJ,EAAqBzB,KAAKmB,OAAQnB,KAAK6K,SAAU7K,KAAKsE,YACvEtE,KAAKqK,OAAS5I,EAAqBiC,EAAoB1D,KAAK2D,SAAU3D,KAAKqK,MAAOrK,KAAKsE,aA4T/F,IAAI+N,KACAC,UAAW3M,GACX4M,UAAW5G,GACX6G,QAAS3M,IAGTuE,GAAuB,YACvBE,GAAsB,mBAgB1BpK,GAAQgF,EAAYlB,GAKhB3C,QAAS,SAAmBkD,GACxB,GAAIa,GAAYiN,GAAgB9N,EAAGhD,KAG/B6D,GAAYO,IAA6B,IAAdpB,EAAGkO,SAC9BzS,KAAKuK,SAAU,GAGfnF,EAAYuG,IAA2B,IAAbpH,EAAGmO,QAC7BtN,EAAYS,IAIX7F,KAAKuK,UAINnF,EAAYS,KACZ7F,KAAKuK,SAAU,GAGnBvK,KAAKkE,SAASlE,KAAKiE,QAASmB,GACxBG,UAAWhB,GACXkB,iBAAkBlB,GAClBoO,YAxbW,QAybXvK,SAAU7D,OAKtB,IAAIqO,KACAC,YAAalN,GACbmN,YAAanH,GACboH,UAAWlN,GACXmN,cAAelN,GACfmN,WAAYnN,IAIZoN,IACAC,EA1cmB,QA2cnBC,EA1ciB,MA2cjBC,EA1cmB,QA2cnBC,EA1coB,UA6cpB9I,GAAyB,cACzBC,GAAwB,qCAGxBtM,GAAOoV,iBAAmBpV,EAAOqV,eACjChJ,GAAyB,gBACzBC,GAAwB,6CAiB5BvK,EAAQ2E,EAAmBb,GAKvB3C,QAAS,SAAmBkD,GACxB,GAAImG,GAAQ1K,KAAK0K,MACb+I,GAAgB,EAEhBC,EAAsBnP,EAAGhD,KAAKoS,cAAchU,QAAQ,KAAM,IAC1DyF,EAAYwN,GAAkBc,GAC9Bf,EAAcO,GAAuB3O,EAAGoO,cAAgBpO,EAAGoO,YAE3DiB,EApfW,SAofAjB,EAGXkB,EAAaxR,EAAQqI,EAAOnG,EAAGuP,UAAW,YAG1C1O,GAAYO,KAA8B,IAAdpB,EAAGkO,QAAgBmB,GAC3CC,EAAa,IACbnJ,EAAM3H,KAAKwB,GACXsP,EAAanJ,EAAMvL,OAAS,GAEzBiG,GAAaS,GAAYC,MAChC2N,GAAgB,GAIhBI,EAAa,IAKjBnJ,EAAMmJ,GAActP,EAEpBvE,KAAKkE,SAASlE,KAAKiE,QAASmB,GACxBG,SAAUmF,EACVjF,iBAAkBlB,GAClBoO,YAAaA,EACbvK,SAAU7D,IAGVkP,GAEA/I,EAAMgC,OAAOmH,EAAY,MAKrC,IAAIE,KACAC,WAAYrO,GACZsO,UAAWtI,GACXuI,SAAUrO,GACVsO,YAAarO,IAGbgF,GAA6B,aAC7BC,GAA6B,2CAejC7K,GAAQ0K,EAAkB5G,GACtB3C,QAAS,SAAmBkD,GACxB,GAAIhD,GAAOwS,GAAuBxP,EAAGhD,KAOrC,IAJIA,IAASoE,KACT3F,KAAKgL,SAAU,GAGdhL,KAAKgL,QAAV,CAIA,GAAIG,GAAUF,EAAuBxO,KAAKuD,KAAMuE,EAAIhD,EAGhDA,IAAQsE,GAAYC,KAAiBqF,EAAQ,GAAGhM,OAASgM,EAAQ,GAAGhM,QAAW,IAC/Ea,KAAKgL,SAAU,GAGnBhL,KAAKkE,SAASlE,KAAKiE,QAAS1C,GACxBgE,SAAU4F,EAAQ,GAClB1F,gBAAiB0F,EAAQ,GACzBwH,YAvkBW,QAwkBXvK,SAAU7D,OAsBtB,IAAI6P,KACAJ,WAAYrO,GACZsO,UAAWtI,GACXuI,SAAUrO,GACVsO,YAAarO,IAGbyF,GAAsB,2CAc1BrL,GAAQ6E,EAAYf,GAChB3C,QAAS,SAAoBkD,GACzB,GAAIhD,GAAO6S,GAAgB7P,EAAGhD,MAC1B4J,EAAUM,EAAWhP,KAAKuD,KAAMuE,EAAIhD,EACnC4J,IAILnL,KAAKkE,SAASlE,KAAKiE,QAAS1C,GACxBgE,SAAU4F,EAAQ,GAClB1F,gBAAiB0F,EAAQ,GACzBwH,YA9nBW,QA+nBXvK,SAAU7D,MA4EtB,IAAIoI,IAAgB,KAChBK,GAAiB,EAarB9M,GAAQ+E,EAAiBjB,GAOrB3C,QAAS,SAAoB4C,EAASoQ,EAAYC,GAC9C,GAAIV,GAjuBW,SAiuBAU,EAAU3B,YACrB4B,EAhuBW,SAguBAD,EAAU3B,WAEzB,MAAI4B,GAAWD,EAAUE,oBAAsBF,EAAUE,mBAAmBC,kBAA5E,CAKA,GAAIb,EACAxH,EAAc3P,KAAKuD,KAAMqU,EAAYC,OAClC,IAAIC,GAAW3H,EAAiBnQ,KAAKuD,KAAMsU,GAC9C,MAGJtU,MAAKkE,SAASD,EAASoQ,EAAYC,KAMvClC,QAAS,WACLpS,KAAKgM,MAAMoG,UACXpS,KAAKiM,MAAMmG,YA0CnB,IAAIsC,IAAwBxR,EAAS+N,GAAaV,MAAO,eACrDoE,GAAsBD,KAA0BpW,EAIhDsP,GAAoB,OACpBD,GAA4B,eAC5BL,GAAoB,OACpBE,GAAqB,QACrBE,GAAqB,QACrBkH,GA4IJ,WACI,IAAKD,GACD,OAAO,CAEX,IAAIE,MACAC,EAAc3W,EAAO4W,KAAO5W,EAAO4W,IAAIC,QAO3C,QANC,OAAQ,eAAgB,QAAS,QAAS,cAAe,QAAQ9V,QAAQ,SAAU0B,GAIhFiU,EAASjU,IAAOkU,GAAc3W,EAAO4W,IAAIC,SAAS,eAAgBpU,KAE/DiU,IA1IX5H,GAAYxP,WAKR0P,IAAK,SAAUD,GAzBQ,WA2BfA,IACAA,EAAQlN,KAAKiV,WAGbN,IAAuB3U,KAAKiE,QAAQN,QAAQ4M,OAASqE,GAAiB1H,KACtElN,KAAKiE,QAAQN,QAAQ4M,MAAMmE,IAAyBxH,GAExDlN,KAAKqN,QAAUH,EAAMyG,cAAcxR,QAMvC+S,OAAQ,WACJlV,KAAKmN,IAAInN,KAAKiE,QAAQG,QAAQ6L,cAOlCgF,QAAS,WACL,GAAI5H,KAMJ,OALApO,GAAKe,KAAKiE,QAAQ2L,YAAa,SAAUhB,GACjCjO,EAASiO,EAAWxK,QAAQI,QAASoK,MACrCvB,EAAUA,EAAQ/B,OAAOsD,EAAWuG,qBAGrC/H,EAAkBC,EAAQ+H,KAAK,OAO1CC,gBAAiB,SAAUhQ,GACvB,GAAI+C,GAAW/C,EAAM+C,SACjBO,EAAYtD,EAAM8B,eAGtB,IAAInH,KAAKiE,QAAQ8B,QAAQuP,UAErB,WADAlN,GAASmN,gBAIb,IAAIlI,GAAUrN,KAAKqN,QACfmI,EAAUzT,EAAMsL,EAASC,MAAuBsH,GAAiBtH,IACjEG,EAAU1L,EAAMsL,EAASK,MAAwBkH,GAAiBlH,IAClEH,EAAUxL,EAAMsL,EAASG,MAAwBoH,GAAiBpH,GAEtE,IAAIgI,EAAS,CAGT,GAAIC,GAAyC,IAA1BpQ,EAAME,SAASpG,OAC9BuW,EAAgBrQ,EAAM2B,SAAW,EACjC2O,EAAiBtQ,EAAMwB,UAAY,GAEvC,IAAI4O,GAAgBC,GAAiBC,EACjC,OAIR,MAAIpI,IAAWE,MAAf,GAKI+H,GACC/H,GAAW9E,EAAYsJ,IACvB1E,GAAW5E,EAAYuJ,GACjBlS,KAAK4V,WAAWxN,OAH3B,IAWJwN,WAAY,SAAUxN,GAClBpI,KAAKiE,QAAQ8B,QAAQuP,WAAY,EACjClN,EAASmN,kBAiFjB,IAAItH,IAAiB,EACjBO,GAAc,EACdD,GAAgB,EAChBD,GAAc,EACduH,GAAmBvH,GACnBD,GAAkB,EAyBtBR,GAAWpQ,WAKPqQ,YAOAX,IAAK,SAAU/I,GAKX,MAJA1D,IAAOV,KAAKoE,QAASA,GAGrBpE,KAAKiE,SAAWjE,KAAKiE,QAAQgM,YAAYiF,SAClClV,MAQXqQ,cAAe,SAAU1B,GACrB,GAAI9P,EAAe8P,EAAiB,gBAAiB3O,MACjD,MAAOA,KAGX,IAAIkO,GAAelO,KAAKkO,YAMxB,OALAS,GAAkBD,GAA6BC,EAAiB3O,MAC3DkO,EAAaS,EAAgBZ,MAC9BG,EAAaS,EAAgBZ,IAAMY,EACnCA,EAAgB0B,cAAcrQ,OAE3BA,MAQX8V,kBAAmB,SAAUnH,GACzB,MAAI9P,GAAe8P,EAAiB,oBAAqB3O,MAC9CA,MAGX2O,EAAkBD,GAA6BC,EAAiB3O,YACzDA,MAAKkO,aAAaS,EAAgBZ,IAClC/N,OAQXsQ,eAAgB,SAAU3B,GACtB,GAAI9P,EAAe8P,EAAiB,iBAAkB3O,MAClD,MAAOA,KAGX,IAAImO,GAAcnO,KAAKmO,WAMvB,OALAQ,GAAkBD,GAA6BC,EAAiB3O,OACjB,IAA3CqC,EAAQ8L,EAAaQ,KACrBR,EAAYpL,KAAK4L,GACjBA,EAAgB2B,eAAetQ,OAE5BA,MAQX+V,mBAAoB,SAAUpH,GAC1B,GAAI9P,EAAe8P,EAAiB,qBAAsB3O,MACtD,MAAOA,KAGX2O,GAAkBD,GAA6BC,EAAiB3O,KAChE,IAAIsR,GAAQjP,EAAQrC,KAAKmO,YAAaQ,EAItC,OAHI2C,IAAS,GACTtR,KAAKmO,YAAYzB,OAAO4E,EAAO,GAE5BtR,MAOXgW,mBAAoB,WAChB,MAAOhW,MAAKmO,YAAYhP,OAAS,GAQrC8W,iBAAkB,SAAUtH,GACxB,QAAS3O,KAAKkO,aAAaS,EAAgBZ,KAQ/C9H,KAAM,SAAUZ,GAIZ,QAASY,GAAKyK,GACVvM,EAAKF,QAAQgC,KAAKyK,EAAOrL,GAJ7B,GAAIlB,GAAOnE,KACPgO,EAAQhO,KAAKgO,KAObA,GAAQM,IACRrI,EAAK9B,EAAKC,QAAQsM,MAAQtC,EAASJ,IAGvC/H,EAAK9B,EAAKC,QAAQsM,OAEdrL,EAAM6Q,iBACNjQ,EAAKZ,EAAM6Q,iBAIXlI,GAASM,IACTrI,EAAK9B,EAAKC,QAAQsM,MAAQtC,EAASJ,KAU3CmI,QAAS,SAAU9Q,GACf,GAAIrF,KAAKoW,UACL,MAAOpW,MAAKiG,KAAKZ,EAGrBrF,MAAKgO,MA7KM,IAoLfoI,QAAS,WAEL,IADA,GAAI7Z,GAAI,EACDA,EAAIyD,KAAKmO,YAAYhP,QAAQ,CAChC,KAAMa,KAAKmO,YAAY5R,GAAGyR,OAvLnB,GAuL2CC,KAC9C,OAAO,CAEX1R,KAEJ,OAAO,GAOX2J,UAAW,SAAUoO,GAGjB,GAAI+B,GAAiB3V,MAAW4T,EAGhC,KAAK3T,EAASX,KAAKoE,QAAQI,QAASxE,KAAMqW,IAGtC,MAFArW,MAAKsW,aACLtW,KAAKgO,MA3ME,GAgNPhO,MAAKgO,OAAS6H,GAAmBxH,GAhN1B,MAiNPrO,KAAKgO,MAAQC,IAGjBjO,KAAKgO,MAAQhO,KAAKuW,QAAQF,GAItBrW,KAAKgO,OAASQ,GAAcD,GAAgBD,GAAcD,KAC1DrO,KAAKmW,QAAQE,IAWrBE,QAAS,SAAUjC,KAQnBa,eAAgB,aAQhBmB,MAAO,cA+DXpW,EAAQ2O,GAAgBhB,GAKpBC,UAKIvI,SAAU,GASdiR,SAAU,SAAUnR,GAChB,GAAIoR,GAAiBzW,KAAKoE,QAAQmB,QAClC,OAA0B,KAAnBkR,GAAwBpR,EAAME,SAASpG,SAAWsX,GAS7DF,QAAS,SAAUlR,GACf,GAAI2I,GAAQhO,KAAKgO,MACb5I,EAAYC,EAAMD,UAElBsR,EAAe1I,GAASQ,GAAcD,IACtCoI,EAAU3W,KAAKwW,SAASnR,EAG5B,OAAIqR,KAAiBtR,EAAYU,KAAiB6Q,GACvC3I,EAAQK,GACRqI,GAAgBC,EACnBvR,EAAYS,GACLmI,EAAQM,GACNN,EAAQQ,GAGdR,EAAQO,GAFJC,GA/VJ,MAoXnBtO,EAAQ4O,GAAeD,IAKnBf,UACI4C,MAAO,MACPkG,UAAW,GACXrR,SAAU,EACVoD,UAAWwJ,IAGfgD,eAAgB,WACZ,GAAIxM,GAAY3I,KAAKoE,QAAQuE,UACzB0E,IAOJ,OANI1E,GAAYsJ,IACZ5E,EAAQtK,KAAK2K,IAEb/E,EAAYuJ,IACZ7E,EAAQtK,KAAKyK,IAEVH,GAGXwJ,cAAe,SAAUxR,GACrB,GAAIjB,GAAUpE,KAAKoE,QACf0S,GAAW,EACX9P,EAAW3B,EAAM2B,SACjB2B,EAAYtD,EAAMsD,UAClBjB,EAAIrC,EAAMgC,OACVO,EAAIvC,EAAMiC,MAed,OAZMqB,GAAYvE,EAAQuE,YAClBvE,EAAQuE,UAAYsJ,IACpBtJ,EAAmB,IAANjB,EAAWyB,GAAkBzB,EAAI,EAAK0B,GAAiBC,GACpEyN,EAAWpP,GAAK1H,KAAK+O,GACrB/H,EAAW4C,KAAK/B,IAAIxC,EAAMgC,UAE1BsB,EAAmB,IAANf,EAAWuB,GAAkBvB,EAAI,EAAK0B,GAAeC,GAClEuN,EAAWlP,GAAK5H,KAAKgP,GACrBhI,EAAW4C,KAAK/B,IAAIxC,EAAMiC,UAGlCjC,EAAMsD,UAAYA,EACXmO,GAAY9P,EAAW5C,EAAQwS,WAAajO,EAAYvE,EAAQuE,WAG3E6N,SAAU,SAAUnR,GAChB,MAAOwJ,IAAepR,UAAU+Y,SAAS/Z,KAAKuD,KAAMqF,KAC/CrF,KAAKgO,MAAQQ,MAAkBxO,KAAKgO,MAAQQ,KAAgBxO,KAAK6W,cAAcxR,KAGxFY,KAAM,SAAUZ,GAEZrF,KAAK+O,GAAK1J,EAAMgC,OAChBrH,KAAKgP,GAAK3J,EAAMiC,MAEhB,IAAIqB,GAAY8F,GAAapJ,EAAMsD,UAE/BA,KACAtD,EAAM6Q,gBAAkBlW,KAAKoE,QAAQsM,MAAQ/H,GAEjD3I,KAAKS,OAAOwF,KAAKxJ,KAAKuD,KAAMqF,MAcpCnF,EAAQ+O,GAAiBJ,IAKrBf,UACI4C,MAAO,QACPkG,UAAW,EACXrR,SAAU,GAGd4P,eAAgB,WACZ,OAAQ7H,KAGZkJ,SAAU,SAAUnR,GAChB,MAAOrF,MAAKS,OAAO+V,SAAS/Z,KAAKuD,KAAMqF,KAClCuE,KAAK/B,IAAIxC,EAAMyC,MAAQ,GAAK9H,KAAKoE,QAAQwS,WAAa5W,KAAKgO,MAAQQ,KAG5EvI,KAAM,SAAUZ,GACZ,GAAoB,IAAhBA,EAAMyC,MAAa,CACnB,GAAIiP,GAAQ1R,EAAMyC,MAAQ,EAAI,KAAO,KACrCzC,GAAM6Q,gBAAkBlW,KAAKoE,QAAQsM,MAAQqG,EAEjD/W,KAAKS,OAAOwF,KAAKxJ,KAAKuD,KAAMqF,MAiBpCnF,EAAQgP,GAAiBrB,GAKrBC,UACI4C,MAAO,QACPnL,SAAU,EACVyR,KAAM,IACNJ,UAAW,GAGfzB,eAAgB,WACZ,OAAQvH,KAGZ2I,QAAS,SAAUlR,GACf,GAAIjB,GAAUpE,KAAKoE,QACf6S,EAAgB5R,EAAME,SAASpG,SAAWiF,EAAQmB,SAClD2R,EAAgB7R,EAAM2B,SAAW5C,EAAQwS,UACzCO,EAAY9R,EAAMwB,UAAYzC,EAAQ4S,IAM1C,IAJAhX,KAAKoP,OAAS/J,GAIT6R,IAAkBD,GAAkB5R,EAAMD,WAAaS,GAAYC,MAAkBqR,EACtFnX,KAAKsW,YACF,IAAIjR,EAAMD,UAAYO,GACzB3F,KAAKsW,QACLtW,KAAKmP,OAAS5Q,EAAkB,WAC5ByB,KAAKgO,MAAQ6H,GACb7V,KAAKmW,WACN/R,EAAQ4S,KAAMhX,UACd,IAAIqF,EAAMD,UAAYS,GACzB,MAAOgQ,GAEX,OAhhBW,KAmhBfS,MAAO,WACHc,aAAapX,KAAKmP,SAGtBlJ,KAAM,SAAUZ,GACRrF,KAAKgO,QAAU6H,KAIfxQ,GAAUA,EAAMD,UAAYS,GAC5B7F,KAAKiE,QAAQgC,KAAKjG,KAAKoE,QAAQsM,MAAQ,KAAMrL,IAE7CrF,KAAKoP,OAAOzI,UAAYC,KACxB5G,KAAKiE,QAAQgC,KAAKjG,KAAKoE,QAAQsM,MAAO1Q,KAAKoP,aAevDlP,EAAQmP,GAAkBR,IAKtBf,UACI4C,MAAO,SACPkG,UAAW,EACXrR,SAAU,GAGd4P,eAAgB,WACZ,OAAQ7H,KAGZkJ,SAAU,SAAUnR,GAChB,MAAOrF,MAAKS,OAAO+V,SAAS/Z,KAAKuD,KAAMqF,KAClCuE,KAAK/B,IAAIxC,EAAM2C,UAAYhI,KAAKoE,QAAQwS,WAAa5W,KAAKgO,MAAQQ,OAc/EtO,EAAQoP,GAAiBT,IAKrBf,UACI4C,MAAO,QACPkG,UAAW,GACXpO,SAAU,GACVG,UAAWsJ,GAAuBC,GAClC3M,SAAU,GAGd4P,eAAgB,WACZ,MAAOrG,IAAcrR,UAAU0X,eAAe1Y,KAAKuD,OAGvDwW,SAAU,SAAUnR,GAChB,GACImD,GADAG,EAAY3I,KAAKoE,QAAQuE,SAW7B,OARIA,IAAasJ,GAAuBC,IACpC1J,EAAWnD,EAAMkC,gBACVoB,EAAYsJ,GACnBzJ,EAAWnD,EAAMoC,iBACVkB,EAAYuJ,KACnB1J,EAAWnD,EAAMsC,kBAGd3H,KAAKS,OAAO+V,SAAS/Z,KAAKuD,KAAMqF,IACnCsD,EAAYtD,EAAM8B,iBAClB9B,EAAM2B,SAAWhH,KAAKoE,QAAQwS,WAC9BvR,EAAM6C,aAAelI,KAAKoE,QAAQmB,UAClCsC,GAAIW,GAAYxI,KAAKoE,QAAQoE,UAAYnD,EAAMD,UAAYS,IAGnEI,KAAM,SAAUZ,GACZ,GAAIsD,GAAY8F,GAAapJ,EAAM8B,gBAC/BwB,IACA3I,KAAKiE,QAAQgC,KAAKjG,KAAKoE,QAAQsM,MAAQ/H,EAAWtD,GAGtDrF,KAAKiE,QAAQgC,KAAKjG,KAAKoE,QAAQsM,MAAOrL,MA2B9CnF,EAAQqP,GAAe1B,GAKnBC,UACI4C,MAAO,MACPnL,SAAU,EACV8R,KAAM,EACNC,SAAU,IACVN,KAAM,IACNJ,UAAW,EACXW,aAAc,IAGlBpC,eAAgB,WACZ,OAAQxH,KAGZ4I,QAAS,SAAUlR,GACf,GAAIjB,GAAUpE,KAAKoE,QAEf6S,EAAgB5R,EAAME,SAASpG,SAAWiF,EAAQmB,SAClD2R,EAAgB7R,EAAM2B,SAAW5C,EAAQwS,UACzCY,EAAiBnS,EAAMwB,UAAYzC,EAAQ4S,IAI/C,IAFAhX,KAAKsW,QAEAjR,EAAMD,UAAYO,IAAgC,IAAf3F,KAAK0P,MACzC,MAAO1P,MAAKyX,aAKhB,IAAIP,GAAiBM,GAAkBP,EAAe,CAClD,GAAI5R,EAAMD,WAAaS,GACnB,MAAO7F,MAAKyX,aAGhB,IAAIC,IAAgB1X,KAAKwP,OAASnK,EAAMsB,UAAY3G,KAAKwP,MAAQpL,EAAQkT,SACrEK,GAAiB3X,KAAKyP,SAAWxI,EAAYjH,KAAKyP,QAASpK,EAAMoB,QAAUrC,EAAQmT,YAEvFvX,MAAKwP,MAAQnK,EAAMsB,UACnB3G,KAAKyP,QAAUpK,EAAMoB,OAEhBkR,GAAkBD,EAGnB1X,KAAK0P,OAAS,EAFd1P,KAAK0P,MAAQ,EAKjB1P,KAAKoP,OAAS/J,CAKd,IAAiB,IADFrF,KAAK0P,MAAQtL,EAAQiT,KAIhC,MAAKrX,MAAKgW,sBAGNhW,KAAKmP,OAAS5Q,EAAkB,WAC5ByB,KAAKgO,MAAQ6H,GACb7V,KAAKmW,WACN/R,EAAQkT,SAAUtX,MACdwO,IANAqH,GAUnB,MAztBW,KA4tBf4B,YAAa,WAIT,MAHAzX,MAAKmP,OAAS5Q,EAAkB,WAC5ByB,KAAKgO,MA9tBE,IA+tBRhO,KAAKoE,QAAQkT,SAAUtX,MA/tBf,IAmuBfsW,MAAO,WACHc,aAAapX,KAAKmP,SAGtBlJ,KAAM,WACEjG,KAAKgO,OAAS6H,KACd7V,KAAKoP,OAAOwI,SAAW5X,KAAK0P,MAC5B1P,KAAKiE,QAAQgC,KAAKjG,KAAKoE,QAAQsM,MAAO1Q,KAAKoP,YAoBvDO,GAAOkI,QAAU,QAMjBlI,GAAO7B,UAOHgK,WAAW,EAQX7H,YAr9BuB,UA29BvBzL,QAAQ,EASRH,YAAa,KAObM,WAAY,KAOZkL,SAEKR,IAAmB7K,QAAQ,KAC3ByK,IAAkBzK,QAAQ,IAAS,YACnC8K,IAAkB3G,UAAWsJ,MAC7BnD,IAAgBnG,UAAWsJ,KAAwB,WACnD1C,KACAA,IAAgBmB,MAAO,YAAa2G,KAAM,IAAK,SAC/CnI,KAQLsB,UAMIuH,WAAY,OAOZC,YAAa,OASbC,aAAc,OAOdC,eAAgB,OAOhBC,SAAU,OAQVC,kBAAmB,iBAoC3BtI,IAAQrS,WAMJ0P,IAAK,SAAU/I,GAaX,MAZA1D,IAAOV,KAAKoE,QAASA,GAGjBA,EAAQ6L,aACRjQ,KAAKiQ,YAAYiF,SAEjB9Q,EAAQC,cAERrE,KAAKqF,MAAM+M,UACXpS,KAAKqF,MAAMlE,OAASiD,EAAQC,YAC5BrE,KAAKqF,MAAMZ,QAERzE,MASXqY,KAAM,SAAUC,GACZtY,KAAK+F,QAAQwS,QAAUD,EA5Db,EADP,GAsEPpS,UAAW,SAAUoO,GACjB,GAAIvO,GAAU/F,KAAK+F,OACnB,KAAIA,EAAQwS,QAAZ,CAKAvY,KAAKiQ,YAAYoF,gBAAgBf,EAEjC,IAAI1F,GACAgB,EAAc5P,KAAK4P,YAKnB4I,EAAgBzS,EAAQyS,gBAIvBA,GAAkBA,GAAiBA,EAAcxK,MAAQ6H,MAC1D2C,EAAgBzS,EAAQyS,cAAgB,KAI5C,KADA,GAAIjc,GAAI,EACDA,EAAIqT,EAAYzQ,QACnByP,EAAagB,EAAYrT,GA9FnB,IAsGFwJ,EAAQwS,SACPC,GAAiB5J,GAAc4J,IAChC5J,EAAWqH,iBAAiBuC,GAG5B5J,EAAW0H,QAFX1H,EAAW1I,UAAUoO,IAOpBkE,GAAiB5J,EAAWZ,OAASQ,GAAcD,GAAgBD,MACpEkK,EAAgBzS,EAAQyS,cAAgB5J,GAE5CrS,MASRa,IAAK,SAAUwR,GACX,GAAIA,YAAsBf,GACtB,MAAOe,EAIX,KAAK,GADDgB,GAAc5P,KAAK4P,YACdrT,EAAI,EAAGA,EAAIqT,EAAYzQ,OAAQ5C,IACpC,GAAIqT,EAAYrT,GAAG6H,QAAQsM,OAAS9B,EAChC,MAAOgB,GAAYrT,EAG3B,OAAO,OASX6T,IAAK,SAAUxB,GACX,GAAI/P,EAAe+P,EAAY,MAAO5O,MAClC,MAAOA,KAIX,IAAIyY,GAAWzY,KAAK5C,IAAIwR,EAAWxK,QAAQsM,MAS3C,OARI+H,IACAzY,KAAK0Y,OAAOD,GAGhBzY,KAAK4P,YAAY7M,KAAK6L,GACtBA,EAAW3K,QAAUjE,KAErBA,KAAKiQ,YAAYiF,SACVtG,GAQX8J,OAAQ,SAAU9J,GACd,GAAI/P,EAAe+P,EAAY,SAAU5O,MACrC,MAAOA,KAMX,IAHA4O,EAAa5O,KAAK5C,IAAIwR,GAGN,CACZ,GAAIgB,GAAc5P,KAAK4P,YACnB0B,EAAQjP,EAAQuN,EAAahB,IAElB,IAAX0C,IACA1B,EAAYlD,OAAO4E,EAAO,GAC1BtR,KAAKiQ,YAAYiF,UAIzB,MAAOlV,OASX2Y,GAAI,SAAUC,EAAQvX,GAClB,GAAIuX,IAAWta,GAGX+C,IAAY/C,EAAhB,CAIA,GAAIyR,GAAW/P,KAAK+P,QAKpB,OAJA9Q,GAAKqC,EAASsX,GAAS,SAAUlI,GAC7BX,EAASW,GAASX,EAASW,OAC3BX,EAASW,GAAO3N,KAAK1B,KAElBrB,OASX6Y,IAAK,SAAUD,EAAQvX,GACnB,GAAIuX,IAAWta,EAAf,CAIA,GAAIyR,GAAW/P,KAAK+P,QAQpB,OAPA9Q,GAAKqC,EAASsX,GAAS,SAAUlI,GACxBrP,EAGD0O,EAASW,IAAUX,EAASW,GAAOhE,OAAOrK,EAAQ0N,EAASW,GAAQrP,GAAU,SAFtE0O,GAASW,KAKjB1Q,OAQXiG,KAAM,SAAUyK,EAAOC,GAEf3Q,KAAKoE,QAAQ0T,WACbrH,GAAgBC,EAAOC,EAI3B,IAAIZ,GAAW/P,KAAK+P,SAASW,IAAU1Q,KAAK+P,SAASW,GAAOjO,OAC5D,IAAKsN,GAAaA,EAAS5Q,OAA3B,CAIAwR,EAAKpP,KAAOmP,EACZC,EAAK4E,eAAiB,WAClB5E,EAAKvI,SAASmN,iBAIlB,KADA,GAAIhZ,GAAI,EACDA,EAAIwT,EAAS5Q,QAChB4Q,EAASxT,GAAGoU,GACZpU,MAQR6V,QAAS,WACLpS,KAAK2D,SAAWuM,GAAelQ,MAAM,GAErCA,KAAK+P,YACL/P,KAAK+F,WACL/F,KAAKqF,MAAM+M,UACXpS,KAAK2D,QAAU,OAyCvBjD,GAAOiP,IACHhK,YAAaA,GACbgG,WAAYA,GACZ9F,UAAWA,GACXC,aAAcA,GAEdmI,eAAgBA,GAChBO,YAAaA,GACbD,cAAeA,GACfD,YAAaA,GACbuH,iBAAkBA,GAClBxH,gBAAiBA,GACjByK,aArrCe,GAurCf3P,eAAgBA,GAChBC,eAAgBA,GAChBC,gBAAiBA,GACjBC,aAAcA,GACdC,eAAgBA,GAChB0I,qBAAsBA,GACtBC,mBAAoBA,GACpBC,cAAeA,GAEfrC,QAASA,GACT9L,MAAOA,EACPiJ,YAAaA,EAEblI,WAAYA,EACZG,WAAYA,EACZL,kBAAmBA,EACnBI,gBAAiBA,EACjB2F,iBAAkBA,EAElBiD,WAAYA,EACZgB,eAAgBA,GAChBkK,IAAKxJ,GACLyJ,IAAKlK,GACLmK,MAAO3J,GACP4J,MAAOjK,GACPkK,OAAQ9J,GACR+J,MAAOlK,GAEPyJ,GAAIzX,EACJ2X,IAAKpX,EACLxC,KAAMA,EACN0S,MAAOA,GACPF,OAAQA,GACR/Q,OAAQA,GACRR,QAASA,EACTtB,OAAQA,EACRsE,SAAUA,SAKsB,KAAX/E,EAAyBA,EAA0B,mBAATgG,MAAuBA,SAC/EwL,OAASA,GAEE,kBAAX0J,SAAyBnd,EAAA,GAChCmd,OAAO,WACH,MAAO1J,UAEa,KAAVrT,GAAyBA,EAAOD,QAC9CC,EAAOD,QAAUsT,GAEjBxR,EAAA,OAAqBwR,IAE1BxR,OAAQC,UAEXP,EAAA,EAAeM,OAAf,SFwD6B1B,KAAKoB,EAAqB3B,EAAoB,GAAGI,KAIxE,SAAUA,EAAQuB,EAAqB3B,GAE7C,YGtoFA,SAASod,GAAMC,EAAUC,GAErB,MADAA,GAAKA,GAAMpb,SACJob,EAAGC,iBAAiBF,GAG/B,QAASG,GAAc/V,GACnB,GAAIgW,GAAgBhW,EAAQ7B,UACxB6X,IACAA,EAAcC,YAAYjW,GAIlC,QAASkW,GAAkBL,EAAI9R,EAAGE,GAC9B4R,EAAGjJ,MAAMuJ,GAAT,eAAyCpS,EAAI,MAAQE,EAAI,QAG7D,QAASmS,GAA0BP,EAAI1R,EAAOJ,EAAGE,GAC7C4R,EAAGjJ,MAAMuJ,GAAT,WAAqChS,EAArC,IAA8CA,EAA9C,mBAAsEJ,EAAI,MAAQE,EAAI,QHwqF1F,QAASoS,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAI9I,WAAU,qCA2ChH,QAAS+I,GAAsBF,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAI9I,WAAU,qCAgGtH,QAASgJ,GAAuBH,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAI9I,WAAU,qCAwPvH,QAASiJ,GAA4BJ,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAI9I,WAAU,qCArb5HpU,OAAOC,eAAeY,EAAqB,cAAgBqP,OAAO,GIlpFlE,IAAIoN,GAAQ,SAACC,GACTpc,OAAO0B,QAAQD,IAAI,iBAAmB2a,IDDtCT,EAAiB,WACjB,GAAIpQ,IAAS,YAAa,kBAAmB,eAAgB,aAAc,eACvE6G,EAAQnS,SAAS8S,cAAc,OAAOX,MAAOiK,EAAY,EAM7D,OALA9Q,GAAMxK,QAAQ,SAAUkE,OACA9E,KAAhBiS,EAAMnN,KACNoX,EAAYpX,KAGboX,KEPLC,EAAY,aLisFdC,EAAe,WAAc,QAASC,GAAiBxZ,EAAQuI,GAAS,IAAK,GAAInN,GAAI,EAAGA,EAAImN,EAAMvK,OAAQ5C,IAAK,CAAE,GAAIqe,GAAalR,EAAMnN,EAAIqe,GAAWzd,WAAayd,EAAWzd,aAAc,EAAOyd,EAAW1d,cAAe,EAAU,SAAW0d,KAAYA,EAAWC,UAAW,GAAM7d,OAAOC,eAAekE,EAAQyZ,EAAWjY,IAAKiY,IAAiB,MAAO,UAAUV,EAAaY,EAAYC,GAAiJ,MAA9HD,IAAYH,EAAiBT,EAAYzc,UAAWqd,GAAiBC,GAAaJ,EAAiBT,EAAaa,GAAqBb,MMlsF1hBc,ENssFK,WMrsFP,QAAAA,KAAchB,EAAAha,KAAAgb,GACVhb,KAAKib,UNsuFT,MA3BAP,GAAaM,IACTrY,IAAK,aACLuK,MAAO,SM1sFArQ,GACPmD,KAAKib,OAAOpe,IAAQ,KN6sFpB8F,IAAK,aACLuK,MAAO,SM3sFArQ,SACAmD,MAAKib,OAAOpe,MN8sFnB8F,IAAK,UACLuK,MAAO,SM5sFHrQ,GACJmD,KAAKib,OAAOpe,IAAQ,KN+sFpB8F,IAAK,cACLuK,MAAO,SM7sFCrQ,GACRmD,KAAKib,OAAOpe,IAAQ,KNgtFpB8F,IAAK,eACLuK,MAAO,SM9sFErQ,GACT,MAAOmD,MAAKib,OAAOpe,ONktFhBme,KM9sFXE,EAAA,GAAmBF,GNmtFfG,EAAqB,WAAc,QAASR,GAAiBxZ,EAAQuI,GAAS,IAAK,GAAInN,GAAI,EAAGA,EAAImN,EAAMvK,OAAQ5C,IAAK,CAAE,GAAIqe,GAAalR,EAAMnN,EAAIqe,GAAWzd,WAAayd,EAAWzd,aAAc,EAAOyd,EAAW1d,cAAe,EAAU,SAAW0d,KAAYA,EAAWC,UAAW,GAAM7d,OAAOC,eAAekE,EAAQyZ,EAAWjY,IAAKiY,IAAiB,MAAO,UAAUV,EAAaY,EAAYC,GAAiJ,MAA9HD,IAAYH,EAAiBT,EAAYzc,UAAWqd,GAAiBC,GAAaJ,EAAiBT,EAAaa,GAAqBb,MO7uFhiBkB,EPivFM,WO5uFR,QAAAA,KAAoC,GAAxBC,KAAwBpb,UAAAd,OAAA,OAAAb,KAAA2B,UAAA,KAAAA,UAAA,EAAAka,GAAAna,KAAAob,GAChCpb,KAAKqb,gBAAkBA,EACvBrb,KAAKsb,aPg0FT,MAhEAH,GAAmBC,IACfzY,IAAK,KACLuK,MAAO,SOzvFRrQ,EAAMwE,EAASka,GACdA,MAAoCjd,KAAnBid,EAA+Bvb,KAAKqb,gBAAkBE,EACnEA,GACKvb,KAAKsb,UAAUze,KAChBmD,KAAKsb,UAAUze,OAEnBmD,KAAKsb,UAAUze,GAAMkG,KAAK1B,IAE1BrB,KAAKsb,UAAUze,IAASwE,MPmwF5BsB,IAAK,MACLuK,MAAO,SO5vFPrQ,SACOmD,MAAKsb,UAAUze,MPswFtB8F,IAAK,OACLuK,MAAO,SO/vFNrQ,GAAe,OAAA2e,GAAAxb,KAAAyb,EAAAxb,UAAAd,OAAN0B,EAAM9B,MAAA0c,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAN7a,EAAM6a,EAAA,GAAAzb,UAAAyb,EAChB,IAAI3L,GAAW/P,KAAKsb,UAAUze,OAAa6T,GAAS2H,MAAM,GAAQlZ,EAAS4Q,EAAS5Q,MAGpF0B,GAAOA,EAAKyK,SACRzO,KAAMA,EACNsC,OAAQA,EAIRwc,KANgB,WAOZjL,EAAM2H,MAAO,MAGjBlZ,GAEA4Q,EAAS7Q,QAAQ,SAACmC,IACbqP,EAAM2H,MAAQhX,EAAQtB,MAARyb,EAAoB3a,SP6wFxCua,KOvwFXQ,EAAA,EP4wFyBC,EAA4C3f,EAAoB,GACrF4f,EAAsB,WAAc,QAASnB,GAAiBxZ,EAAQuI,GAAS,IAAK,GAAInN,GAAI,EAAGA,EAAImN,EAAMvK,OAAQ5C,IAAK,CAAE,GAAIqe,GAAalR,EAAMnN,EAAIqe,GAAWzd,WAAayd,EAAWzd,aAAc,EAAOyd,EAAW1d,cAAe,EAAU,SAAW0d,KAAYA,EAAWC,UAAW,GAAM7d,OAAOC,eAAekE,EAAQyZ,EAAWjY,IAAKiY,IAAiB,MAAO,UAAUV,EAAaY,EAAYC,GAAiJ,MAA9HD,IAAYH,EAAiBT,EAAYzc,UAAWqd,GAAiBC,GAAaJ,EAAiBT,EAAaa,GAAqBb,MQh0FjiB6B,ER00Fc,WQz0FhB,QAAAC,GAAYC,EAAazC,EAAI0C,EAAOC,EAAQ7K,GAAO8I,EAAApa,KAAAgc,GAC/Chc,KAAK0Q,MAAQ,GAAIkL,IAAM,GACvB5b,KAAKic,YAAcA,EACnBjc,KAAKwZ,GAAKA,EACVxZ,KAAKoc,QAAU5C,EAAG6C,kBAClBrc,KAAKsc,QAAUhD,EAAM,MAAOtZ,KAAKwZ,IAAI,GACrCxZ,KAAKsC,IAAM,GACXtC,KAAKsR,MAAQA,EACbtR,KAAKuc,aAAe,EACpBvc,KAAKkc,MAAQA,EACblc,KAAKmc,OAASA,EACdnc,KAAKwc,UAAY,EACjBxc,KAAKyc,WAAa,EAClBzc,KAAK0c,WAAa,EAClB1c,KAAK2c,WAAa,EAClB3c,KAAK8H,MAAQ,EACb9H,KAAK4c,aAAe,EACpB5c,KAAK6c,gBAAkB,EACvB7c,KAAK8c,gBAAkB,EACvB9c,KAAK+c,cAAgB,EACrB/c,KAAKgd,cAAgB,EACrBhd,KAAKid,eAAiB,EACtBjd,KAAKkd,eAAiB,EACtBld,KAAKmd,YAAa,EAClBnd,KAAKod,YAAa,EAClBpd,KAAKqH,OAAS,EACdrH,KAAKsH,OAAS,EACdtH,KAAKqd,WAAa,oBAClBrd,KAAKsd,aRqhGT,MAtMAxB,GAAoBE,IAChBrZ,IAAK,OACLuK,MAAO,WQ90FkD,GAAxDqP,GAAwDtc,UAAAd,OAAA,OAAAb,KAAA2B,UAAA,GAAAA,UAAA,GAAzC,EAAGsd,EAAsCtd,UAAA,GAA1BzB,EAA0ByB,UAAA,GAAAub,EAAAxb,KAAtBwd,IAAsBvd,UAAAd,OAAA,OAAAb,KAAA2B,UAAA,KAAAA,UAAA,GAALqC,EAAKrC,UAAA,GACnDwd,EAAa,WACXF,IACA/B,EAAK1T,MAAQ,EACb0T,EAAKyB,eAAiBzB,EAAK0B,eAAiB,GAE5CM,IACAhC,EAAKc,QAAQ/L,MAAMmN,QAAU,IAEjClC,EAAKqB,gBAAkB,EACvBrB,EAAKsB,gBAAkB,EACvBtB,EAAKuB,cAAgB,EACrBvB,EAAKwB,cAAgB,EACrBxB,EAAKgB,UAAYhB,EAAKY,QAAQuB,YAAcnC,EAAK1T,MACjD0T,EAAKiB,WAAajB,EAAKY,QAAQwB,aAAepC,EAAK1T,MACnD0T,EAAKkB,WAAalB,EAAKe,aAAef,EAAKU,MAC3CV,EAAKmB,YAAcnB,EAAKhC,GAAGoE,aAAe,EAC1CpC,EAAK2B,WAAa3B,EAAK4B,YAAa,EACpCrD,EAA0ByB,EAAKY,QAASZ,EAAK1T,MAAO0T,EAAKqB,gBAAiBrB,EAAKsB,iBAC/EjD,EAAkB2B,EAAKhC,GAAIgC,EAAKkB,WAAYlB,EAAKmB,YACjDne,GAAMA,EAAGuB,MAAHyb,GAeV,OAbAxb,MAAKuc,aAAeA,EAEhBiB,GACAxd,KAAKsC,IAAMA,EACXtC,KAAKsc,QAAQha,IAAMtC,KAAKsC,IACxBtC,KAAKsc,QAAQ/L,MAAMmN,QAAU,OAC7B1d,KAAK0Q,MAAMiI,GAAG3Y,KAAKqd,WAAY,WAC3BI,MAEJ5D,EAAkB7Z,KAAKwZ,GAAIxZ,KAAKuc,aAAevc,KAAKkc,MAAOlc,KAAK2c,aAEhEc,IAEGzd,QR01FP2C,IAAK,aACLuK,MAAO,WQx1FE,GAAA2Q,GAAA7d,KACL8d,EAAK,GAAIjC,GAAA,EAAO/L,QAAQ9P,KAAKoc,QACjC0B,GAAG1N,IAAI,GAAIyL,GAAA,EAAO7C,KAClB8E,EAAGnF,GAAG,WAAY,SAACjI,GACfmN,EAAKE,kBACD7C,EAAK8C,aAAavD,KAClBoD,EAAKxW,OAASqJ,EAAMrJ,OACpBwW,EAAKvW,OAASoJ,EAAMpJ,UAG5BwW,EAAGnF,GAAG,UAAW,SAACjI,GACVwK,EAAK8C,aAAavD,KAClB/J,EAAM6E,iBACNsI,EAAKI,gBAAgBvN,EAAMrJ,OAASwW,EAAKxW,OAAQqJ,EAAMpJ,OAASuW,EAAKvW,WAG7EwW,EAAGnF,GAAG,SAAU,SAACjI,GACTwK,EAAK8C,aAAavD,IAClBoD,EAAKK,mBAAmBxN,EAAMrJ,OAASwW,EAAKxW,UAIpDrH,KAAKsc,QAAQ9a,iBAAiB,OAAQ,WAClCqc,EAAKnN,MAAMzK,KAAK4X,EAAKR,cACtB,MR61FH1a,IAAK,cACLuK,MAAO,WQ11FPlN,KAAK+d,kBACL/d,KAAKoc,QAAQ7L,MAAM4N,WAAa,eR81FhCxb,IAAK,SACLuK,MAAO,SQ51FJpF,GACH,GAAI8U,GAAe9U,EAAQ9H,KAAK8H,MAAQ9H,KAAK8H,KAK7C,OAJI8U,GAAe,IAAOA,EAAe,IACrC5c,KAAK4c,aAAeA,EACpB7C,EAA0B/Z,KAAKoc,QAASpc,KAAK4c,aAAc5c,KAAK6c,gBAAiB7c,KAAK8c,kBAEnF9c,QR+1FP2C,IAAK,YACLuK,MAAO,SQ71FDpF,GAeN,MAdA9H,MAAK8H,MAAQsW,MAAMtW,GAAS9H,KAAK4c,aAAe9U,EAChD9H,KAAKwc,UAAYxc,KAAKoc,QAAQuB,YAAc3d,KAAK8H,MACjD9H,KAAKyc,WAAazc,KAAKoc,QAAQwB,aAAe5d,KAAK8H,MACnD9H,KAAKid,gBAAkBjd,KAAKwc,UAAYxc,KAAKkc,OAAS,EAAIlc,KAAK8H,MAAQ,EACvE9H,KAAKkd,gBAAkBld,KAAKyc,WAAazc,KAAKmc,QAAU,EAAInc,KAAK8H,MAAQ,GACrE9H,KAAKwc,UAAYxc,KAAKkc,OAASlc,KAAKyc,WAAazc,KAAKmc,SACtDnc,KAAKyE,KAAKzE,KAAKuc,cAAc,EAAO,MAAM,GAE1Cvc,KAAKqe,UACLnD,EAAKoD,QAAQ7D,GAEbS,EAAKqD,YAAY9D,GAErBza,KAAKoc,QAAQ7L,MAAM4N,WAAa,OACzBne,QRg2FP2C,IAAK,aACLuK,MAAO,SQ91FAlK,EAAGC,GACV,MAAOD,GAAI,EAAKA,EAAIC,EAAMD,EAAIC,KRi2F9BN,IAAK,kBACLuK,MAAO,SQ/1FK2P,EAAiBC,GAC7B,GAAI0B,GAAQ,CAsBZ,OArBIxe,MAAKwc,WAAaxc,KAAKkc,OAASW,EAChC7c,KAAKic,YAAYwC,qBAAqBpX,OAAQwV,IAAkB,IAE5D7c,KAAKid,eAAiB,GAAKJ,IAC3B7c,KAAK+c,cAAgBF,EAAkB7c,KAAK8H,MAAQ9H,KAAK6c,gBACzD7c,KAAKmd,cAAgBnd,KAAKid,eAAiBjd,KAAK+c,eAAiB/c,KAAK+c,cAAgB/c,KAAKid,iBAG3Fjd,KAAKmd,YACLnd,KAAKic,YAAYwC,qBAAqBpX,OAAQrH,KAAK0e,WAAW1e,KAAK+c,cAAe/c,KAAKid,kBAAkB,GACzGuB,EAAQxe,KAAK+c,cAAgB,EAAI/c,KAAKid,gBAAkBjd,KAAKid,iBAE7Djd,KAAKic,YAAYwC,qBAAqBpX,OAAQ,IAAI,GAClDmX,EAAQxe,KAAK+c,gBAGjB/c,KAAKkd,eAAiB,GAAKJ,IAC3B9c,KAAKgd,cAAgBF,EAAkB9c,KAAK8H,MAAQ9H,KAAK8c,gBACzD9c,KAAKod,cAAgBpd,KAAKkd,eAAiBld,KAAKgd,eAAiBhd,KAAKgd,cAAgBhd,KAAKkd,iBAE/FnD,EAA0B/Z,KAAKoc,QAASpc,KAAK8H,MAAO0W,EAAOxe,KAAKgd,eACzDhd,QRk2FP2C,IAAK,qBACLuK,MAAO,SQh2FQ2P,GACf,GAAI8B,IAAY,CA6BhB,OA5BI3e,MAAKwc,WAAaxc,KAAKkc,OAASW,EAChC8B,EAAY3e,KAAKic,YAAY2C,wBAAwBvX,OAAQwV,IAAkB,GACxE7c,KAAKmd,aACZwB,EAAY3e,KAAKic,YAAY2C,wBAAwBvX,OAAQrH,KAAK0e,WAAW1e,KAAK+c,cAAe/c,KAAKid,kBAAkB,IAExH0B,GAEA3e,KAAKyE,KAAKzE,KAAKuc,cAAc,EAAM,MAAM,GACzC5d,WAAW,WACPuc,EAAKqD,YAAY9D,IAClB,KAECza,KAAKmd,WACLnd,KAAK6c,gBAAkB7c,KAAK+c,cAAgB,EAAI/c,KAAKid,gBAAkBjd,KAAKid,eAE5Ejd,KAAK6c,gBAAkB7c,KAAK+c,cAE5B/c,KAAKod,WACLpd,KAAK8c,gBAAkB9c,KAAKgd,cAAgB,EAAIhd,KAAKkd,gBAAkBld,KAAKkd,eAE5Eld,KAAK8c,gBAAkB9c,KAAKgd,eAE5Bhd,KAAKmd,YAAcnd,KAAKod,cACxBpd,KAAK6e,eACL9E,EAA0B/Z,KAAKoc,QAASpc,KAAK8H,MAAO9H,KAAK6c,gBAAiB7c,KAAK8c,kBAEnF9c,KAAKmd,WAAand,KAAKod,YAAa,GAEjCpd,QRm2FP2C,IAAK,UACLuK,MAAO,WQh2FP,MAAOtD,MAAK/B,IAAI7H,KAAK8H,MAAQ,GAAK,ORo2FlCnF,IAAK,eACLuK,MAAO,WQj2FPlN,KAAKoc,QAAQ0C,UAAU1O,IHlNF,oBGmNrBpQ,KAAKwZ,GAAGsF,UAAU1O,IHnNG,uBLwjGrBzN,IAAK,kBACLuK,MAAO,WQl2FPlN,KAAKoc,QAAQ0C,UAAUpG,OHvNF,oBGwNrB1Y,KAAKwZ,GAAGsF,UAAUpG,OHxNG,wBL+jGlBsD,KQn2FX+C,EAAA,ERw2FyBC,EAAwD9iB,EAAoB,GACjG+iB,EAA2B,WAAc,QAAStE,GAAiBxZ,EAAQuI,GAAS,IAAK,GAAInN,GAAI,EAAGA,EAAImN,EAAMvK,OAAQ5C,IAAK,CAAE,GAAIqe,GAAalR,EAAMnN,EAAIqe,GAAWzd,WAAayd,EAAWzd,aAAc,EAAOyd,EAAW1d,cAAe,EAAU,SAAW0d,KAAYA,EAAWC,UAAW,GAAM7d,OAAOC,eAAekE,EAAQyZ,EAAWjY,IAAKiY,IAAiB,MAAO,UAAUV,EAAaY,EAAYC,GAAiJ,MAA9HD,IAAYH,EAAiBT,EAAYzc,UAAWqd,GAAiBC,GAAaJ,EAAiBT,EAAaa,GAAqBb,MSrjGtiBgF,ETgkGwB,WS/jG1B,QAAAC,KAAmC,GAAvBC,GAAuBnf,UAAAd,OAAA,OAAAb,KAAA2B,UAAA,GAAAA,UAAA,MAAVof,EAAUpf,UAAAd,OAAA,OAAAb,KAAA2B,UAAA,GAAAA,UAAA,KAAAoa,GAAAra,KAAAmf,GAC/Bnf,KAAKqf,IAAMA,EACXrf,KAAKwZ,GAAK,KACVxZ,KAAKsf,SAAW,KAChBtf,KAAKuf,OAAS,KACdvf,KAAKwf,SAAW,KAChBxf,KAAKyf,gBAAkB,KACvBzf,KAAK0f,cAAgB,KACrB1f,KAAKof,OAASA,EACdpf,KAAK2f,aAAeP,EAAOjgB,OAC3Ba,KAAK4f,UAAYP,EAAIO,WAAa,OAClC5f,KAAK6f,gBAAkCvhB,KAApB+gB,EAAIQ,aAAmCR,EAAIQ,YAC9D7f,KAAK8f,aAAeT,EAAIU,YAAc,EACtC/f,KAAKggB,WACLhgB,KAAKigB,WAAa,EAClBjgB,KAAKkc,MAAQ,EACblc,KAAKmc,OAAS,EACdnc,KAAKkgB,YACLlgB,KAAKmgB,OAAS,KACdngB,KAAKqH,OAAS,EACdrH,KAAK0c,WAAa,ET24GtB,MAnUAuC,GAAyBE,IACrBxc,IAAK,UACLuK,MAAO,WStkGPlN,KAAKwZ,GAAKF,EAAM,iBAAiB,GACjCtZ,KAAKoS,SACL,IAWIgO,GAAQhiB,SAAS8S,cAAc,MACnCkP,GAAMC,UAZFC,icAaJtgB,KAAKwZ,GAAK4G,EAAM/D,kBAChB/C,EAAMtZ,KAAK4f,WAAW,GAAGW,YAAYvgB,KAAKwZ,IAC1CxZ,KAAKsf,SAAWhG,EAAM,gBAAiBtZ,KAAKwZ,IAAI,GAChDxZ,KAAKuf,OAASjG,EAAM,cAAetZ,KAAKwZ,IAAI,GAC5CxZ,KAAKwf,SAAWlG,EAAM,gBAAiBtZ,KAAKwZ,IAAI,GAChDxZ,KAAKkgB,SAAW5G,EAAM,cAAetZ,KAAKwZ,IAAI,GAAGgH,SACjDxgB,KAAKkc,MAAQlc,KAAKwZ,GAAGmE,YACrB3d,KAAKmc,OAASnc,KAAKwZ,GAAGoE,aAElB5d,KAAKqf,IAAIoB,eACTzgB,KAAKsf,SAASe,UAAYrgB,KAAKqf,IAAIoB,gBAEnCzgB,KAAKqf,IAAIqB,eACT1gB,KAAKwf,SAASa,UAAYrgB,KAAKqf,IAAIqB,gBAEvC1gB,KAAKyf,gBAAkBnG,EAAM,kBAAmBtZ,KAAKwZ,IAAI,GACzDxZ,KAAK0f,cAAgBpG,EAAM,gBAAiBtZ,KAAKwZ,IAAI,MTikGrD7W,IAAK,QACLuK,MAAO,WS9jGPlN,KAAKggB,UACL,KAAK,GAA0C7P,GAAtC5T,EAAI,EAAG4C,EAASa,KAAKkgB,SAAS/gB,OAAc5C,EAAI4C,EAAQ5C,IAC7D4T,EAAOnQ,KAAKkgB,SAAS3jB,GACrByD,KAAKggB,QAAQjd,KAAK,GAAIgc,GAAO/e,KAAMmQ,EAAMnQ,KAAKkc,MAAOlc,KAAKmc,OAAQ5f,GAEtEyD,MAAK2gB,eAAe3gB,KAAK8f,cACzB5E,EAAK0F,WAAWnG,MTkkGhB9X,IAAK,sBACLuK,MAAO,WS/jGHlN,KAAKyf,kBACLzf,KAAKyf,gBAAgBoB,UAAY7gB,KAAK8f,aAAe,GAErD9f,KAAK0f,gBACL1f,KAAK0f,cAAcmB,UAAY7gB,KAAK2f,iBTokGxChd,IAAK,aACLuK,MAAO,WShkGP,GAAI4Q,GAAK,GAAIkB,GAAA,EAAOlP,QAAQ9P,KAAKwZ,IAC7BsH,EAAS,GAAI9B,GAAA,EAAO9F,MACpB6H,EAAO,GAAI/B,GAAA,EAAOhG,KAAKrQ,UAAWqW,EAAA,EAAO/M,uBACzC+O,EAAO,GAAIhC,GAAA,EAAOjG,KAAK1B,KAAM,GACjCyG,GAAG1N,KAAK0Q,EAAQC,EAAMC,IACtBlD,EAAGnF,GAAG,WAAY3Y,KAAKihB,yBAAyBC,KAAKlhB,OACrD8d,EAAGnF,GAAG,UAAW3Y,KAAKye,oBAAoByC,KAAKlhB,OAC/C8d,EAAGnF,GAAG,SAAU3Y,KAAK4e,uBAAuBsC,KAAKlhB,OAC7CA,KAAK6f,cACL/B,EAAGnF,GAAG,MAAO3Y,KAAKsW,MAAM4K,KAAKlhB,OAC7B8d,EAAGnF,GAAG,aAAc3Y,KAAKmhB,0BAA0BD,KAAKlhB,OACxD8d,EAAGnF,GAAG,QAAS3Y,KAAKohB,qBAAqBF,KAAKlhB,OAC9C8d,EAAGnF,GAAG,WAAY3Y,KAAKqhB,wBAAwBH,KAAKlhB,QAExDA,KAAKmgB,OAASrC,KTqkGdnb,IAAK,2BACLuK,MAAO,SSnkGcwD,GACjBwK,EAAK8C,aAAavD,KACtBza,KAAKuf,OAAOT,UAAUpG,OJlHD,oBImHrB1Y,KAAKqf,IAAIiC,aAAethB,KAAKqf,IAAIiC,YAAYthB,KAAK8f,cAClD9f,KAAKqH,OAASqJ,EAAMrJ,OACpBrH,KAAKuf,OAAOhP,MAAM4N,WAAa,gBTskG/Bxb,IAAK,sBACLuK,MAAO,SSpkGSwD,EAAO4H,GACvB,IAAI4C,EAAK8C,aAAavD,IAAenC,EAArC,CACAA,GAAStY,KAAKuf,OAAOT,UAAUpG,OJ1HV,mBI2HrB,IAAI1R,GAAW0J,EAAMrJ,OAASrH,KAAKqH,MACnCwS,GAAkB7Z,KAAKuf,OAAQvf,KAAK0c,WAAa1V,EAAU,OTukG3DrE,IAAK,yBACLuK,MAAO,SSrkGYwD,EAAO4H,GAC1B,IAAI4C,EAAK8C,aAAavD,IAAenC,EAArC,CACA,GAAItR,GAAW0J,EAAMrJ,OAASrH,KAAKqH,OAAQsX,GAAY,EAAO4C,GAAY,CAyB1E,OAvB0B,KAAtBvhB,KAAK8f,cAAsB9Y,EAAW,GAAKhH,KAAKqf,IAAImC,gBAEpDD,EAAYvhB,KAAKqf,IAAImC,gBAAgBxhB,KAAM4J,KAAK/B,IAAIb,IAC7ChH,KAAK8f,eAAkB9f,KAAK2f,aAAe,GAAM3Y,EAAW,GAAKhH,KAAKqf,IAAIoC,gBAEjFF,EAAYvhB,KAAKqf,IAAIoC,cAAczhB,KAAM4J,KAAK/B,IAAIb,KAGjDua,IACY,IAAbva,GAAkBhH,KAAKuf,OAAOT,UAAU1O,IJ5IvB,oBI6IA,IAAbpJ,GAAkBhH,KAAK0hB,eAAe1a,IACtChH,KAAKggB,QAAQ9gB,QAAQ,SAACyiB,GAClBA,EAAO5D,oBAEXY,EAAY3X,EAAW,EAAIhH,KAAK4hB,cAAgB5hB,KAAK6hB,cACrD7hB,KAAK8hB,uBAELjI,EAAkB7Z,KAAKuf,OAAQvf,KAAK0c,WAAY,GAEpD1c,KAAKqf,IAAI0C,YAAc/hB,KAAKqf,IAAI0C,WAAW/hB,KAAK8f,eAEpD9f,KAAKqH,OAAS,EACdrH,KAAKuf,OAAOhP,MAAM4N,WAAa,OACxBQ,MT0kGPhc,IAAK,4BACLuK,MAAO,SSxkGewD,GACtB1Q,KAAKigB,WAAavP,EAAM5I,MACxB9H,KAAKggB,QAAQ,GAAGgC,iBT2kGhBrf,IAAK,uBACLuK,MAAO,SSzkGUwD,GACjB1Q,KAAKggB,QAAQ,GAAGiC,OAAOvR,EAAM5I,MAAQ9H,KAAKigB,eT4kG1Ctd,IAAK,0BACLuK,MAAO,WSzkGPlN,KAAKggB,QAAQ,GAAGkC,eT6kGhBvf,IAAK,iBACLuK,MAAO,WS3kGkB,GAAdlG,GAAc/G,UAAAd,OAAA,OAAAb,KAAA2B,UAAA,GAAAA,UAAA,GAAH,CACtB,OAAO2J,MAAK/B,IAAIb,GAAYhH,KAAKkc,MAAQ,KTglGzCvZ,IAAK,gBACLuK,MAAO,WS7kGP,GAAIiV,GAAUniB,KAAK8f,YAInB,OAHI9f,MAAKqf,IAAI+C,MAAQpiB,KAAK2f,aAAe,IACrCwC,EAAgC,IAAtBniB,KAAK8f,aAAqB9f,KAAK2f,aAAe3f,KAAK8f,cAE1D9f,KAAKof,OAAO+C,EAAU,IAAM,MTilGnCxf,IAAK,mBACLuK,MAAO,WS9kGP,MAAOlN,MAAKof,OAAOpf,KAAK8f,eAAiB,MTklGzCnd,IAAK,gBACLuK,MAAO,WS/kGP,GAAImV,GAASriB,KAAK8f,YAIlB,OAHI9f,MAAKqf,IAAI+C,MAAQpiB,KAAK2f,aAAe,IACrC0C,EAASriB,KAAK8f,eAAiB9f,KAAK2f,aAAe,GAAK,EAAI3f,KAAK8f,cAE9D9f,KAAKof,OAAOiD,EAAS,IAAM,MTmlGlC1f,IAAK,oBACLuK,MAAO,SSjlGOoE,GACd,MAAOtR,MAAKof,OAAO9N,IAAU,MTylG7B3O,IAAK,QACLuK,MAAO,WSnlGP,GAAIyU,GAAS3hB,KAAKggB,QAAQ,EAC1B2B,GAAOld,KAAKkd,EAAOpF,cAAc,EAAM,MAAM,GAC7C5d,WAAW,WACPuc,EAAKqD,YAAY9D,IAClB,MT8lGH9X,IAAK,cACLuK,MAAO,SSvlGCvE,GACR,GAAIgZ,GAAS,IAQb,OAPkB,KAAdhZ,GACAgZ,EAAS3hB,KAAKggB,QAAQsC,QACtBtiB,KAAKggB,QAAQjd,KAAK4e,IACG,IAAdhZ,IACPgZ,EAAS3hB,KAAKggB,QAAQuC,MACtBviB,KAAKggB,SAAW2B,GAAQrW,OAAOtL,KAAKggB,UAEjC2B,KTgmGPhf,IAAK,cACLuK,MAAO,WSxlGP,GADgBlN,KAAKwiB,gBACN,CACXxiB,KAAK8f,eACL9f,KAAK0c,YAAc1c,KAAKkc,MACxBrC,EAAkB7Z,KAAKuf,OAAQvf,KAAK0c,WAAY,EAEhD,IAAI+F,GAAQziB,KAAK0iB,kBAAkB1iB,KAAK8f,aAAe,EACvD,IAAI2C,GAA+B,IAAtBziB,KAAK8f,aAAoB,CAClC,GAAI6B,GAAS3hB,KAAK2iB,YAAY,EAC9BhB,GAAOld,KAAKkd,EAAOpF,aAAe,GAAG,EAAM,MAAM,EAAMkG,GAE3D,OAAO,EAGP,MADA5I,GAAkB7Z,KAAKuf,OAAQvf,KAAK0c,WAAY,IACzC,KTomGX/Z,IAAK,cACLuK,MAAO,WS3lGP,GADgBlN,KAAK4iB,gBACN,CACX5iB,KAAK8f,eACL9f,KAAK0c,YAAc1c,KAAKkc,MACxBrC,EAAkB7Z,KAAKuf,OAAQvf,KAAK0c,WAAY,EAEhD,IAAI+F,GAAQziB,KAAK0iB,kBAAkB1iB,KAAK8f,aAAe,EACvD,IAAI2C,GAASziB,KAAK8f,eAAiB9f,KAAK2f,aAAe,EAAG,CACtD,GAAIgC,GAAS3hB,KAAK2iB,YAAY,EAC9BhB,GAAOld,KAAKkd,EAAOpF,aAAe,GAAG,EAAM,MAAM,EAAMkG,GAE3D,OAAO,EAGP,MADA5I,GAAkB7Z,KAAKuf,OAAQvf,KAAK0c,WAAY,IACzC,KTumGX/Z,IAAK,iBACLuK,MAAO,SShmGIoE,IACN8M,MAAM9M,KAAW,EAAIA,GAASA,EAAQtR,KAAK2f,cAC5C3f,KAAK8f,aAAexO,EACpBtR,KAAK0c,WAAa,EAClB7C,EAAkB7Z,KAAKuf,OAAQ,EAAG,GAElCvf,KAAKggB,QAAUhgB,KAAKggB,QAAQpd,KAAK,SAAUI,EAAGC,GAC1C,MAAOD,GAAEsO,MAAQrO,EAAEqO,QAEvBtR,KAAKggB,QAAQ,GAAGvb,MAAM,GAAG,EAAM,MAAM,EAAMzE,KAAKwiB,iBAChDxiB,KAAKggB,QAAQ,GAAGvb,KAAK,GAAG,EAAM,MAAM,EAAMzE,KAAK6iB,oBAC/C7iB,KAAKggB,QAAQ,GAAGvb,KAAK,GAAG,EAAM,MAAM,EAAMzE,KAAK4iB,iBAE/C5iB,KAAK8hB,uBAELxH,EAAM,qBTomGV3X,IAAK,iBACLuK,MAAO,WSjmGiC,GAA7BkS,GAA6Bnf,UAAAd,OAAA,OAAAb,KAAA2B,UAAA,GAAAA,UAAA,MAAhB8f,EAAgB9f,UAAAd,OAAA,OAAAb,KAAA2B,UAAA,GAAAA,UAAA,GAAH,CAChCmf,GAAOjgB,QACRmb,EAAM,kCAEVta,KAAKof,OAASA,EACdpf,KAAK2f,aAAeP,EAAOjgB,OAC3Ba,KAAK8f,aAAeC,EACpB/f,KAAK8iB,WTumGLngB,IAAK,UACLuK,MAAO,WSpmGPlN,KAAKwZ,IAAME,EAAc1Z,KAAKwZ,OTwmG9B7W,IAAK,QACLuK,MAAO,WSrmGHlN,KAAKwZ,KACLxZ,KAAKwZ,GAAGjJ,MAAMmN,QAAU,WT0mG5B/a,IAAK,OACLuK,MAAO,SSvmGNoE,GACDtR,KAAK8f,iBAAyBxhB,KAAVgT,EAAsBtR,KAAK8f,aAAexO,EACzDtR,KAAKwZ,GAMNxZ,KAAK2gB,eAAe3gB,KAAK8f,eAJzB9f,KAAK+iB,UACL/iB,KAAK8iB,QACL9iB,KAAKsd,cAITtd,KAAKwZ,GAAGjJ,MAAMmN,QAAU,YT2mGrByB,KSvmGX6D,EAAA,ET4mGyBC,EAA+C/mB,EAAoB,EACZA,GAAoBmB,EAAE4lB,EUn7GtG9kB,QAAOghB,YAAc6D,GV27Gf,SAAU1mB,EAAQD,GW97GxBC,EAAAD,QAAA,SAAA6mB,GACA,IAAAA,EAAAC,gBAAA,CACA,GAAA7mB,GAAAU,OAAAwD,OAAA0iB,EAEA5mB,GAAAkkB,WAAAlkB,EAAAkkB,aACAxjB,OAAAC,eAAAX,EAAA,UACAa,YAAA,EACAC,IAAA,WACA,MAAAd,GAAAE,KAGAQ,OAAAC,eAAAX,EAAA,MACAa,YAAA,EACAC,IAAA,WACA,MAAAd,GAAAC,KAGAS,OAAAC,eAAAX,EAAA,WACAa,YAAA,IAEAb,EAAA6mB,gBAAA,EAEA,MAAA7mB,KXs8GM,SAAUA,EAAQD,IY59GxB,SAAA+mB,GACA9mB,EAAAD,QAAA+mB,IZg+G6B3mB,KAAKJ,OAI5B,SAAUC,EAAQD,EAASH,Gal+GjC,GAAAmnB,GAAAnnB,EAAA,EACA,iBAAAmnB,SAAA/mB,EAAAC,EAAA8mB,EAAA,KAEAnnB,GAAA,GAAAmnB,KACAA,GAAAC,SAAAhnB,EAAAD,QAAAgnB,EAAAC,Sbw/GM,SAAUhnB,EAAQD,EAASH,Gc//GjCG,EAAAC,EAAAD,QAAAH,EAAA,OAAAoC,IAKAjC,EAAA0G,MAAAzG,EAAAC,EAAA,w7CAA+8C,MdwgHz8C,SAAUD,EAAQD,Ge59GxB,QAAAknB,GAAApT,EAAAqT,GACA,GAAAH,GAAAlT,EAAA,OACAsT,EAAAtT,EAAA,EACA,KAAAsT,EACA,MAAAJ,EAGA,IAAAG,GAAA,kBAAAE,MAAA,CACA,GAAAC,GAAAC,EAAAH,EAKA,QAAAJ,GAAA/X,OAJAmY,EAAAI,QAAAC,IAAA,SAAAvS,GACA,uBAAAkS,EAAAM,WAAAxS,EAAA,SAGAjG,QAAAqY,IAAAvO,KAAA,MAGA,OAAAiO,GAAAjO,KAAA,MAIA,QAAAwO,GAAAI,GAKA,yEAHAN,KAAAO,SAAAC,mBAAAC,KAAAC,UAAAJ,MAGA,MArEA1nB,EAAAD,QAAA,SAAAmnB,GACA,GAAAa,KAwCA,OArCAA,GAAAC,SAAA,WACA,MAAAtkB,MAAA8jB,IAAA,SAAA3T,GACA,GAAAkT,GAAAE,EAAApT,EAAAqT,EACA,OAAArT,GAAA,GACA,UAAAA,EAAA,OAAmCkT,EAAA,IAEnCA,IAEGjO,KAAA,KAIHiP,EAAA9nB,EAAA,SAAAN,EAAAsoB,GACA,gBAAAtoB,KACAA,IAAA,KAAAA,EAAA,KAEA,QADAuoB,MACAjoB,EAAA,EAAgBA,EAAAyD,KAAAb,OAAiB5C,IAAA,CACjC,GAAAwR,GAAA/N,KAAAzD,GAAA,EACA,iBAAAwR,KACAyW,EAAAzW,IAAA,GAEA,IAAAxR,EAAA,EAAYA,EAAAN,EAAAkD,OAAoB5C,IAAA,CAChC,GAAA4T,GAAAlU,EAAAM,EAKA,iBAAA4T,GAAA,IAAAqU,EAAArU,EAAA,MACAoU,IAAApU,EAAA,GACAA,EAAA,GAAAoU,EACKA,IACLpU,EAAA,OAAAA,EAAA,aAAAoU,EAAA,KAEAF,EAAAthB,KAAAoN,MAIAkU,IfijHM,SAAU/nB,EAAQD,GgBliHxB,QAAAooB,GAAAC,EAAAtgB,GACA,OAAA7H,GAAA,EAAeA,EAAAmoB,EAAAvlB,OAAmB5C,IAAA,CAClC,GAAA4T,GAAAuU,EAAAnoB,GACAooB,EAAAC,EAAAzU,EAAApC,GACA,IAAA4W,EAAA,CACAA,EAAAE,MACA,QAAAC,GAAA,EAAiBA,EAAAH,EAAAI,MAAA5lB,OAA2B2lB,IAC5CH,EAAAI,MAAAD,GAAA3U,EAAA4U,MAAAD,GAEA,MAAQA,EAAA3U,EAAA4U,MAAA5lB,OAAuB2lB,IAC/BH,EAAAI,MAAAhiB,KAAAiiB,EAAA7U,EAAA4U,MAAAD,GAAA1gB,QAEG,CAEH,OADA2gB,MACAD,EAAA,EAAiBA,EAAA3U,EAAA4U,MAAA5lB,OAAuB2lB,IACxCC,EAAAhiB,KAAAiiB,EAAA7U,EAAA4U,MAAAD,GAAA1gB,GAEAwgB,GAAAzU,EAAApC,KAA2BA,GAAAoC,EAAApC,GAAA8W,KAAA,EAAAE,WAK3B,QAAAE,GAAAZ,GAGA,OAFAK,MACAQ,KACA3oB,EAAA,EAAeA,EAAA8nB,EAAAllB,OAAiB5C,IAAA,CAChC,GAAA4T,GAAAkU,EAAA9nB,GACAwR,EAAAoC,EAAA,GACAgV,EAAAhV,EAAA,GACAiV,EAAAjV,EAAA,GACA6T,EAAA7T,EAAA,GACAkV,GAAcF,MAAAC,QAAApB,YACdkB,GAAAnX,GAGAmX,EAAAnX,GAAAgX,MAAAhiB,KAAAsiB,GAFAX,EAAA3hB,KAAAmiB,EAAAnX,IAAgCA,KAAAgX,OAAAM,KAIhC,MAAAX,GAGA,QAAAY,GAAAlhB,EAAAmhB,GACA,GAAAC,GAAAC,IACAC,EAAAC,IAAAxmB,OAAA,EACA,YAAAiF,EAAAwhB,SACAF,EAEGA,EAAAG,YACHL,EAAAM,aAAAP,EAAAG,EAAAG,aAEAL,EAAAjF,YAAAgF,GAJAC,EAAAM,aAAAP,EAAAC,EAAAO,YAMAJ,EAAA5iB,KAAAwiB,OACE,eAAAnhB,EAAAwhB,SAGF,SAAAnmB,OAAA,qEAFA+lB,GAAAjF,YAAAgF,IAMA,QAAAS,GAAAT,GACAA,EAAAzjB,WAAA8X,YAAA2L,EACA,IAAAU,GAAAN,EAAAzjB,QAAAqjB,EACAU,IAAA,GACAN,EAAAjZ,OAAAuZ,EAAA,GAIA,QAAAC,GAAA9hB,GACA,GAAAmhB,GAAAnnB,SAAA8S,cAAA,QAGA,OAFAqU,GAAAhkB,KAAA,WACA+jB,EAAAlhB,EAAAmhB,GACAA,EAGA,QAAAY,GAAA/hB,GACA,GAAAgiB,GAAAhoB,SAAA8S,cAAA,OAGA,OAFAkV,GAAAC,IAAA,aACAf,EAAAlhB,EAAAgiB,GACAA,EAGA,QAAApB,GAAA/mB,EAAAmG,GACA,GAAAmhB,GAAArQ,EAAAwD,CAEA,IAAAtU,EAAAkiB,UAAA,CACA,GAAAC,GAAAC,GACAjB,GAAAkB,MAAAP,EAAA9hB,IACA8Q,EAAAwR,EAAAxF,KAAA,KAAAqE,EAAAgB,GAAA,GACA7N,EAAAgO,EAAAxF,KAAA,KAAAqE,EAAAgB,GAAA,OACEtoB,GAAA+lB,WACF,kBAAA2C,MACA,kBAAAA,KAAAC,iBACA,kBAAAD,KAAAE,iBACA,kBAAAC,OACA,kBAAApD,OACA6B,EAAAY,EAAA/hB,GACA8Q,EAAA6R,EAAA7F,KAAA,KAAAqE,GACA7M,EAAA,WACAsN,EAAAT,GACAA,EAAAyB,MACAL,IAAAE,gBAAAtB,EAAAyB,SAGAzB,EAAAW,EAAA9hB,GACA8Q,EAAA+R,EAAA/F,KAAA,KAAAqE,GACA7M,EAAA,WACAsN,EAAAT,IAMA,OAFArQ,GAAAjX,GAEA,SAAAipB,GACA,GAAAA,EAAA,CACA,GAAAA,EAAA/B,MAAAlnB,EAAAknB,KAAA+B,EAAA9B,QAAAnnB,EAAAmnB,OAAA8B,EAAAlD,YAAA/lB,EAAA+lB,UACA,MACA9O,GAAAjX,EAAAipB,OAEAxO,MAcA,QAAAgO,GAAAnB,EAAAjU,EAAAoH,EAAAza,GACA,GAAAknB,GAAAzM,EAAA,GAAAza,EAAAknB,GAEA,IAAAI,EAAA4B,WACA5B,EAAA4B,WAAAC,QAAAC,EAAA/V,EAAA6T,OACE,CACF,GAAAmC,GAAAlpB,SAAAmpB,eAAApC,GACAqC,EAAAjC,EAAAiC,UACAA,GAAAlW,IAAAiU,EAAA3L,YAAA4N,EAAAlW,IACAkW,EAAAroB,OACAomB,EAAAO,aAAAwB,EAAAE,EAAAlW,IAEAiU,EAAAhF,YAAA+G,IAKA,QAAAL,GAAA1B,EAAAtnB,GACA,GAAAknB,GAAAlnB,EAAAknB,IACAC,EAAAnnB,EAAAmnB,KAMA,IAJAA,GACAG,EAAAkC,aAAA,QAAArC,GAGAG,EAAA4B,WACA5B,EAAA4B,WAAAC,QAAAjC,MACE,CACF,KAAAI,EAAAQ,YACAR,EAAA3L,YAAA2L,EAAAQ,WAEAR,GAAAhF,YAAAniB,SAAAmpB,eAAApC,KAIA,QAAA4B,GAAAX,EAAAnoB,GACA,GAAAknB,GAAAlnB,EAAAknB,IACAnB,EAAA/lB,EAAA+lB,SAEAA,KAEAmB,GAAA,uDAAuDzB,KAAAO,SAAAC,mBAAAC,KAAAC,UAAAJ,MAAA,MAGvD,IAAA0D,GAAA,GAAAZ,OAAA3B,IAA6B5jB,KAAA,aAE7BomB,EAAAvB,EAAAY,IAEAZ,GAAAY,KAAAL,IAAAC,gBAAAc,GAEAC,GACAhB,IAAAE,gBAAAc,GAhPA,GAAA/C,MACAgD,EAAA,SAAAppB,GACA,GAAAqpB,EACA,mBAEA,WADA,KAAAA,MAAArpB,EAAAuB,MAAAC,KAAAC,YACA4nB,IAGAC,EAAAF,EAAA,WACA,qBAAA9V,KAAA3N,KAAA4N,UAAAC,UAAA2B,iBAEA8R,EAAAmC,EAAA,WACA,MAAAxpB,UAAAonB,MAAApnB,SAAA2pB,qBAAA,aAEAtB,EAAA,KACAD,EAAA,EACAb,IAEArpB,GAAAD,QAAA,SAAAgoB,EAAAjgB,GACA,sBAAA4jB,eACA,gBAAA5pB,UAAA,SAAAqB,OAAA,+DAGA2E,aAGA,KAAAA,EAAAkiB,YAAAliB,EAAAkiB,UAAAwB,SAGA,KAAA1jB,EAAAwhB,WAAAxhB,EAAAwhB,SAAA,SAEA,IAAAlB,GAAAO,EAAAZ,EAGA,OAFAI,GAAAC,EAAAtgB,GAEA,SAAA6jB,GAEA,OADAC,MACA3rB,EAAA,EAAgBA,EAAAmoB,EAAAvlB,OAAmB5C,IAAA,CACnC,GAAA4T,GAAAuU,EAAAnoB,GACAooB,EAAAC,EAAAzU,EAAApC,GACA4W,GAAAE,OACAqD,EAAAnlB,KAAA4hB,GAEA,GAAAsD,EAAA,CAEAxD,EADAQ,EAAAgD,GACA7jB,GAEA,OAAA7H,GAAA,EAAgBA,EAAA2rB,EAAA/oB,OAAsB5C,IAAA,CACtC,GAAAooB,GAAAuD,EAAA3rB,EACA,QAAAooB,EAAAE,KAAA,CACA,OAAAC,GAAA,EAAkBA,EAAAH,EAAAI,MAAA5lB,OAA2B2lB,IAC7CH,EAAAI,MAAAD,WACAF,GAAAD,EAAA5W,OAiIA,IAAAsZ,GAAA,WACA,GAAAc,KAEA,iBAAA7W,EAAA8W,GAEA,MADAD,GAAA7W,GAAA8W,EACAD,EAAApc,OAAAsc,SAAAjT,KAAA","file":"imageViewer.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(module) {var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function (window, document, exportName, undefined) {\n    'use strict';\n\n    var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n    var TEST_ELEMENT = document.createElement('div');\n\n    var TYPE_FUNCTION = 'function';\n\n    var round = Math.round;\n    var abs = Math.abs;\n    var now = Date.now;\n\n    /**\n     * set a timeout with a given scope\n     * @param {Function} fn\n     * @param {Number} timeout\n     * @param {Object} context\n     * @returns {number}\n     */\n    function setTimeoutContext(fn, timeout, context) {\n        return setTimeout(bindFn(fn, context), timeout);\n    }\n\n    /**\n     * if the argument is an array, we want to execute the fn on each entry\n     * if it aint an array we don't want to do a thing.\n     * this is used by all the methods that accept a single and array argument.\n     * @param {*|Array} arg\n     * @param {String} fn\n     * @param {Object} [context]\n     * @returns {Boolean}\n     */\n    function invokeArrayArg(arg, fn, context) {\n        if (Array.isArray(arg)) {\n            each(arg, context[fn], context);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * walk objects and arrays\n     * @param {Object} obj\n     * @param {Function} iterator\n     * @param {Object} context\n     */\n    function each(obj, iterator, context) {\n        var i;\n\n        if (!obj) {\n            return;\n        }\n\n        if (obj.forEach) {\n            obj.forEach(iterator, context);\n        } else if (obj.length !== undefined) {\n            i = 0;\n            while (i < obj.length) {\n                iterator.call(context, obj[i], i, obj);\n                i++;\n            }\n        } else {\n            for (i in obj) {\n                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n            }\n        }\n    }\n\n    /**\n     * wrap a method with a deprecation warning and stack trace\n     * @param {Function} method\n     * @param {String} name\n     * @param {String} message\n     * @returns {Function} A new function wrapping the supplied method.\n     */\n    function deprecate(method, name, message) {\n        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n        return function () {\n            var e = new Error('get-stack-trace');\n            var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n            var log = window.console && (window.console.warn || window.console.log);\n            if (log) {\n                log.call(window.console, deprecationMessage, stack);\n            }\n            return method.apply(this, arguments);\n        };\n    }\n\n    /**\n     * extend object.\n     * means that properties in dest will be overwritten by the ones in src.\n     * @param {Object} target\n     * @param {...Object} objects_to_assign\n     * @returns {Object} target\n     */\n    var assign;\n    if (typeof Object.assign !== 'function') {\n        assign = function assign(target) {\n            if (target === undefined || target === null) {\n                throw new TypeError('Cannot convert undefined or null to object');\n            }\n\n            var output = Object(target);\n            for (var index = 1; index < arguments.length; index++) {\n                var source = arguments[index];\n                if (source !== undefined && source !== null) {\n                    for (var nextKey in source) {\n                        if (source.hasOwnProperty(nextKey)) {\n                            output[nextKey] = source[nextKey];\n                        }\n                    }\n                }\n            }\n            return output;\n        };\n    } else {\n        assign = Object.assign;\n    }\n\n    /**\n     * extend object.\n     * means that properties in dest will be overwritten by the ones in src.\n     * @param {Object} dest\n     * @param {Object} src\n     * @param {Boolean} [merge=false]\n     * @returns {Object} dest\n     */\n    var extend = deprecate(function extend(dest, src, merge) {\n        var keys = Object.keys(src);\n        var i = 0;\n        while (i < keys.length) {\n            if (!merge || merge && dest[keys[i]] === undefined) {\n                dest[keys[i]] = src[keys[i]];\n            }\n            i++;\n        }\n        return dest;\n    }, 'extend', 'Use `assign`.');\n\n    /**\n     * merge the values from src in the dest.\n     * means that properties that exist in dest will not be overwritten by src\n     * @param {Object} dest\n     * @param {Object} src\n     * @returns {Object} dest\n     */\n    var merge = deprecate(function merge(dest, src) {\n        return extend(dest, src, true);\n    }, 'merge', 'Use `assign`.');\n\n    /**\n     * simple class inheritance\n     * @param {Function} child\n     * @param {Function} base\n     * @param {Object} [properties]\n     */\n    function inherit(child, base, properties) {\n        var baseP = base.prototype,\n            childP;\n\n        childP = child.prototype = Object.create(baseP);\n        childP.constructor = child;\n        childP._super = baseP;\n\n        if (properties) {\n            assign(childP, properties);\n        }\n    }\n\n    /**\n     * simple function bind\n     * @param {Function} fn\n     * @param {Object} context\n     * @returns {Function}\n     */\n    function bindFn(fn, context) {\n        return function boundFn() {\n            return fn.apply(context, arguments);\n        };\n    }\n\n    /**\n     * let a boolean value also be a function that must return a boolean\n     * this first item in args will be used as the context\n     * @param {Boolean|Function} val\n     * @param {Array} [args]\n     * @returns {Boolean}\n     */\n    function boolOrFn(val, args) {\n        if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == TYPE_FUNCTION) {\n            return val.apply(args ? args[0] || undefined : undefined, args);\n        }\n        return val;\n    }\n\n    /**\n     * use the val2 when val1 is undefined\n     * @param {*} val1\n     * @param {*} val2\n     * @returns {*}\n     */\n    function ifUndefined(val1, val2) {\n        return val1 === undefined ? val2 : val1;\n    }\n\n    /**\n     * addEventListener with multiple events at once\n     * @param {EventTarget} target\n     * @param {String} types\n     * @param {Function} handler\n     */\n    function addEventListeners(target, types, handler) {\n        each(splitStr(types), function (type) {\n            target.addEventListener(type, handler, false);\n        });\n    }\n\n    /**\n     * removeEventListener with multiple events at once\n     * @param {EventTarget} target\n     * @param {String} types\n     * @param {Function} handler\n     */\n    function removeEventListeners(target, types, handler) {\n        each(splitStr(types), function (type) {\n            target.removeEventListener(type, handler, false);\n        });\n    }\n\n    /**\n     * find if a node is in the given parent\n     * @method hasParent\n     * @param {HTMLElement} node\n     * @param {HTMLElement} parent\n     * @return {Boolean} found\n     */\n    function hasParent(node, parent) {\n        while (node) {\n            if (node == parent) {\n                return true;\n            }\n            node = node.parentNode;\n        }\n        return false;\n    }\n\n    /**\n     * small indexOf wrapper\n     * @param {String} str\n     * @param {String} find\n     * @returns {Boolean} found\n     */\n    function inStr(str, find) {\n        return str.indexOf(find) > -1;\n    }\n\n    /**\n     * split string on whitespace\n     * @param {String} str\n     * @returns {Array} words\n     */\n    function splitStr(str) {\n        return str.trim().split(/\\s+/g);\n    }\n\n    /**\n     * find if a array contains the object using indexOf or a simple polyFill\n     * @param {Array} src\n     * @param {String} find\n     * @param {String} [findByKey]\n     * @return {Boolean|Number} false when not found, or the index\n     */\n    function inArray(src, find, findByKey) {\n        if (src.indexOf && !findByKey) {\n            return src.indexOf(find);\n        } else {\n            var i = 0;\n            while (i < src.length) {\n                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n                    return i;\n                }\n                i++;\n            }\n            return -1;\n        }\n    }\n\n    /**\n     * convert array-like objects to real arrays\n     * @param {Object} obj\n     * @returns {Array}\n     */\n    function toArray(obj) {\n        return Array.prototype.slice.call(obj, 0);\n    }\n\n    /**\n     * unique array with objects based on a key (like 'id') or just by the array's value\n     * @param {Array} src [{id:1},{id:2},{id:1}]\n     * @param {String} [key]\n     * @param {Boolean} [sort=False]\n     * @returns {Array} [{id:1},{id:2}]\n     */\n    function uniqueArray(src, key, sort) {\n        var results = [];\n        var values = [];\n        var i = 0;\n\n        while (i < src.length) {\n            var val = key ? src[i][key] : src[i];\n            if (inArray(values, val) < 0) {\n                results.push(src[i]);\n            }\n            values[i] = val;\n            i++;\n        }\n\n        if (sort) {\n            if (!key) {\n                results = results.sort();\n            } else {\n                results = results.sort(function sortUniqueArray(a, b) {\n                    return a[key] > b[key];\n                });\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     * get the prefixed property\n     * @param {Object} obj\n     * @param {String} property\n     * @returns {String|Undefined} prefixed\n     */\n    function prefixed(obj, property) {\n        var prefix, prop;\n        var camelProp = property[0].toUpperCase() + property.slice(1);\n\n        var i = 0;\n        while (i < VENDOR_PREFIXES.length) {\n            prefix = VENDOR_PREFIXES[i];\n            prop = prefix ? prefix + camelProp : property;\n\n            if (prop in obj) {\n                return prop;\n            }\n            i++;\n        }\n        return undefined;\n    }\n\n    /**\n     * get a unique id\n     * @returns {number} uniqueId\n     */\n    var _uniqueId = 1;\n\n    function uniqueId() {\n        return _uniqueId++;\n    }\n\n    /**\n     * get the window object of an element\n     * @param {HTMLElement} element\n     * @returns {DocumentView|Window}\n     */\n    function getWindowForElement(element) {\n        var doc = element.ownerDocument || element;\n        return doc.defaultView || doc.parentWindow || window;\n    }\n\n    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\n    var SUPPORT_TOUCH = 'ontouchstart' in window;\n    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\n    var INPUT_TYPE_TOUCH = 'touch';\n    var INPUT_TYPE_PEN = 'pen';\n    var INPUT_TYPE_MOUSE = 'mouse';\n    var INPUT_TYPE_KINECT = 'kinect';\n\n    var COMPUTE_INTERVAL = 25;\n\n    var INPUT_START = 1;\n    var INPUT_MOVE = 2;\n    var INPUT_END = 4;\n    var INPUT_CANCEL = 8;\n\n    var DIRECTION_NONE = 1;\n    var DIRECTION_LEFT = 2;\n    var DIRECTION_RIGHT = 4;\n    var DIRECTION_UP = 8;\n    var DIRECTION_DOWN = 16;\n\n    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\n    var PROPS_XY = ['x', 'y'];\n    var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n    /**\n     * create new input type manager\n     * @param {Manager} manager\n     * @param {Function} callback\n     * @returns {Input}\n     * @constructor\n     */\n    function Input(manager, callback) {\n        var self = this;\n        this.manager = manager;\n        this.callback = callback;\n        this.element = manager.element;\n        this.target = manager.options.inputTarget;\n\n        // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n        // so when disabled the input events are completely bypassed.\n        this.domHandler = function (ev) {\n            if (boolOrFn(manager.options.enable, [manager])) {\n                self.handler(ev);\n            }\n        };\n\n        this.init();\n    }\n\n    Input.prototype = {\n        /**\n         * should handle the inputEvent data and trigger the callback\n         * @virtual\n         */\n        handler: function handler() {},\n\n        /**\n         * bind the events\n         */\n        init: function init() {\n            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n        },\n\n        /**\n         * unbind the events\n         */\n        destroy: function destroy() {\n            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n        }\n    };\n\n    /**\n     * create new input type manager\n     * called by the Manager constructor\n     * @param {Hammer} manager\n     * @returns {Input}\n     */\n    function createInputInstance(manager) {\n        var Type;\n        var inputClass = manager.options.inputClass;\n\n        if (inputClass) {\n            Type = inputClass;\n        } else if (SUPPORT_POINTER_EVENTS) {\n            Type = PointerEventInput;\n        } else if (SUPPORT_ONLY_TOUCH) {\n            Type = TouchInput;\n        } else if (!SUPPORT_TOUCH) {\n            Type = MouseInput;\n        } else {\n            Type = TouchMouseInput;\n        }\n        return new Type(manager, inputHandler);\n    }\n\n    /**\n     * handle input events\n     * @param {Manager} manager\n     * @param {String} eventType\n     * @param {Object} input\n     */\n    function inputHandler(manager, eventType, input) {\n        var pointersLen = input.pointers.length;\n        var changedPointersLen = input.changedPointers.length;\n        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n\n        input.isFirst = !!isFirst;\n        input.isFinal = !!isFinal;\n\n        if (isFirst) {\n            manager.session = {};\n        }\n\n        // source event is the normalized value of the domEvents\n        // like 'touchstart, mouseup, pointerdown'\n        input.eventType = eventType;\n\n        // compute scale, rotation etc\n        computeInputData(manager, input);\n\n        // emit secret event\n        manager.emit('hammer.input', input);\n\n        manager.recognize(input);\n        manager.session.prevInput = input;\n    }\n\n    /**\n     * extend the data with some usable properties like scale, rotate, velocity etc\n     * @param {Object} manager\n     * @param {Object} input\n     */\n    function computeInputData(manager, input) {\n        var session = manager.session;\n        var pointers = input.pointers;\n        var pointersLength = pointers.length;\n\n        // store the first input to calculate the distance and direction\n        if (!session.firstInput) {\n            session.firstInput = simpleCloneInputData(input);\n        }\n\n        // to compute scale and rotation we need to store the multiple touches\n        if (pointersLength > 1 && !session.firstMultiple) {\n            session.firstMultiple = simpleCloneInputData(input);\n        } else if (pointersLength === 1) {\n            session.firstMultiple = false;\n        }\n\n        var firstInput = session.firstInput;\n        var firstMultiple = session.firstMultiple;\n        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n        var center = input.center = getCenter(pointers);\n        input.timeStamp = now();\n        input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n        input.angle = getAngle(offsetCenter, center);\n        input.distance = getDistance(offsetCenter, center);\n\n        computeDeltaXY(session, input);\n        input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n        input.overallVelocityX = overallVelocity.x;\n        input.overallVelocityY = overallVelocity.y;\n        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n\n        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n\n        computeIntervalInputData(session, input);\n\n        // find the correct target\n        var target = manager.element;\n        if (hasParent(input.srcEvent.target, target)) {\n            target = input.srcEvent.target;\n        }\n        input.target = target;\n    }\n\n    function computeDeltaXY(session, input) {\n        var center = input.center;\n        var offset = session.offsetDelta || {};\n        var prevDelta = session.prevDelta || {};\n        var prevInput = session.prevInput || {};\n\n        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n            prevDelta = session.prevDelta = {\n                x: prevInput.deltaX || 0,\n                y: prevInput.deltaY || 0\n            };\n\n            offset = session.offsetDelta = {\n                x: center.x,\n                y: center.y\n            };\n        }\n\n        input.deltaX = prevDelta.x + (center.x - offset.x);\n        input.deltaY = prevDelta.y + (center.y - offset.y);\n    }\n\n    /**\n     * velocity is calculated every x ms\n     * @param {Object} session\n     * @param {Object} input\n     */\n    function computeIntervalInputData(session, input) {\n        var last = session.lastInterval || input,\n            deltaTime = input.timeStamp - last.timeStamp,\n            velocity,\n            velocityX,\n            velocityY,\n            direction;\n\n        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n            var deltaX = input.deltaX - last.deltaX;\n            var deltaY = input.deltaY - last.deltaY;\n\n            var v = getVelocity(deltaTime, deltaX, deltaY);\n            velocityX = v.x;\n            velocityY = v.y;\n            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n            direction = getDirection(deltaX, deltaY);\n\n            session.lastInterval = input;\n        } else {\n            // use latest velocity info if it doesn't overtake a minimum period\n            velocity = last.velocity;\n            velocityX = last.velocityX;\n            velocityY = last.velocityY;\n            direction = last.direction;\n        }\n\n        input.velocity = velocity;\n        input.velocityX = velocityX;\n        input.velocityY = velocityY;\n        input.direction = direction;\n    }\n\n    /**\n     * create a simple clone from the input used for storage of firstInput and firstMultiple\n     * @param {Object} input\n     * @returns {Object} clonedInputData\n     */\n    function simpleCloneInputData(input) {\n        // make a simple copy of the pointers because we will get a reference if we don't\n        // we only need clientXY for the calculations\n        var pointers = [];\n        var i = 0;\n        while (i < input.pointers.length) {\n            pointers[i] = {\n                clientX: round(input.pointers[i].clientX),\n                clientY: round(input.pointers[i].clientY)\n            };\n            i++;\n        }\n\n        return {\n            timeStamp: now(),\n            pointers: pointers,\n            center: getCenter(pointers),\n            deltaX: input.deltaX,\n            deltaY: input.deltaY\n        };\n    }\n\n    /**\n     * get the center of all the pointers\n     * @param {Array} pointers\n     * @return {Object} center contains `x` and `y` properties\n     */\n    function getCenter(pointers) {\n        var pointersLength = pointers.length;\n\n        // no need to loop when only one touch\n        if (pointersLength === 1) {\n            return {\n                x: round(pointers[0].clientX),\n                y: round(pointers[0].clientY)\n            };\n        }\n\n        var x = 0,\n            y = 0,\n            i = 0;\n        while (i < pointersLength) {\n            x += pointers[i].clientX;\n            y += pointers[i].clientY;\n            i++;\n        }\n\n        return {\n            x: round(x / pointersLength),\n            y: round(y / pointersLength)\n        };\n    }\n\n    /**\n     * calculate the velocity between two points. unit is in px per ms.\n     * @param {Number} deltaTime\n     * @param {Number} x\n     * @param {Number} y\n     * @return {Object} velocity `x` and `y`\n     */\n    function getVelocity(deltaTime, x, y) {\n        return {\n            x: x / deltaTime || 0,\n            y: y / deltaTime || 0\n        };\n    }\n\n    /**\n     * get the direction between two points\n     * @param {Number} x\n     * @param {Number} y\n     * @return {Number} direction\n     */\n    function getDirection(x, y) {\n        if (x === y) {\n            return DIRECTION_NONE;\n        }\n\n        if (abs(x) >= abs(y)) {\n            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        }\n        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n    }\n\n    /**\n     * calculate the absolute distance between two points\n     * @param {Object} p1 {x, y}\n     * @param {Object} p2 {x, y}\n     * @param {Array} [props] containing x and y keys\n     * @return {Number} distance\n     */\n    function getDistance(p1, p2, props) {\n        if (!props) {\n            props = PROPS_XY;\n        }\n        var x = p2[props[0]] - p1[props[0]],\n            y = p2[props[1]] - p1[props[1]];\n\n        return Math.sqrt(x * x + y * y);\n    }\n\n    /**\n     * calculate the angle between two coordinates\n     * @param {Object} p1\n     * @param {Object} p2\n     * @param {Array} [props] containing x and y keys\n     * @return {Number} angle\n     */\n    function getAngle(p1, p2, props) {\n        if (!props) {\n            props = PROPS_XY;\n        }\n        var x = p2[props[0]] - p1[props[0]],\n            y = p2[props[1]] - p1[props[1]];\n        return Math.atan2(y, x) * 180 / Math.PI;\n    }\n\n    /**\n     * calculate the rotation degrees between two pointersets\n     * @param {Array} start array of pointers\n     * @param {Array} end array of pointers\n     * @return {Number} rotation\n     */\n    function getRotation(start, end) {\n        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n    }\n\n    /**\n     * calculate the scale factor between two pointersets\n     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n     * @param {Array} start array of pointers\n     * @param {Array} end array of pointers\n     * @return {Number} scale\n     */\n    function getScale(start, end) {\n        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n    }\n\n    var MOUSE_INPUT_MAP = {\n        mousedown: INPUT_START,\n        mousemove: INPUT_MOVE,\n        mouseup: INPUT_END\n    };\n\n    var MOUSE_ELEMENT_EVENTS = 'mousedown';\n    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n    /**\n     * Mouse events input\n     * @constructor\n     * @extends Input\n     */\n    function MouseInput() {\n        this.evEl = MOUSE_ELEMENT_EVENTS;\n        this.evWin = MOUSE_WINDOW_EVENTS;\n\n        this.pressed = false; // mousedown state\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(MouseInput, Input, {\n        /**\n         * handle mouse events\n         * @param {Object} ev\n         */\n        handler: function MEhandler(ev) {\n            var eventType = MOUSE_INPUT_MAP[ev.type];\n\n            // on start we want to have the left mouse button down\n            if (eventType & INPUT_START && ev.button === 0) {\n                this.pressed = true;\n            }\n\n            if (eventType & INPUT_MOVE && ev.which !== 1) {\n                eventType = INPUT_END;\n            }\n\n            // mouse must be down\n            if (!this.pressed) {\n                return;\n            }\n\n            if (eventType & INPUT_END) {\n                this.pressed = false;\n            }\n\n            this.callback(this.manager, eventType, {\n                pointers: [ev],\n                changedPointers: [ev],\n                pointerType: INPUT_TYPE_MOUSE,\n                srcEvent: ev\n            });\n        }\n    });\n\n    var POINTER_INPUT_MAP = {\n        pointerdown: INPUT_START,\n        pointermove: INPUT_MOVE,\n        pointerup: INPUT_END,\n        pointercancel: INPUT_CANCEL,\n        pointerout: INPUT_CANCEL\n    };\n\n    // in IE10 the pointer types is defined as an enum\n    var IE10_POINTER_TYPE_ENUM = {\n        2: INPUT_TYPE_TOUCH,\n        3: INPUT_TYPE_PEN,\n        4: INPUT_TYPE_MOUSE,\n        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n    };\n\n    var POINTER_ELEMENT_EVENTS = 'pointerdown';\n    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n    // IE10 has prefixed support, and case-sensitive\n    if (window.MSPointerEvent && !window.PointerEvent) {\n        POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n    }\n\n    /**\n     * Pointer events input\n     * @constructor\n     * @extends Input\n     */\n    function PointerEventInput() {\n        this.evEl = POINTER_ELEMENT_EVENTS;\n        this.evWin = POINTER_WINDOW_EVENTS;\n\n        Input.apply(this, arguments);\n\n        this.store = this.manager.session.pointerEvents = [];\n    }\n\n    inherit(PointerEventInput, Input, {\n        /**\n         * handle mouse events\n         * @param {Object} ev\n         */\n        handler: function PEhandler(ev) {\n            var store = this.store;\n            var removePointer = false;\n\n            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n            var isTouch = pointerType == INPUT_TYPE_TOUCH;\n\n            // get index of the event in the store\n            var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n            // start and mouse must be down\n            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n                if (storeIndex < 0) {\n                    store.push(ev);\n                    storeIndex = store.length - 1;\n                }\n            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n                removePointer = true;\n            }\n\n            // it not found, so the pointer hasn't been down (so it's probably a hover)\n            if (storeIndex < 0) {\n                return;\n            }\n\n            // update the event in the store\n            store[storeIndex] = ev;\n\n            this.callback(this.manager, eventType, {\n                pointers: store,\n                changedPointers: [ev],\n                pointerType: pointerType,\n                srcEvent: ev\n            });\n\n            if (removePointer) {\n                // remove from the store\n                store.splice(storeIndex, 1);\n            }\n        }\n    });\n\n    var SINGLE_TOUCH_INPUT_MAP = {\n        touchstart: INPUT_START,\n        touchmove: INPUT_MOVE,\n        touchend: INPUT_END,\n        touchcancel: INPUT_CANCEL\n    };\n\n    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n    /**\n     * Touch events input\n     * @constructor\n     * @extends Input\n     */\n    function SingleTouchInput() {\n        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n        this.started = false;\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(SingleTouchInput, Input, {\n        handler: function TEhandler(ev) {\n            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n            // should we handle the touch events?\n            if (type === INPUT_START) {\n                this.started = true;\n            }\n\n            if (!this.started) {\n                return;\n            }\n\n            var touches = normalizeSingleTouches.call(this, ev, type);\n\n            // when done, reset the started state\n            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n                this.started = false;\n            }\n\n            this.callback(this.manager, type, {\n                pointers: touches[0],\n                changedPointers: touches[1],\n                pointerType: INPUT_TYPE_TOUCH,\n                srcEvent: ev\n            });\n        }\n    });\n\n    /**\n     * @this {TouchInput}\n     * @param {Object} ev\n     * @param {Number} type flag\n     * @returns {undefined|Array} [all, changed]\n     */\n    function normalizeSingleTouches(ev, type) {\n        var all = toArray(ev.touches);\n        var changed = toArray(ev.changedTouches);\n\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            all = uniqueArray(all.concat(changed), 'identifier', true);\n        }\n\n        return [all, changed];\n    }\n\n    var TOUCH_INPUT_MAP = {\n        touchstart: INPUT_START,\n        touchmove: INPUT_MOVE,\n        touchend: INPUT_END,\n        touchcancel: INPUT_CANCEL\n    };\n\n    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n    /**\n     * Multi-user touch events input\n     * @constructor\n     * @extends Input\n     */\n    function TouchInput() {\n        this.evTarget = TOUCH_TARGET_EVENTS;\n        this.targetIds = {};\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(TouchInput, Input, {\n        handler: function MTEhandler(ev) {\n            var type = TOUCH_INPUT_MAP[ev.type];\n            var touches = getTouches.call(this, ev, type);\n            if (!touches) {\n                return;\n            }\n\n            this.callback(this.manager, type, {\n                pointers: touches[0],\n                changedPointers: touches[1],\n                pointerType: INPUT_TYPE_TOUCH,\n                srcEvent: ev\n            });\n        }\n    });\n\n    /**\n     * @this {TouchInput}\n     * @param {Object} ev\n     * @param {Number} type flag\n     * @returns {undefined|Array} [all, changed]\n     */\n    function getTouches(ev, type) {\n        var allTouches = toArray(ev.touches);\n        var targetIds = this.targetIds;\n\n        // when there is only one touch, the process can be simplified\n        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n            targetIds[allTouches[0].identifier] = true;\n            return [allTouches, allTouches];\n        }\n\n        var i,\n            targetTouches,\n            changedTouches = toArray(ev.changedTouches),\n            changedTargetTouches = [],\n            target = this.target;\n\n        // get target touches from touches\n        targetTouches = allTouches.filter(function (touch) {\n            return hasParent(touch.target, target);\n        });\n\n        // collect touches\n        if (type === INPUT_START) {\n            i = 0;\n            while (i < targetTouches.length) {\n                targetIds[targetTouches[i].identifier] = true;\n                i++;\n            }\n        }\n\n        // filter changed touches to only contain touches that exist in the collected target ids\n        i = 0;\n        while (i < changedTouches.length) {\n            if (targetIds[changedTouches[i].identifier]) {\n                changedTargetTouches.push(changedTouches[i]);\n            }\n\n            // cleanup removed touches\n            if (type & (INPUT_END | INPUT_CANCEL)) {\n                delete targetIds[changedTouches[i].identifier];\n            }\n            i++;\n        }\n\n        if (!changedTargetTouches.length) {\n            return;\n        }\n\n        return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n    }\n\n    /**\n     * Combined touch and mouse input\n     *\n     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n     * This because touch devices also emit mouse events while doing a touch.\n     *\n     * @constructor\n     * @extends Input\n     */\n\n    var DEDUP_TIMEOUT = 2500;\n    var DEDUP_DISTANCE = 25;\n\n    function TouchMouseInput() {\n        Input.apply(this, arguments);\n\n        var handler = bindFn(this.handler, this);\n        this.touch = new TouchInput(this.manager, handler);\n        this.mouse = new MouseInput(this.manager, handler);\n\n        this.primaryTouch = null;\n        this.lastTouches = [];\n    }\n\n    inherit(TouchMouseInput, Input, {\n        /**\n         * handle mouse and touch events\n         * @param {Hammer} manager\n         * @param {String} inputEvent\n         * @param {Object} inputData\n         */\n        handler: function TMEhandler(manager, inputEvent, inputData) {\n            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n                isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n\n            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n                return;\n            }\n\n            // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n            if (isTouch) {\n                recordTouches.call(this, inputEvent, inputData);\n            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n                return;\n            }\n\n            this.callback(manager, inputEvent, inputData);\n        },\n\n        /**\n         * remove the event listeners\n         */\n        destroy: function destroy() {\n            this.touch.destroy();\n            this.mouse.destroy();\n        }\n    });\n\n    function recordTouches(eventType, eventData) {\n        if (eventType & INPUT_START) {\n            this.primaryTouch = eventData.changedPointers[0].identifier;\n            setLastTouch.call(this, eventData);\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            setLastTouch.call(this, eventData);\n        }\n    }\n\n    function setLastTouch(eventData) {\n        var touch = eventData.changedPointers[0];\n\n        if (touch.identifier === this.primaryTouch) {\n            var lastTouch = { x: touch.clientX, y: touch.clientY };\n            this.lastTouches.push(lastTouch);\n            var lts = this.lastTouches;\n            var removeLastTouch = function removeLastTouch() {\n                var i = lts.indexOf(lastTouch);\n                if (i > -1) {\n                    lts.splice(i, 1);\n                }\n            };\n            setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n        }\n    }\n\n    function isSyntheticEvent(eventData) {\n        var x = eventData.srcEvent.clientX,\n            y = eventData.srcEvent.clientY;\n        for (var i = 0; i < this.lastTouches.length; i++) {\n            var t = this.lastTouches[i];\n            var dx = Math.abs(x - t.x),\n                dy = Math.abs(y - t.y);\n            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n    // magical touchAction value\n    var TOUCH_ACTION_COMPUTE = 'compute';\n    var TOUCH_ACTION_AUTO = 'auto';\n    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n    var TOUCH_ACTION_NONE = 'none';\n    var TOUCH_ACTION_PAN_X = 'pan-x';\n    var TOUCH_ACTION_PAN_Y = 'pan-y';\n    var TOUCH_ACTION_MAP = getTouchActionProps();\n\n    /**\n     * Touch Action\n     * sets the touchAction property or uses the js alternative\n     * @param {Manager} manager\n     * @param {String} value\n     * @constructor\n     */\n    function TouchAction(manager, value) {\n        this.manager = manager;\n        this.set(value);\n    }\n\n    TouchAction.prototype = {\n        /**\n         * set the touchAction value on the element or enable the polyfill\n         * @param {String} value\n         */\n        set: function set(value) {\n            // find out the touch-action by the event handlers\n            if (value == TOUCH_ACTION_COMPUTE) {\n                value = this.compute();\n            }\n\n            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n            }\n            this.actions = value.toLowerCase().trim();\n        },\n\n        /**\n         * just re-set the touchAction value\n         */\n        update: function update() {\n            this.set(this.manager.options.touchAction);\n        },\n\n        /**\n         * compute the value for the touchAction property based on the recognizer's settings\n         * @returns {String} value\n         */\n        compute: function compute() {\n            var actions = [];\n            each(this.manager.recognizers, function (recognizer) {\n                if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                    actions = actions.concat(recognizer.getTouchAction());\n                }\n            });\n            return cleanTouchActions(actions.join(' '));\n        },\n\n        /**\n         * this method is called on each input cycle and provides the preventing of the browser behavior\n         * @param {Object} input\n         */\n        preventDefaults: function preventDefaults(input) {\n            var srcEvent = input.srcEvent;\n            var direction = input.offsetDirection;\n\n            // if the touch action did prevented once this session\n            if (this.manager.session.prevented) {\n                srcEvent.preventDefault();\n                return;\n            }\n\n            var actions = this.actions;\n            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n            if (hasNone) {\n                //do not prevent defaults if this is a tap gesture\n\n                var isTapPointer = input.pointers.length === 1;\n                var isTapMovement = input.distance < 2;\n                var isTapTouchTime = input.deltaTime < 250;\n\n                if (isTapPointer && isTapMovement && isTapTouchTime) {\n                    return;\n                }\n            }\n\n            if (hasPanX && hasPanY) {\n                // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n                return;\n            }\n\n            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n                return this.preventSrc(srcEvent);\n            }\n        },\n\n        /**\n         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n         * @param {Object} srcEvent\n         */\n        preventSrc: function preventSrc(srcEvent) {\n            this.manager.session.prevented = true;\n            srcEvent.preventDefault();\n        }\n    };\n\n    /**\n     * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n     * @param {String} actions\n     * @returns {*}\n     */\n    function cleanTouchActions(actions) {\n        // none\n        if (inStr(actions, TOUCH_ACTION_NONE)) {\n            return TOUCH_ACTION_NONE;\n        }\n\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n        // if both pan-x and pan-y are set (different recognizers\n        // for different directions, e.g. horizontal pan but vertical swipe?)\n        // we need none (as otherwise with pan-x pan-y combined none of these\n        // recognizers will work, since the browser would handle all panning\n        if (hasPanX && hasPanY) {\n            return TOUCH_ACTION_NONE;\n        }\n\n        // pan-x OR pan-y\n        if (hasPanX || hasPanY) {\n            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n        }\n\n        // manipulation\n        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n            return TOUCH_ACTION_MANIPULATION;\n        }\n\n        return TOUCH_ACTION_AUTO;\n    }\n\n    function getTouchActionProps() {\n        if (!NATIVE_TOUCH_ACTION) {\n            return false;\n        }\n        var touchMap = {};\n        var cssSupports = window.CSS && window.CSS.supports;\n        ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n\n            // If css.supports is not supported but there is native touch-action assume it supports\n            // all values. This is the case for IE 10 and 11.\n            touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n        });\n        return touchMap;\n    }\n\n    /**\n     * Recognizer flow explained; *\n     * All recognizers have the initial state of POSSIBLE when a input session starts.\n     * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n     * Example session for mouse-input: mousedown -> mousemove -> mouseup\n     *\n     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n     * which determines with state it should be.\n     *\n     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n     * POSSIBLE to give it another change on the next cycle.\n     *\n     *               Possible\n     *                  |\n     *            +-----+---------------+\n     *            |                     |\n     *      +-----+-----+               |\n     *      |           |               |\n     *   Failed      Cancelled          |\n     *                          +-------+------+\n     *                          |              |\n     *                      Recognized       Began\n     *                                         |\n     *                                      Changed\n     *                                         |\n     *                                  Ended/Recognized\n     */\n    var STATE_POSSIBLE = 1;\n    var STATE_BEGAN = 2;\n    var STATE_CHANGED = 4;\n    var STATE_ENDED = 8;\n    var STATE_RECOGNIZED = STATE_ENDED;\n    var STATE_CANCELLED = 16;\n    var STATE_FAILED = 32;\n\n    /**\n     * Recognizer\n     * Every recognizer needs to extend from this class.\n     * @constructor\n     * @param {Object} options\n     */\n    function Recognizer(options) {\n        this.options = assign({}, this.defaults, options || {});\n\n        this.id = uniqueId();\n\n        this.manager = null;\n\n        // default is enable true\n        this.options.enable = ifUndefined(this.options.enable, true);\n\n        this.state = STATE_POSSIBLE;\n\n        this.simultaneous = {};\n        this.requireFail = [];\n    }\n\n    Recognizer.prototype = {\n        /**\n         * @virtual\n         * @type {Object}\n         */\n        defaults: {},\n\n        /**\n         * set options\n         * @param {Object} options\n         * @return {Recognizer}\n         */\n        set: function set(options) {\n            assign(this.options, options);\n\n            // also update the touchAction, in case something changed about the directions/enabled state\n            this.manager && this.manager.touchAction.update();\n            return this;\n        },\n\n        /**\n         * recognize simultaneous with an other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        recognizeWith: function recognizeWith(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n                return this;\n            }\n\n            var simultaneous = this.simultaneous;\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            if (!simultaneous[otherRecognizer.id]) {\n                simultaneous[otherRecognizer.id] = otherRecognizer;\n                otherRecognizer.recognizeWith(this);\n            }\n            return this;\n        },\n\n        /**\n         * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n                return this;\n            }\n\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            delete this.simultaneous[otherRecognizer.id];\n            return this;\n        },\n\n        /**\n         * recognizer can only run when an other is failing\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        requireFailure: function requireFailure(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n                return this;\n            }\n\n            var requireFail = this.requireFail;\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            if (inArray(requireFail, otherRecognizer) === -1) {\n                requireFail.push(otherRecognizer);\n                otherRecognizer.requireFailure(this);\n            }\n            return this;\n        },\n\n        /**\n         * drop the requireFailure link. it does not remove the link on the other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        dropRequireFailure: function dropRequireFailure(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n                return this;\n            }\n\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            var index = inArray(this.requireFail, otherRecognizer);\n            if (index > -1) {\n                this.requireFail.splice(index, 1);\n            }\n            return this;\n        },\n\n        /**\n         * has require failures boolean\n         * @returns {boolean}\n         */\n        hasRequireFailures: function hasRequireFailures() {\n            return this.requireFail.length > 0;\n        },\n\n        /**\n         * if the recognizer can recognize simultaneous with an other recognizer\n         * @param {Recognizer} otherRecognizer\n         * @returns {Boolean}\n         */\n        canRecognizeWith: function canRecognizeWith(otherRecognizer) {\n            return !!this.simultaneous[otherRecognizer.id];\n        },\n\n        /**\n         * You should use `tryEmit` instead of `emit` directly to check\n         * that all the needed recognizers has failed before emitting.\n         * @param {Object} input\n         */\n        emit: function emit(input) {\n            var self = this;\n            var state = this.state;\n\n            function emit(event) {\n                self.manager.emit(event, input);\n            }\n\n            // 'panstart' and 'panmove'\n            if (state < STATE_ENDED) {\n                emit(self.options.event + stateStr(state));\n            }\n\n            emit(self.options.event); // simple 'eventName' events\n\n            if (input.additionalEvent) {\n                // additional event(panleft, panright, pinchin, pinchout...)\n                emit(input.additionalEvent);\n            }\n\n            // panend and pancancel\n            if (state >= STATE_ENDED) {\n                emit(self.options.event + stateStr(state));\n            }\n        },\n\n        /**\n         * Check that all the require failure recognizers has failed,\n         * if true, it emits a gesture event,\n         * otherwise, setup the state to FAILED.\n         * @param {Object} input\n         */\n        tryEmit: function tryEmit(input) {\n            if (this.canEmit()) {\n                return this.emit(input);\n            }\n            // it's failing anyway\n            this.state = STATE_FAILED;\n        },\n\n        /**\n         * can we emit?\n         * @returns {boolean}\n         */\n        canEmit: function canEmit() {\n            var i = 0;\n            while (i < this.requireFail.length) {\n                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                    return false;\n                }\n                i++;\n            }\n            return true;\n        },\n\n        /**\n         * update the recognizer\n         * @param {Object} inputData\n         */\n        recognize: function recognize(inputData) {\n            // make a new copy of the inputData\n            // so we can change the inputData without messing up the other recognizers\n            var inputDataClone = assign({}, inputData);\n\n            // is is enabled and allow recognizing?\n            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n                this.reset();\n                this.state = STATE_FAILED;\n                return;\n            }\n\n            // reset when we've reached the end\n            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n                this.state = STATE_POSSIBLE;\n            }\n\n            this.state = this.process(inputDataClone);\n\n            // the recognizer has recognized a gesture\n            // so trigger an event\n            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n                this.tryEmit(inputDataClone);\n            }\n        },\n\n        /**\n         * return the state of the recognizer\n         * the actual recognizing happens in this method\n         * @virtual\n         * @param {Object} inputData\n         * @returns {Const} STATE\n         */\n        process: function process(inputData) {}, // jshint ignore:line\n\n        /**\n         * return the preferred touch-action\n         * @virtual\n         * @returns {Array}\n         */\n        getTouchAction: function getTouchAction() {},\n\n        /**\n         * called when the gesture isn't allowed to recognize\n         * like when another is being recognized or it is disabled\n         * @virtual\n         */\n        reset: function reset() {}\n    };\n\n    /**\n     * get a usable string, used as event postfix\n     * @param {Const} state\n     * @returns {String} state\n     */\n    function stateStr(state) {\n        if (state & STATE_CANCELLED) {\n            return 'cancel';\n        } else if (state & STATE_ENDED) {\n            return 'end';\n        } else if (state & STATE_CHANGED) {\n            return 'move';\n        } else if (state & STATE_BEGAN) {\n            return 'start';\n        }\n        return '';\n    }\n\n    /**\n     * direction cons to string\n     * @param {Const} direction\n     * @returns {String}\n     */\n    function directionStr(direction) {\n        if (direction == DIRECTION_DOWN) {\n            return 'down';\n        } else if (direction == DIRECTION_UP) {\n            return 'up';\n        } else if (direction == DIRECTION_LEFT) {\n            return 'left';\n        } else if (direction == DIRECTION_RIGHT) {\n            return 'right';\n        }\n        return '';\n    }\n\n    /**\n     * get a recognizer by name if it is bound to a manager\n     * @param {Recognizer|String} otherRecognizer\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer}\n     */\n    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n        var manager = recognizer.manager;\n        if (manager) {\n            return manager.get(otherRecognizer);\n        }\n        return otherRecognizer;\n    }\n\n    /**\n     * This recognizer is just used as a base for the simple attribute recognizers.\n     * @constructor\n     * @extends Recognizer\n     */\n    function AttrRecognizer() {\n        Recognizer.apply(this, arguments);\n    }\n\n    inherit(AttrRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof AttrRecognizer\n         */\n        defaults: {\n            /**\n             * @type {Number}\n             * @default 1\n             */\n            pointers: 1\n        },\n\n        /**\n         * Used to check if it the recognizer receives valid input, like input.distance > 10.\n         * @memberof AttrRecognizer\n         * @param {Object} input\n         * @returns {Boolean} recognized\n         */\n        attrTest: function attrTest(input) {\n            var optionPointers = this.options.pointers;\n            return optionPointers === 0 || input.pointers.length === optionPointers;\n        },\n\n        /**\n         * Process the input and return the state for the recognizer\n         * @memberof AttrRecognizer\n         * @param {Object} input\n         * @returns {*} State\n         */\n        process: function process(input) {\n            var state = this.state;\n            var eventType = input.eventType;\n\n            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n            var isValid = this.attrTest(input);\n\n            // on cancel input and we've recognized before, return STATE_CANCELLED\n            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n                return state | STATE_CANCELLED;\n            } else if (isRecognized || isValid) {\n                if (eventType & INPUT_END) {\n                    return state | STATE_ENDED;\n                } else if (!(state & STATE_BEGAN)) {\n                    return STATE_BEGAN;\n                }\n                return state | STATE_CHANGED;\n            }\n            return STATE_FAILED;\n        }\n    });\n\n    /**\n     * Pan\n     * Recognized when the pointer is down and moved in the allowed direction.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function PanRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n\n        this.pX = null;\n        this.pY = null;\n    }\n\n    inherit(PanRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof PanRecognizer\n         */\n        defaults: {\n            event: 'pan',\n            threshold: 10,\n            pointers: 1,\n            direction: DIRECTION_ALL\n        },\n\n        getTouchAction: function getTouchAction() {\n            var direction = this.options.direction;\n            var actions = [];\n            if (direction & DIRECTION_HORIZONTAL) {\n                actions.push(TOUCH_ACTION_PAN_Y);\n            }\n            if (direction & DIRECTION_VERTICAL) {\n                actions.push(TOUCH_ACTION_PAN_X);\n            }\n            return actions;\n        },\n\n        directionTest: function directionTest(input) {\n            var options = this.options;\n            var hasMoved = true;\n            var distance = input.distance;\n            var direction = input.direction;\n            var x = input.deltaX;\n            var y = input.deltaY;\n\n            // lock to axis?\n            if (!(direction & options.direction)) {\n                if (options.direction & DIRECTION_HORIZONTAL) {\n                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                    hasMoved = x != this.pX;\n                    distance = Math.abs(input.deltaX);\n                } else {\n                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n                    hasMoved = y != this.pY;\n                    distance = Math.abs(input.deltaY);\n                }\n            }\n            input.direction = direction;\n            return hasMoved && distance > options.threshold && direction & options.direction;\n        },\n\n        attrTest: function attrTest(input) {\n            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n        },\n\n        emit: function emit(input) {\n\n            this.pX = input.deltaX;\n            this.pY = input.deltaY;\n\n            var direction = directionStr(input.direction);\n\n            if (direction) {\n                input.additionalEvent = this.options.event + direction;\n            }\n            this._super.emit.call(this, input);\n        }\n    });\n\n    /**\n     * Pinch\n     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function PinchRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(PinchRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof PinchRecognizer\n         */\n        defaults: {\n            event: 'pinch',\n            threshold: 0,\n            pointers: 2\n        },\n\n        getTouchAction: function getTouchAction() {\n            return [TOUCH_ACTION_NONE];\n        },\n\n        attrTest: function attrTest(input) {\n            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n        },\n\n        emit: function emit(input) {\n            if (input.scale !== 1) {\n                var inOut = input.scale < 1 ? 'in' : 'out';\n                input.additionalEvent = this.options.event + inOut;\n            }\n            this._super.emit.call(this, input);\n        }\n    });\n\n    /**\n     * Press\n     * Recognized when the pointer is down for x ms without any movement.\n     * @constructor\n     * @extends Recognizer\n     */\n    function PressRecognizer() {\n        Recognizer.apply(this, arguments);\n\n        this._timer = null;\n        this._input = null;\n    }\n\n    inherit(PressRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof PressRecognizer\n         */\n        defaults: {\n            event: 'press',\n            pointers: 1,\n            time: 251, // minimal time of the pointer to be pressed\n            threshold: 9 // a minimal movement is ok, but keep it low\n        },\n\n        getTouchAction: function getTouchAction() {\n            return [TOUCH_ACTION_AUTO];\n        },\n\n        process: function process(input) {\n            var options = this.options;\n            var validPointers = input.pointers.length === options.pointers;\n            var validMovement = input.distance < options.threshold;\n            var validTime = input.deltaTime > options.time;\n\n            this._input = input;\n\n            // we only allow little movement\n            // and we've reached an end event, so a tap is possible\n            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n                this.reset();\n            } else if (input.eventType & INPUT_START) {\n                this.reset();\n                this._timer = setTimeoutContext(function () {\n                    this.state = STATE_RECOGNIZED;\n                    this.tryEmit();\n                }, options.time, this);\n            } else if (input.eventType & INPUT_END) {\n                return STATE_RECOGNIZED;\n            }\n            return STATE_FAILED;\n        },\n\n        reset: function reset() {\n            clearTimeout(this._timer);\n        },\n\n        emit: function emit(input) {\n            if (this.state !== STATE_RECOGNIZED) {\n                return;\n            }\n\n            if (input && input.eventType & INPUT_END) {\n                this.manager.emit(this.options.event + 'up', input);\n            } else {\n                this._input.timeStamp = now();\n                this.manager.emit(this.options.event, this._input);\n            }\n        }\n    });\n\n    /**\n     * Rotate\n     * Recognized when two or more pointer are moving in a circular motion.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function RotateRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(RotateRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof RotateRecognizer\n         */\n        defaults: {\n            event: 'rotate',\n            threshold: 0,\n            pointers: 2\n        },\n\n        getTouchAction: function getTouchAction() {\n            return [TOUCH_ACTION_NONE];\n        },\n\n        attrTest: function attrTest(input) {\n            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n        }\n    });\n\n    /**\n     * Swipe\n     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function SwipeRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(SwipeRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof SwipeRecognizer\n         */\n        defaults: {\n            event: 'swipe',\n            threshold: 10,\n            velocity: 0.3,\n            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n            pointers: 1\n        },\n\n        getTouchAction: function getTouchAction() {\n            return PanRecognizer.prototype.getTouchAction.call(this);\n        },\n\n        attrTest: function attrTest(input) {\n            var direction = this.options.direction;\n            var velocity;\n\n            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n                velocity = input.overallVelocity;\n            } else if (direction & DIRECTION_HORIZONTAL) {\n                velocity = input.overallVelocityX;\n            } else if (direction & DIRECTION_VERTICAL) {\n                velocity = input.overallVelocityY;\n            }\n\n            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n        },\n\n        emit: function emit(input) {\n            var direction = directionStr(input.offsetDirection);\n            if (direction) {\n                this.manager.emit(this.options.event + direction, input);\n            }\n\n            this.manager.emit(this.options.event, input);\n        }\n    });\n\n    /**\n     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n     * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n     * a single tap.\n     *\n     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n     * multi-taps being recognized.\n     * @constructor\n     * @extends Recognizer\n     */\n    function TapRecognizer() {\n        Recognizer.apply(this, arguments);\n\n        // previous time and center,\n        // used for tap counting\n        this.pTime = false;\n        this.pCenter = false;\n\n        this._timer = null;\n        this._input = null;\n        this.count = 0;\n    }\n\n    inherit(TapRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof PinchRecognizer\n         */\n        defaults: {\n            event: 'tap',\n            pointers: 1,\n            taps: 1,\n            interval: 300, // max time between the multi-tap taps\n            time: 250, // max time of the pointer to be down (like finger on the screen)\n            threshold: 9, // a minimal movement is ok, but keep it low\n            posThreshold: 10 // a multi-tap can be a bit off the initial position\n        },\n\n        getTouchAction: function getTouchAction() {\n            return [TOUCH_ACTION_MANIPULATION];\n        },\n\n        process: function process(input) {\n            var options = this.options;\n\n            var validPointers = input.pointers.length === options.pointers;\n            var validMovement = input.distance < options.threshold;\n            var validTouchTime = input.deltaTime < options.time;\n\n            this.reset();\n\n            if (input.eventType & INPUT_START && this.count === 0) {\n                return this.failTimeout();\n            }\n\n            // we only allow little movement\n            // and we've reached an end event, so a tap is possible\n            if (validMovement && validTouchTime && validPointers) {\n                if (input.eventType != INPUT_END) {\n                    return this.failTimeout();\n                }\n\n                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n                this.pTime = input.timeStamp;\n                this.pCenter = input.center;\n\n                if (!validMultiTap || !validInterval) {\n                    this.count = 1;\n                } else {\n                    this.count += 1;\n                }\n\n                this._input = input;\n\n                // if tap count matches we have recognized it,\n                // else it has began recognizing...\n                var tapCount = this.count % options.taps;\n                if (tapCount === 0) {\n                    // no failing requirements, immediately trigger the tap event\n                    // or wait as long as the multitap interval to trigger\n                    if (!this.hasRequireFailures()) {\n                        return STATE_RECOGNIZED;\n                    } else {\n                        this._timer = setTimeoutContext(function () {\n                            this.state = STATE_RECOGNIZED;\n                            this.tryEmit();\n                        }, options.interval, this);\n                        return STATE_BEGAN;\n                    }\n                }\n            }\n            return STATE_FAILED;\n        },\n\n        failTimeout: function failTimeout() {\n            this._timer = setTimeoutContext(function () {\n                this.state = STATE_FAILED;\n            }, this.options.interval, this);\n            return STATE_FAILED;\n        },\n\n        reset: function reset() {\n            clearTimeout(this._timer);\n        },\n\n        emit: function emit() {\n            if (this.state == STATE_RECOGNIZED) {\n                this._input.tapCount = this.count;\n                this.manager.emit(this.options.event, this._input);\n            }\n        }\n    });\n\n    /**\n     * Simple way to create a manager with a default set of recognizers.\n     * @param {HTMLElement} element\n     * @param {Object} [options]\n     * @constructor\n     */\n    function Hammer(element, options) {\n        options = options || {};\n        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n        return new Manager(element, options);\n    }\n\n    /**\n     * @const {string}\n     */\n    Hammer.VERSION = '2.0.8';\n\n    /**\n     * default settings\n     * @namespace\n     */\n    Hammer.defaults = {\n        /**\n         * set if DOM events are being triggered.\n         * But this is slower and unused by simple implementations, so disabled by default.\n         * @type {Boolean}\n         * @default false\n         */\n        domEvents: false,\n\n        /**\n         * The value for the touchAction property/fallback.\n         * When set to `compute` it will magically set the correct value based on the added recognizers.\n         * @type {String}\n         * @default compute\n         */\n        touchAction: TOUCH_ACTION_COMPUTE,\n\n        /**\n         * @type {Boolean}\n         * @default true\n         */\n        enable: true,\n\n        /**\n         * EXPERIMENTAL FEATURE -- can be removed/changed\n         * Change the parent input target element.\n         * If Null, then it is being set the to main element.\n         * @type {Null|EventTarget}\n         * @default null\n         */\n        inputTarget: null,\n\n        /**\n         * force an input class\n         * @type {Null|Function}\n         * @default null\n         */\n        inputClass: null,\n\n        /**\n         * Default recognizer setup when calling `Hammer()`\n         * When creating a new Manager these will be skipped.\n         * @type {Array}\n         */\n        preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],\n\n        /**\n         * Some CSS properties can be used to improve the working of Hammer.\n         * Add them to this method and they will be set when creating a new Manager.\n         * @namespace\n         */\n        cssProps: {\n            /**\n             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n             * @type {String}\n             * @default 'none'\n             */\n            userSelect: 'none',\n\n            /**\n             * Disable the Windows Phone grippers when pressing an element.\n             * @type {String}\n             * @default 'none'\n             */\n            touchSelect: 'none',\n\n            /**\n             * Disables the default callout shown when you touch and hold a touch target.\n             * On iOS, when you touch and hold a touch target such as a link, Safari displays\n             * a callout containing information about the link. This property allows you to disable that callout.\n             * @type {String}\n             * @default 'none'\n             */\n            touchCallout: 'none',\n\n            /**\n             * Specifies whether zooming is enabled. Used by IE10>\n             * @type {String}\n             * @default 'none'\n             */\n            contentZooming: 'none',\n\n            /**\n             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n             * @type {String}\n             * @default 'none'\n             */\n            userDrag: 'none',\n\n            /**\n             * Overrides the highlight color shown when the user taps a link or a JavaScript\n             * clickable element in iOS. This property obeys the alpha value, if specified.\n             * @type {String}\n             * @default 'rgba(0,0,0,0)'\n             */\n            tapHighlightColor: 'rgba(0,0,0,0)'\n        }\n    };\n\n    var STOP = 1;\n    var FORCED_STOP = 2;\n\n    /**\n     * Manager\n     * @param {HTMLElement} element\n     * @param {Object} [options]\n     * @constructor\n     */\n    function Manager(element, options) {\n        this.options = assign({}, Hammer.defaults, options || {});\n\n        this.options.inputTarget = this.options.inputTarget || element;\n\n        this.handlers = {};\n        this.session = {};\n        this.recognizers = [];\n        this.oldCssProps = {};\n\n        this.element = element;\n        this.input = createInputInstance(this);\n        this.touchAction = new TouchAction(this, this.options.touchAction);\n\n        toggleCssProps(this, true);\n\n        each(this.options.recognizers, function (item) {\n            var recognizer = this.add(new item[0](item[1]));\n            item[2] && recognizer.recognizeWith(item[2]);\n            item[3] && recognizer.requireFailure(item[3]);\n        }, this);\n    }\n\n    Manager.prototype = {\n        /**\n         * set options\n         * @param {Object} options\n         * @returns {Manager}\n         */\n        set: function set(options) {\n            assign(this.options, options);\n\n            // Options that need a little more setup\n            if (options.touchAction) {\n                this.touchAction.update();\n            }\n            if (options.inputTarget) {\n                // Clean up existing event listeners and reinitialize\n                this.input.destroy();\n                this.input.target = options.inputTarget;\n                this.input.init();\n            }\n            return this;\n        },\n\n        /**\n         * stop recognizing for this session.\n         * This session will be discarded, when a new [input]start event is fired.\n         * When forced, the recognizer cycle is stopped immediately.\n         * @param {Boolean} [force]\n         */\n        stop: function stop(force) {\n            this.session.stopped = force ? FORCED_STOP : STOP;\n        },\n\n        /**\n         * run the recognizers!\n         * called by the inputHandler function on every movement of the pointers (touches)\n         * it walks through all the recognizers and tries to detect the gesture that is being made\n         * @param {Object} inputData\n         */\n        recognize: function recognize(inputData) {\n            var session = this.session;\n            if (session.stopped) {\n                return;\n            }\n\n            // run the touch-action polyfill\n            this.touchAction.preventDefaults(inputData);\n\n            var recognizer;\n            var recognizers = this.recognizers;\n\n            // this holds the recognizer that is being recognized.\n            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n            // if no recognizer is detecting a thing, it is set to `null`\n            var curRecognizer = session.curRecognizer;\n\n            // reset when the last recognizer is recognized\n            // or when we're in a new session\n            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n                curRecognizer = session.curRecognizer = null;\n            }\n\n            var i = 0;\n            while (i < recognizers.length) {\n                recognizer = recognizers[i];\n\n                // find out if we are allowed try to recognize the input for this one.\n                // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n                //      that is being recognized.\n                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n                //      this can be setup with the `recognizeWith()` method on the recognizer.\n                if (session.stopped !== FORCED_STOP && ( // 1\n                !curRecognizer || recognizer == curRecognizer || // 2\n                recognizer.canRecognizeWith(curRecognizer))) {\n                    // 3\n                    recognizer.recognize(inputData);\n                } else {\n                    recognizer.reset();\n                }\n\n                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n                // current active recognizer. but only if we don't already have an active recognizer\n                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                    curRecognizer = session.curRecognizer = recognizer;\n                }\n                i++;\n            }\n        },\n\n        /**\n         * get a recognizer by its event name.\n         * @param {Recognizer|String} recognizer\n         * @returns {Recognizer|Null}\n         */\n        get: function get(recognizer) {\n            if (recognizer instanceof Recognizer) {\n                return recognizer;\n            }\n\n            var recognizers = this.recognizers;\n            for (var i = 0; i < recognizers.length; i++) {\n                if (recognizers[i].options.event == recognizer) {\n                    return recognizers[i];\n                }\n            }\n            return null;\n        },\n\n        /**\n         * add a recognizer to the manager\n         * existing recognizers with the same event name will be removed\n         * @param {Recognizer} recognizer\n         * @returns {Recognizer|Manager}\n         */\n        add: function add(recognizer) {\n            if (invokeArrayArg(recognizer, 'add', this)) {\n                return this;\n            }\n\n            // remove existing\n            var existing = this.get(recognizer.options.event);\n            if (existing) {\n                this.remove(existing);\n            }\n\n            this.recognizers.push(recognizer);\n            recognizer.manager = this;\n\n            this.touchAction.update();\n            return recognizer;\n        },\n\n        /**\n         * remove a recognizer by name or instance\n         * @param {Recognizer|String} recognizer\n         * @returns {Manager}\n         */\n        remove: function remove(recognizer) {\n            if (invokeArrayArg(recognizer, 'remove', this)) {\n                return this;\n            }\n\n            recognizer = this.get(recognizer);\n\n            // let's make sure this recognizer exists\n            if (recognizer) {\n                var recognizers = this.recognizers;\n                var index = inArray(recognizers, recognizer);\n\n                if (index !== -1) {\n                    recognizers.splice(index, 1);\n                    this.touchAction.update();\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * bind event\n         * @param {String} events\n         * @param {Function} handler\n         * @returns {EventEmitter} this\n         */\n        on: function on(events, handler) {\n            if (events === undefined) {\n                return;\n            }\n            if (handler === undefined) {\n                return;\n            }\n\n            var handlers = this.handlers;\n            each(splitStr(events), function (event) {\n                handlers[event] = handlers[event] || [];\n                handlers[event].push(handler);\n            });\n            return this;\n        },\n\n        /**\n         * unbind event, leave emit blank to remove all handlers\n         * @param {String} events\n         * @param {Function} [handler]\n         * @returns {EventEmitter} this\n         */\n        off: function off(events, handler) {\n            if (events === undefined) {\n                return;\n            }\n\n            var handlers = this.handlers;\n            each(splitStr(events), function (event) {\n                if (!handler) {\n                    delete handlers[event];\n                } else {\n                    handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n                }\n            });\n            return this;\n        },\n\n        /**\n         * emit event to the listeners\n         * @param {String} event\n         * @param {Object} data\n         */\n        emit: function emit(event, data) {\n            // we also want to trigger dom events\n            if (this.options.domEvents) {\n                triggerDomEvent(event, data);\n            }\n\n            // no handlers, so skip it all\n            var handlers = this.handlers[event] && this.handlers[event].slice();\n            if (!handlers || !handlers.length) {\n                return;\n            }\n\n            data.type = event;\n            data.preventDefault = function () {\n                data.srcEvent.preventDefault();\n            };\n\n            var i = 0;\n            while (i < handlers.length) {\n                handlers[i](data);\n                i++;\n            }\n        },\n\n        /**\n         * destroy the manager and unbinds all events\n         * it doesn't unbind dom events, that is the user own responsibility\n         */\n        destroy: function destroy() {\n            this.element && toggleCssProps(this, false);\n\n            this.handlers = {};\n            this.session = {};\n            this.input.destroy();\n            this.element = null;\n        }\n    };\n\n    /**\n     * add/remove the css properties as defined in manager.options.cssProps\n     * @param {Manager} manager\n     * @param {Boolean} add\n     */\n    function toggleCssProps(manager, add) {\n        var element = manager.element;\n        if (!element.style) {\n            return;\n        }\n        var prop;\n        each(manager.options.cssProps, function (value, name) {\n            prop = prefixed(element.style, name);\n            if (add) {\n                manager.oldCssProps[prop] = element.style[prop];\n                element.style[prop] = value;\n            } else {\n                element.style[prop] = manager.oldCssProps[prop] || '';\n            }\n        });\n        if (!add) {\n            manager.oldCssProps = {};\n        }\n    }\n\n    /**\n     * trigger dom event\n     * @param {String} event\n     * @param {Object} data\n     */\n    function triggerDomEvent(event, data) {\n        var gestureEvent = document.createEvent('Event');\n        gestureEvent.initEvent(event, true, true);\n        gestureEvent.gesture = data;\n        data.target.dispatchEvent(gestureEvent);\n    }\n\n    assign(Hammer, {\n        INPUT_START: INPUT_START,\n        INPUT_MOVE: INPUT_MOVE,\n        INPUT_END: INPUT_END,\n        INPUT_CANCEL: INPUT_CANCEL,\n\n        STATE_POSSIBLE: STATE_POSSIBLE,\n        STATE_BEGAN: STATE_BEGAN,\n        STATE_CHANGED: STATE_CHANGED,\n        STATE_ENDED: STATE_ENDED,\n        STATE_RECOGNIZED: STATE_RECOGNIZED,\n        STATE_CANCELLED: STATE_CANCELLED,\n        STATE_FAILED: STATE_FAILED,\n\n        DIRECTION_NONE: DIRECTION_NONE,\n        DIRECTION_LEFT: DIRECTION_LEFT,\n        DIRECTION_RIGHT: DIRECTION_RIGHT,\n        DIRECTION_UP: DIRECTION_UP,\n        DIRECTION_DOWN: DIRECTION_DOWN,\n        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n        DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n        DIRECTION_ALL: DIRECTION_ALL,\n\n        Manager: Manager,\n        Input: Input,\n        TouchAction: TouchAction,\n\n        TouchInput: TouchInput,\n        MouseInput: MouseInput,\n        PointerEventInput: PointerEventInput,\n        TouchMouseInput: TouchMouseInput,\n        SingleTouchInput: SingleTouchInput,\n\n        Recognizer: Recognizer,\n        AttrRecognizer: AttrRecognizer,\n        Tap: TapRecognizer,\n        Pan: PanRecognizer,\n        Swipe: SwipeRecognizer,\n        Pinch: PinchRecognizer,\n        Rotate: RotateRecognizer,\n        Press: PressRecognizer,\n\n        on: addEventListeners,\n        off: removeEventListeners,\n        each: each,\n        merge: merge,\n        extend: extend,\n        assign: assign,\n        inherit: inherit,\n        bindFn: bindFn,\n        prefixed: prefixed\n    });\n\n    // this prevents errors when Hammer is loaded in the presence of an AMD\n    //  style loader but by script tag, not by the loader.\n    var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line\n    freeGlobal.Hammer = Hammer;\n\n    if (typeof define === 'function' && __webpack_require__(3)) {\n        define(function () {\n            return Hammer;\n        });\n    } else if (typeof module != 'undefined' && module.exports) {\n        module.exports = Hammer;\n    } else {\n        window[exportName] = Hammer;\n    }\n})(window, document, 'Hammer');\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (window.Hammer);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)(module)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./src/common/debug.js\nvar debug = function debug(msg) {\n    window.console.log('[ImageViewer]:' + msg);\n};\n\n\n// CONCATENATED MODULE: ./src/common/dom.js\nvar transformProp = function getTransformProperty() {\n    var props = ['transform', 'webkitTransform', 'MozTransform', 'oTransform', 'msTransform'];\n    var style = document.createElement('div').style,\n        availProp = '';\n    props.forEach(function (prop) {\n        if (style[prop] !== undefined) {\n            availProp = prop;\n        }\n    });\n    return availProp;\n}();\n\nfunction query(selector, el) {\n    el = el || document;\n    return el.querySelectorAll(selector);\n}\n\nfunction removeElement(element) {\n    var parentElement = element.parentNode;\n    if (parentElement) {\n        parentElement.removeChild(element);\n    }\n}\n\nfunction setTranslateStyle(el, x, y) {\n    el.style[transformProp] = 'translate3d(' + (x + 'px') + ',' + (y + 'px') + ',0)';\n}\n\nfunction setScaleAndTranslateStyle(el, scale, x, y) {\n    el.style[transformProp] = 'scale3d(' + scale + ',' + scale + ',1) translate3d(' + (x + 'px') + ',' + (y + 'px') + ',0)';\n}\n\n\n// CONCATENATED MODULE: ./src/common/profile.js\nvar ITEM_ANIMATION_CLASS = 'viewer-animation';\nvar LOCK_NAME = 'STOP_SWIPE';\n\n\n// CONCATENATED MODULE: ./src/common/lock.js\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Lock = function () {\n    function Lock() {\n        _classCallCheck(this, Lock);\n\n        this._locks = {};\n    }\n\n    _createClass(Lock, [{\n        key: \"createLock\",\n        value: function createLock(name) {\n            this._locks[name] = false;\n        }\n    }, {\n        key: \"deleteLock\",\n        value: function deleteLock(name) {\n            delete this._locks[name];\n        }\n    }, {\n        key: \"getLock\",\n        value: function getLock(name) {\n            this._locks[name] = true;\n        }\n    }, {\n        key: \"releaseLock\",\n        value: function releaseLock(name) {\n            this._locks[name] = false;\n        }\n    }, {\n        key: \"getLockState\",\n        value: function getLockState(name) {\n            return this._locks[name];\n        }\n    }]);\n\n    return Lock;\n}();\n\n/* harmony default export */ var lock_defaultExport = (new Lock());\n// CONCATENATED MODULE: ./src/common/event.js\nvar event__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction event__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Event = function () {\n    /**\n     * 构造器\n     * @param _enableMultiple 标记该事件实例是否允许同一事件挂载多个处理函数\n     */\n    function Event() {\n        var _enableMultiple = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n        event__classCallCheck(this, Event);\n\n        this._enableMultiple = _enableMultiple;\n        this._handlers = {};\n    }\n\n    /**\n     * 绑定事件处理函数\n     * @param name 事件名字\n     * @param handler 对应的事件处理函数\n     * @param enableMultiple 标记该事件是否允许挂载多个处理函数\n     */\n\n\n    event__createClass(Event, [{\n        key: \"on\",\n        value: function on(name, handler, enableMultiple) {\n            enableMultiple = enableMultiple === undefined ? this._enableMultiple : enableMultiple;\n            if (enableMultiple) {\n                if (!this._handlers[name]) {\n                    this._handlers[name] = [];\n                }\n                this._handlers[name].push(handler);\n            } else {\n                this._handlers[name] = [handler];\n            }\n        }\n\n        /**\n         * 销毁对应的处理函数\n         * @param name 事件名\n         */\n\n    }, {\n        key: \"off\",\n        value: function off(name) {\n            delete this._handlers[name];\n        }\n\n        /**\n         * 触发事件\n         * @param name 事件名\n         * @param args 参数数组，传递给各个事件处理函数\n         */\n\n    }, {\n        key: \"emit\",\n        value: function emit(name) {\n            var _this = this;\n\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            var handlers = this._handlers[name] || [],\n                event = { stop: false },\n                length = handlers.length;\n            //传递给事件处理函数的第一个参数为事件对象\n            //该对象拥有一些可能会有用的属性和函数（比如可以终止处理函数链的执行exit）\n            args = args.concat([{\n                name: name, //事件名\n                length: length, //事件处理函数的数量\n                /**\n                 * 阻止继续执行函数处理链并退出\n                 */\n                exit: function exit() {\n                    event.stop = true;\n                }\n            }]);\n            if (length) {\n                //仅当存在处理函数时才执行\n                handlers.forEach(function (handler) {\n                    !event.stop && handler.apply(_this, args);\n                });\n            }\n        }\n    }]);\n\n    return Event;\n}();\n\n/* harmony default export */ var event_defaultExport = (Event);\n// CONCATENATED MODULE: ./src/core/viewer.js\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_hammer__ = __webpack_require__(0);\nvar viewer__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction viewer__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\n\n\nvar viewer_Viewer = function () {\n    function Viewer(imageViewer, el, width, height, index) {\n        viewer__classCallCheck(this, Viewer);\n\n        this.event = new event_defaultExport(false);\n        this.imageViewer = imageViewer;\n        this.el = el; //.viewer类\n        this.panelEl = el.firstElementChild; //.panel类\n        this.imageEl = query('img', this.el)[0];\n        this.src = '';\n        this.index = index; //viewer排序用，记录原始的数组位置\n        this.displayIndex = 0;\n        this.width = width;\n        this.height = height;\n        this.realWidth = 0;\n        this.realHeight = 0;\n        this.translateX = 0;\n        this.translateY = 0;\n        this.scale = 1; //缩放比例\n        this.currentScale = 1; //当前正在缩放的倍数(临时保存,当事件结束后,会赋值回scale)\n        this.translatePanelX = 0; //最终图片面板所在的X轴坐标\n        this.translatePanelY = 0; //最终图片面板所在的Y轴坐标\n        this.currentPanelX = 0; //当前图片面板所在的X轴坐标（手指尚未离开屏幕）\n        this.currentPanelY = 0; //当前图片面板所在的Y轴坐标（手指尚未离开屏幕）\n        this.allowDistanceX = 0; //图片放大后，允许拖动的最大X轴距离\n        this.allowDistanceY = 0; //图片放大后，允许拖动的最大Y轴距离\n        this.needResetX = false; //拖动图片超出边界时，需要重置一下x轴的坐标\n        this.needResetY = false; //拖动图片超出边界时，需要重置一下y轴的坐标\n        this.deltaX = 0; //存储起始的X轴偏移量\n        this.deltaY = 0; //存储起始的Y轴偏移量\n        this.EVENT_NAME = 'IMG_LOAD_COMPLETE';\n        this._bindEvent();\n    }\n\n    viewer__createClass(Viewer, [{\n        key: 'init',\n        value: function init() {\n            var displayIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            var resetScale = arguments[1];\n            var fn = arguments[2];\n\n            var _this = this;\n\n            var needLoad = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n            var src = arguments[4];\n\n            var _initImage = function _initImage() {\n                if (resetScale) {\n                    _this.scale = 1;\n                    _this.allowDistanceX = _this.allowDistanceY = 0;\n                }\n                if (needLoad) {\n                    _this.imageEl.style.display = '';\n                }\n                _this.translatePanelX = 0;\n                _this.translatePanelY = 0;\n                _this.currentPanelX = 0;\n                _this.currentPanelY = 0;\n                _this.realWidth = _this.panelEl.clientWidth * _this.scale;\n                _this.realHeight = _this.panelEl.clientHeight * _this.scale;\n                _this.translateX = _this.displayIndex * _this.width;\n                _this.translateY = -_this.el.clientHeight / 2;\n                _this.needResetX = _this.needResetY = false;\n                setScaleAndTranslateStyle(_this.panelEl, _this.scale, _this.translatePanelX, _this.translatePanelY);\n                setTranslateStyle(_this.el, _this.translateX, _this.translateY);\n                fn && fn.apply(_this);\n            };\n            this.displayIndex = displayIndex;\n\n            if (needLoad) {\n                this.src = src;\n                this.imageEl.src = this.src;\n                this.imageEl.style.display = 'none';\n                this.event.on(this.EVENT_NAME, function () {\n                    _initImage();\n                });\n                setTranslateStyle(this.el, this.displayIndex * this.width, this.translateY);\n            } else {\n                _initImage();\n            }\n            return this;\n        }\n    }, {\n        key: '_bindEvent',\n        value: function _bindEvent() {\n            var _this2 = this;\n\n            var mc = new __WEBPACK_IMPORTED_MODULE_4__lib_hammer__[\"a\" /* default */].Manager(this.panelEl);\n            mc.add(new __WEBPACK_IMPORTED_MODULE_4__lib_hammer__[\"a\" /* default */].Pan());\n            mc.on('panstart', function (event) {\n                _this2.removeAnimation();\n                if (lock_defaultExport.getLockState(LOCK_NAME)) {\n                    _this2.deltaX = event.deltaX;\n                    _this2.deltaY = event.deltaY;\n                }\n            });\n            mc.on('panmove', function (event) {\n                if (lock_defaultExport.getLockState(LOCK_NAME)) {\n                    event.preventDefault();\n                    _this2._translatePanel(event.deltaX - _this2.deltaX, event.deltaY - _this2.deltaY);\n                }\n            });\n            mc.on('panend', function (event) {\n                if (lock_defaultExport.getLockState(LOCK_NAME)) {\n                    _this2._translatePanelEnd(event.deltaX - _this2.deltaX);\n                }\n            });\n\n            this.imageEl.addEventListener('load', function () {\n                _this2.event.emit(_this2.EVENT_NAME);\n            }, false);\n        }\n    }, {\n        key: '_pinchStart',\n        value: function _pinchStart() {\n            this.removeAnimation();\n            this.panelEl.style.willChange = 'transform';\n        }\n    }, {\n        key: '_pinch',\n        value: function _pinch(scale) {\n            var currentScale = scale * this.scale + this.scale;\n            if (currentScale > 0.5 && currentScale < 8) {\n                this.currentScale = currentScale;\n                setScaleAndTranslateStyle(this.panelEl, this.currentScale, this.translatePanelX, this.translatePanelY);\n            }\n            return this;\n        }\n    }, {\n        key: '_pinchEnd',\n        value: function _pinchEnd(scale) {\n            this.scale = isNaN(scale) ? this.currentScale : scale;\n            this.realWidth = this.panelEl.clientWidth * this.scale;\n            this.realHeight = this.panelEl.clientHeight * this.scale;\n            this.allowDistanceX = (this.realWidth - this.width) / 2 / this.scale + 2;\n            this.allowDistanceY = (this.realHeight - this.height) / 2 / this.scale + 2;\n            if (this.realWidth < this.width || this.realHeight < this.height) {\n                this.init(this.displayIndex, false, null, false);\n            }\n            if (this.isScale()) {\n                lock_defaultExport.getLock(LOCK_NAME);\n            } else {\n                lock_defaultExport.releaseLock(LOCK_NAME);\n            }\n            this.panelEl.style.willChange = 'auto';\n            return this;\n        }\n    }, {\n        key: '_calculate',\n        value: function _calculate(a, b) {\n            return a > 0 ? a - b : a + b;\n        }\n    }, {\n        key: '_translatePanel',\n        value: function _translatePanel(translatePanelX, translatePanelY) {\n            var tempX = 0;\n            if (this.realWidth <= this.width && translatePanelX) {\n                this.imageViewer._dealWithMoveAction({ deltaX: translatePanelX }, true);\n            } else {\n                if (this.allowDistanceX > 0 && translatePanelX) {\n                    this.currentPanelX = translatePanelX / this.scale + this.translatePanelX;\n                    this.needResetX = !(-this.allowDistanceX < this.currentPanelX && this.currentPanelX < this.allowDistanceX);\n                }\n\n                if (this.needResetX) {\n                    this.imageViewer._dealWithMoveAction({ deltaX: this._calculate(this.currentPanelX, this.allowDistanceX) }, true);\n                    tempX = this.currentPanelX > 0 ? this.allowDistanceX : -this.allowDistanceX;\n                } else {\n                    this.imageViewer._dealWithMoveAction({ deltaX: 0 }, true);\n                    tempX = this.currentPanelX;\n                }\n            }\n            if (this.allowDistanceY > 0 && translatePanelY) {\n                this.currentPanelY = translatePanelY / this.scale + this.translatePanelY;\n                this.needResetY = !(-this.allowDistanceY < this.currentPanelY && this.currentPanelY < this.allowDistanceY);\n            }\n            setScaleAndTranslateStyle(this.panelEl, this.scale, tempX, this.currentPanelY);\n            return this;\n        }\n    }, {\n        key: '_translatePanelEnd',\n        value: function _translatePanelEnd(translatePanelX) {\n            var needSwipe = false;\n            if (this.realWidth <= this.width && translatePanelX) {\n                needSwipe = this.imageViewer._dealWithMoveActionEnd({ deltaX: translatePanelX }, true);\n            } else if (this.needResetX) {\n                needSwipe = this.imageViewer._dealWithMoveActionEnd({ deltaX: this._calculate(this.currentPanelX, this.allowDistanceX) }, true);\n            }\n            if (needSwipe) {\n                //滑动到下一张，重置当前图片的尺寸\n                this.init(this.displayIndex, true, null, false);\n                setTimeout(function () {\n                    lock_defaultExport.releaseLock(LOCK_NAME);\n                }, 0);\n            } else {\n                if (this.needResetX) {\n                    this.translatePanelX = this.currentPanelX > 0 ? this.allowDistanceX : -this.allowDistanceX;\n                } else {\n                    this.translatePanelX = this.currentPanelX;\n                }\n                if (this.needResetY) {\n                    this.translatePanelY = this.currentPanelY > 0 ? this.allowDistanceY : -this.allowDistanceY;\n                } else {\n                    this.translatePanelY = this.currentPanelY;\n                }\n                if (this.needResetX || this.needResetY) {\n                    this.addAnimation();\n                    setScaleAndTranslateStyle(this.panelEl, this.scale, this.translatePanelX, this.translatePanelY);\n                }\n                this.needResetX = this.needResetY = false;\n            }\n            return this;\n        }\n    }, {\n        key: 'isScale',\n        value: function isScale() {\n            return Math.abs(this.scale - 1) > 0.01;\n        }\n    }, {\n        key: 'addAnimation',\n        value: function addAnimation() {\n            this.panelEl.classList.add(ITEM_ANIMATION_CLASS);\n            this.el.classList.add(ITEM_ANIMATION_CLASS);\n        }\n    }, {\n        key: 'removeAnimation',\n        value: function removeAnimation() {\n            this.panelEl.classList.remove(ITEM_ANIMATION_CLASS);\n            this.el.classList.remove(ITEM_ANIMATION_CLASS);\n        }\n    }]);\n\n    return Viewer;\n}();\n\n/* harmony default export */ var viewer_defaultExport = (viewer_Viewer);\n// CONCATENATED MODULE: ./src/core/imageViewer.js\n/* harmony import */ var imageViewer___WEBPACK_IMPORTED_MODULE_4__lib_hammer__ = __webpack_require__(0);\nvar imageViewer__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction imageViewer__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\n\n\n\nvar imageViewer_ImageViewer = function () {\n    function ImageViewer() {\n        var images = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        imageViewer__classCallCheck(this, ImageViewer);\n\n        this.opt = opt;\n        this.el = null;\n        this.headerEl = null;\n        this.bodyEl = null;\n        this.footerEl = null;\n        this.currentNumberEl = null;\n        this.totalNumberEl = null;\n        this.images = images; //图片数据\n        this.imagesLength = images.length; //图片数据\n        this.container = opt.container || 'body';\n        this.enableScale = opt.enableScale === undefined ? true : opt.enableScale; //是否开启图片缩放功能\n        this.currentIndex = opt.startIndex || 0; //起始坐标，从0开始\n        this.viewers = [];\n        this.scaleStart = 1;\n        this.width = 0;\n        this.height = 0;\n        this.itemList = []; //各个图片容器元素的dom节点\n        this.hammer = null;\n        this.deltaX = 0;\n        this.translateX = 0;\n    }\n\n    imageViewer__createClass(ImageViewer, [{\n        key: '_create',\n        value: function _create() {\n            this.el = query('.image-viewer')[0];\n            this.destroy();\n            var imageViewerTemplate = '<div class=\"image-viewer\">\\n                <div class=\"image-header\"></div>\\n                <div class=\"image-body\">\\n                    <div class=\"viewer\"><div class=\"panel\"><img></div></div>\\n                    <div class=\"viewer\"><div class=\"panel\"><img></div></div>\\n                    <div class=\"viewer\"><div class=\"panel\"><img></div></div>\\n                </div>\\n                <div class=\"image-footer\"></div>\\n            </div>';\n\n            var divEl = document.createElement('div');\n            divEl.innerHTML = imageViewerTemplate;\n            this.el = divEl.firstElementChild;\n            query(this.container)[0].appendChild(this.el);\n            this.headerEl = query('.image-header', this.el)[0];\n            this.bodyEl = query('.image-body', this.el)[0];\n            this.footerEl = query('.image-footer', this.el)[0];\n            this.itemList = query('.image-body', this.el)[0].children;\n            this.width = this.el.clientWidth;\n            this.height = this.el.clientHeight;\n\n            if (this.opt.headerRender) {\n                this.headerEl.innerHTML = this.opt.headerRender();\n            }\n            if (this.opt.footerRender) {\n                this.footerEl.innerHTML = this.opt.footerRender();\n            }\n            this.currentNumberEl = query('.number-current', this.el)[0]; //当前滑动所在的图片下标的元素节点\n            this.totalNumberEl = query('.number-total', this.el)[0]; //图片总数的元素节点\n        }\n    }, {\n        key: '_init',\n        value: function _init() {\n            this.viewers = [];\n            for (var i = 0, length = this.itemList.length, item; i < length; i++) {\n                item = this.itemList[i];\n                this.viewers.push(new viewer_defaultExport(this, item, this.width, this.height, i));\n            }\n            this.swipeInByIndex(this.currentIndex);\n            lock_defaultExport.createLock(LOCK_NAME);\n        }\n    }, {\n        key: '_updateCountElement',\n        value: function _updateCountElement() {\n            if (this.currentNumberEl) {\n                this.currentNumberEl.innerText = this.currentIndex + 1;\n            }\n            if (this.totalNumberEl) {\n                this.totalNumberEl.innerText = this.imagesLength;\n            }\n        }\n    }, {\n        key: '_bindEvent',\n        value: function _bindEvent() {\n            var mc = new imageViewer___WEBPACK_IMPORTED_MODULE_4__lib_hammer__[\"a\" /* default */].Manager(this.el);\n            var hPinch = new imageViewer___WEBPACK_IMPORTED_MODULE_4__lib_hammer__[\"a\" /* default */].Pinch(),\n                //前缀h代表hammer\n            hPan = new imageViewer___WEBPACK_IMPORTED_MODULE_4__lib_hammer__[\"a\" /* default */].Pan({ direction: imageViewer___WEBPACK_IMPORTED_MODULE_4__lib_hammer__[\"a\" /* default */].DIRECTION_HORIZONTAL }),\n                hTap = new imageViewer___WEBPACK_IMPORTED_MODULE_4__lib_hammer__[\"a\" /* default */].Tap({ taps: 2 });\n            mc.add([hPinch, hPan, hTap]);\n            mc.on('panstart', this._dealWithMoveActionStart.bind(this));\n            mc.on('panmove', this._dealWithMoveAction.bind(this));\n            mc.on('panend', this._dealWithMoveActionEnd.bind(this));\n            if (this.enableScale) {\n                mc.on('tap', this.reset.bind(this));\n                mc.on('pinchstart', this._dealWithScaleActionStart.bind(this));\n                mc.on('pinch', this._dealWithScaleAction.bind(this));\n                mc.on('pinchend', this._dealWithScaleActionEnd.bind(this));\n            }\n            this.hammer = mc;\n        }\n    }, {\n        key: '_dealWithMoveActionStart',\n        value: function _dealWithMoveActionStart(event) {\n            if (lock_defaultExport.getLockState(LOCK_NAME)) return;\n            this.bodyEl.classList.remove(ITEM_ANIMATION_CLASS);\n            this.opt.beforeSwipe && this.opt.beforeSwipe(this.currentIndex);\n            this.deltaX = event.deltaX;\n            this.bodyEl.style.willChange = 'transform';\n        }\n    }, {\n        key: '_dealWithMoveAction',\n        value: function _dealWithMoveAction(event, force) {\n            if (lock_defaultExport.getLockState(LOCK_NAME) && !force) return;\n            force && this.bodyEl.classList.remove(ITEM_ANIMATION_CLASS);\n            var distance = event.deltaX - this.deltaX;\n            setTranslateStyle(this.bodyEl, this.translateX + distance, 0);\n        }\n    }, {\n        key: '_dealWithMoveActionEnd',\n        value: function _dealWithMoveActionEnd(event, force) {\n            if (lock_defaultExport.getLockState(LOCK_NAME) && !force) return;\n            var distance = event.deltaX - this.deltaX,\n                needSwipe = false,\n                needBreak = false;\n\n            if (this.currentIndex === 0 && distance > 0 && this.opt.swipeFirstRight) {\n                //当前图片是第一张，并且向右滑动\n                needBreak = this.opt.swipeFirstRight(this, Math.abs(distance));\n            } else if (this.currentIndex === this.imagesLength - 1 && distance < 0 && this.opt.swipeLastLeft) {\n                //当前图片是最后一张，并且向左滑动\n                needBreak = this.opt.swipeLastLeft(this, Math.abs(distance));\n            }\n\n            if (!needBreak) {\n                distance !== 0 && this.bodyEl.classList.add(ITEM_ANIMATION_CLASS);\n                if (distance !== 0 && this._checkDistance(distance)) {\n                    this.viewers.forEach(function (viewer) {\n                        viewer.removeAnimation();\n                    });\n                    needSwipe = distance > 0 ? this.swipeToPrev() : this.swipeToNext();\n                    this._updateCountElement();\n                } else {\n                    setTranslateStyle(this.bodyEl, this.translateX, 0);\n                }\n                this.opt.afterSwipe && this.opt.afterSwipe(this.currentIndex);\n            }\n            this.deltaX = 0;\n            this.bodyEl.style.willChange = 'auto';\n            return needSwipe;\n        }\n    }, {\n        key: '_dealWithScaleActionStart',\n        value: function _dealWithScaleActionStart(event) {\n            this.scaleStart = event.scale;\n            this.viewers[1]._pinchStart();\n        }\n    }, {\n        key: '_dealWithScaleAction',\n        value: function _dealWithScaleAction(event) {\n            this.viewers[1]._pinch(event.scale - this.scaleStart);\n        }\n    }, {\n        key: '_dealWithScaleActionEnd',\n        value: function _dealWithScaleActionEnd() {\n            this.viewers[1]._pinchEnd();\n        }\n    }, {\n        key: '_checkDistance',\n        value: function _checkDistance() {\n            var distance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            return Math.abs(distance) > this.width / 5;\n        }\n    }, {\n        key: '_getPrevImage',\n        value: function _getPrevImage() {\n            var minuend = this.currentIndex;\n            if (this.opt.loop && this.imagesLength > 2) {\n                minuend = this.currentIndex === 0 ? this.imagesLength : this.currentIndex;\n            }\n            return this.images[minuend - 1] || '';\n        }\n    }, {\n        key: '_getCurrentImage',\n        value: function _getCurrentImage() {\n            return this.images[this.currentIndex] || '';\n        }\n    }, {\n        key: '_getNextImage',\n        value: function _getNextImage() {\n            var addend = this.currentIndex;\n            if (this.opt.loop && this.imagesLength > 2) {\n                addend = this.currentIndex === this.imagesLength - 1 ? -1 : this.currentIndex;\n            }\n            return this.images[addend + 1] || '';\n        }\n    }, {\n        key: '_getSpecificImage',\n        value: function _getSpecificImage(index) {\n            return this.images[index] || '';\n        }\n\n        /**\n         * 重置当前图片的缩放\n         */\n\n    }, {\n        key: 'reset',\n        value: function reset() {\n            var viewer = this.viewers[1];\n            viewer.init(viewer.displayIndex, true, null, false);\n            setTimeout(function () {\n                lock_defaultExport.releaseLock(LOCK_NAME);\n            }, 0);\n        }\n\n        /**\n         * 移动循环队列\n         * @param direction 方向，0：队首移动到队尾，1：队尾移动到队首\n         * @returns {*}\n         */\n\n    }, {\n        key: 'loopViewers',\n        value: function loopViewers(direction) {\n            var viewer = null;\n            if (direction === 0) {\n                viewer = this.viewers.shift();\n                this.viewers.push(viewer);\n            } else if (direction === 1) {\n                viewer = this.viewers.pop();\n                this.viewers = [viewer].concat(this.viewers);\n            }\n            return viewer;\n        }\n\n        /**\n         * 滑动到上一张\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'swipeToPrev',\n        value: function swipeToPrev() {\n            var prevImage = this._getPrevImage();\n            if (prevImage) {\n                this.currentIndex--;\n                this.translateX += this.width;\n                setTranslateStyle(this.bodyEl, this.translateX, 0);\n\n                var image = this._getSpecificImage(this.currentIndex - 1);\n                if (image || this.currentIndex === 0) {\n                    var viewer = this.loopViewers(1);\n                    viewer.init(viewer.displayIndex - 3, true, null, true, image);\n                }\n                return true;\n            } else {\n                setTranslateStyle(this.bodyEl, this.translateX, 0);\n                return false;\n            }\n        }\n\n        /**\n         * 滑动到下一张\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'swipeToNext',\n        value: function swipeToNext() {\n            var nextImage = this._getNextImage();\n            if (nextImage) {\n                this.currentIndex++;\n                this.translateX -= this.width;\n                setTranslateStyle(this.bodyEl, this.translateX, 0);\n\n                var image = this._getSpecificImage(this.currentIndex + 1);\n                if (image || this.currentIndex === this.imagesLength - 1) {\n                    var viewer = this.loopViewers(0);\n                    viewer.init(viewer.displayIndex + 3, true, null, true, image);\n                }\n                return true;\n            } else {\n                setTranslateStyle(this.bodyEl, this.translateX, 0);\n                return false;\n            }\n        }\n\n        /**\n         * 根据给定的下标移动到指定图片处\n         * @param index 数组下标，从0开始\n         */\n\n    }, {\n        key: 'swipeInByIndex',\n        value: function swipeInByIndex(index) {\n            if (!isNaN(index) && -1 < index && index < this.imagesLength) {\n                this.currentIndex = index;\n                this.translateX = 0;\n                setTranslateStyle(this.bodyEl, 0, 0);\n\n                this.viewers = this.viewers.sort(function (a, b) {\n                    return a.index < b.index;\n                });\n                this.viewers[0].init(-1, true, null, true, this._getPrevImage());\n                this.viewers[1].init(0, true, null, true, this._getCurrentImage());\n                this.viewers[2].init(1, true, null, true, this._getNextImage());\n\n                this._updateCountElement();\n            } else {\n                debug('illegal index!');\n            }\n        }\n    }, {\n        key: 'setImageOption',\n        value: function setImageOption() {\n            var images = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n            var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n            if (!images.length) {\n                debug('images array can not be empty!');\n            }\n            this.images = images;\n            this.imagesLength = images.length;\n            this.currentIndex = startIndex;\n            this._init();\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this.el && removeElement(this.el);\n        }\n    }, {\n        key: 'close',\n        value: function close() {\n            if (this.el) {\n                this.el.style.display = 'none';\n            }\n        }\n    }, {\n        key: 'open',\n        value: function open(index) {\n            this.currentIndex = index === undefined ? this.currentIndex : index;\n            if (!this.el) {\n                //仅仅实例化，但尚未初始化\n                this._create();\n                this._init();\n                this._bindEvent();\n            } else {\n                this.swipeInByIndex(this.currentIndex);\n            }\n            this.el.style.display = 'block';\n        }\n    }]);\n\n    return ImageViewer;\n}();\n\n/* harmony default export */ var imageViewer_defaultExport = (imageViewer_ImageViewer);\n// CONCATENATED MODULE: ./src/index.js\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_index_css__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_index_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__css_index_css__);\n\n\n\nwindow.ImageViewer = imageViewer_defaultExport;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(originalModule) {\r\n\tif(!originalModule.webpackPolyfill) {\r\n\t\tvar module = Object.create(originalModule);\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"exports\", {\r\n\t\t\tenumerable: true,\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(5);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(7)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../node_modules/.0.28.4@css-loader/index.js!../../node_modules/.1.3.3@postcss-loader/index.js!./index.css\", function() {\n\t\t\tvar newContent = require(\"!!../../node_modules/.0.28.4@css-loader/index.js!../../node_modules/.1.3.3@postcss-loader/index.js!./index.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(6)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, \".viewer-animation {\\n    transition: -webkit-transform .3s;\\n    transition: transform .3s;\\n    transition: transform .3s, -webkit-transform .3s;\\n}\\n\\n.image-viewer {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    background-color: black;\\n    z-index: 10000;\\n    font-size: 0;\\n    -webkit-transform: translate3d(0, 0, 0);\\n            transform: translate3d(0, 0, 0);\\n    -webkit-backface-visibility: hidden;\\n            backface-visibility: hidden;\\n    overflow: hidden;\\n}\\n\\n.image-viewer .viewer {\\n    display: inline-block;\\n    position: absolute;\\n    top: 50%;\\n    width: 100%;\\n    text-align: center;\\n    -webkit-transform: translate3d(0, -50%, 0);\\n            transform: translate3d(0, -50%, 0);\\n    -webkit-backface-visibility: hidden;\\n            backface-visibility: hidden;\\n}\\n\\n.image-viewer .image-header {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    color: #fff;\\n    font-size: 12px;\\n    z-index: 11;\\n}\\n\\n.image-viewer .image-body {\\n    width: 100%;\\n    height: 100%;\\n    font-size: 0;\\n    z-index: 10;\\n}\\n\\n.image-viewer .image-body .panel img {\\n    max-width: 100%;\\n    max-height: 100%;\\n}\\n\\n.image-viewer .image-footer {\\n    position: absolute;\\n    left: 0;\\n    bottom: 0;\\n    width: 100%;\\n    color: #fff;\\n    font-size: 12px;\\n    z-index: 11;\\n}\\n\\n.image-viewer .panel {\\n    display: inline-block;\\n    overflow: hidden;\\n}\", \"\"]);\n\n// exports\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\tlinkElement.rel = \"stylesheet\";\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// imageViewer.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 614d70d1db3077edc20f","(function (window, document, exportName, undefined) {\n    'use strict';\n\n    var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n    var TEST_ELEMENT = document.createElement('div');\n\n    var TYPE_FUNCTION = 'function';\n\n    var round = Math.round;\n    var abs = Math.abs;\n    var now = Date.now;\n\n    /**\n     * set a timeout with a given scope\n     * @param {Function} fn\n     * @param {Number} timeout\n     * @param {Object} context\n     * @returns {number}\n     */\n    function setTimeoutContext(fn, timeout, context) {\n        return setTimeout(bindFn(fn, context), timeout);\n    }\n\n    /**\n     * if the argument is an array, we want to execute the fn on each entry\n     * if it aint an array we don't want to do a thing.\n     * this is used by all the methods that accept a single and array argument.\n     * @param {*|Array} arg\n     * @param {String} fn\n     * @param {Object} [context]\n     * @returns {Boolean}\n     */\n    function invokeArrayArg(arg, fn, context) {\n        if (Array.isArray(arg)) {\n            each(arg, context[fn], context);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * walk objects and arrays\n     * @param {Object} obj\n     * @param {Function} iterator\n     * @param {Object} context\n     */\n    function each(obj, iterator, context) {\n        var i;\n\n        if (!obj) {\n            return;\n        }\n\n        if (obj.forEach) {\n            obj.forEach(iterator, context);\n        } else if (obj.length !== undefined) {\n            i = 0;\n            while (i < obj.length) {\n                iterator.call(context, obj[i], i, obj);\n                i++;\n            }\n        } else {\n            for (i in obj) {\n                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n            }\n        }\n    }\n\n    /**\n     * wrap a method with a deprecation warning and stack trace\n     * @param {Function} method\n     * @param {String} name\n     * @param {String} message\n     * @returns {Function} A new function wrapping the supplied method.\n     */\n    function deprecate(method, name, message) {\n        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n        return function () {\n            var e = new Error('get-stack-trace');\n            var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n                    .replace(/^\\s+at\\s+/gm, '')\n                    .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n            var log = window.console && (window.console.warn || window.console.log);\n            if (log) {\n                log.call(window.console, deprecationMessage, stack);\n            }\n            return method.apply(this, arguments);\n        };\n    }\n\n    /**\n     * extend object.\n     * means that properties in dest will be overwritten by the ones in src.\n     * @param {Object} target\n     * @param {...Object} objects_to_assign\n     * @returns {Object} target\n     */\n    var assign;\n    if (typeof Object.assign !== 'function') {\n        assign = function assign(target) {\n            if (target === undefined || target === null) {\n                throw new TypeError('Cannot convert undefined or null to object');\n            }\n\n            var output = Object(target);\n            for (var index = 1; index < arguments.length; index++) {\n                var source = arguments[index];\n                if (source !== undefined && source !== null) {\n                    for (var nextKey in source) {\n                        if (source.hasOwnProperty(nextKey)) {\n                            output[nextKey] = source[nextKey];\n                        }\n                    }\n                }\n            }\n            return output;\n        };\n    } else {\n        assign = Object.assign;\n    }\n\n    /**\n     * extend object.\n     * means that properties in dest will be overwritten by the ones in src.\n     * @param {Object} dest\n     * @param {Object} src\n     * @param {Boolean} [merge=false]\n     * @returns {Object} dest\n     */\n    var extend = deprecate(function extend(dest, src, merge) {\n        var keys = Object.keys(src);\n        var i = 0;\n        while (i < keys.length) {\n            if (!merge || (merge && dest[keys[i]] === undefined)) {\n                dest[keys[i]] = src[keys[i]];\n            }\n            i++;\n        }\n        return dest;\n    }, 'extend', 'Use `assign`.');\n\n    /**\n     * merge the values from src in the dest.\n     * means that properties that exist in dest will not be overwritten by src\n     * @param {Object} dest\n     * @param {Object} src\n     * @returns {Object} dest\n     */\n    var merge = deprecate(function merge(dest, src) {\n        return extend(dest, src, true);\n    }, 'merge', 'Use `assign`.');\n\n    /**\n     * simple class inheritance\n     * @param {Function} child\n     * @param {Function} base\n     * @param {Object} [properties]\n     */\n    function inherit(child, base, properties) {\n        var baseP = base.prototype,\n            childP;\n\n        childP = child.prototype = Object.create(baseP);\n        childP.constructor = child;\n        childP._super = baseP;\n\n        if (properties) {\n            assign(childP, properties);\n        }\n    }\n\n    /**\n     * simple function bind\n     * @param {Function} fn\n     * @param {Object} context\n     * @returns {Function}\n     */\n    function bindFn(fn, context) {\n        return function boundFn() {\n            return fn.apply(context, arguments);\n        };\n    }\n\n    /**\n     * let a boolean value also be a function that must return a boolean\n     * this first item in args will be used as the context\n     * @param {Boolean|Function} val\n     * @param {Array} [args]\n     * @returns {Boolean}\n     */\n    function boolOrFn(val, args) {\n        if (typeof val == TYPE_FUNCTION) {\n            return val.apply(args ? args[0] || undefined : undefined, args);\n        }\n        return val;\n    }\n\n    /**\n     * use the val2 when val1 is undefined\n     * @param {*} val1\n     * @param {*} val2\n     * @returns {*}\n     */\n    function ifUndefined(val1, val2) {\n        return (val1 === undefined) ? val2 : val1;\n    }\n\n    /**\n     * addEventListener with multiple events at once\n     * @param {EventTarget} target\n     * @param {String} types\n     * @param {Function} handler\n     */\n    function addEventListeners(target, types, handler) {\n        each(splitStr(types), function (type) {\n            target.addEventListener(type, handler, false);\n        });\n    }\n\n    /**\n     * removeEventListener with multiple events at once\n     * @param {EventTarget} target\n     * @param {String} types\n     * @param {Function} handler\n     */\n    function removeEventListeners(target, types, handler) {\n        each(splitStr(types), function (type) {\n            target.removeEventListener(type, handler, false);\n        });\n    }\n\n    /**\n     * find if a node is in the given parent\n     * @method hasParent\n     * @param {HTMLElement} node\n     * @param {HTMLElement} parent\n     * @return {Boolean} found\n     */\n    function hasParent(node, parent) {\n        while (node) {\n            if (node == parent) {\n                return true;\n            }\n            node = node.parentNode;\n        }\n        return false;\n    }\n\n    /**\n     * small indexOf wrapper\n     * @param {String} str\n     * @param {String} find\n     * @returns {Boolean} found\n     */\n    function inStr(str, find) {\n        return str.indexOf(find) > -1;\n    }\n\n    /**\n     * split string on whitespace\n     * @param {String} str\n     * @returns {Array} words\n     */\n    function splitStr(str) {\n        return str.trim().split(/\\s+/g);\n    }\n\n    /**\n     * find if a array contains the object using indexOf or a simple polyFill\n     * @param {Array} src\n     * @param {String} find\n     * @param {String} [findByKey]\n     * @return {Boolean|Number} false when not found, or the index\n     */\n    function inArray(src, find, findByKey) {\n        if (src.indexOf && !findByKey) {\n            return src.indexOf(find);\n        } else {\n            var i = 0;\n            while (i < src.length) {\n                if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                    return i;\n                }\n                i++;\n            }\n            return -1;\n        }\n    }\n\n    /**\n     * convert array-like objects to real arrays\n     * @param {Object} obj\n     * @returns {Array}\n     */\n    function toArray(obj) {\n        return Array.prototype.slice.call(obj, 0);\n    }\n\n    /**\n     * unique array with objects based on a key (like 'id') or just by the array's value\n     * @param {Array} src [{id:1},{id:2},{id:1}]\n     * @param {String} [key]\n     * @param {Boolean} [sort=False]\n     * @returns {Array} [{id:1},{id:2}]\n     */\n    function uniqueArray(src, key, sort) {\n        var results = [];\n        var values = [];\n        var i = 0;\n\n        while (i < src.length) {\n            var val = key ? src[i][key] : src[i];\n            if (inArray(values, val) < 0) {\n                results.push(src[i]);\n            }\n            values[i] = val;\n            i++;\n        }\n\n        if (sort) {\n            if (!key) {\n                results = results.sort();\n            } else {\n                results = results.sort(function sortUniqueArray(a, b) {\n                    return a[key] > b[key];\n                });\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     * get the prefixed property\n     * @param {Object} obj\n     * @param {String} property\n     * @returns {String|Undefined} prefixed\n     */\n    function prefixed(obj, property) {\n        var prefix, prop;\n        var camelProp = property[0].toUpperCase() + property.slice(1);\n\n        var i = 0;\n        while (i < VENDOR_PREFIXES.length) {\n            prefix = VENDOR_PREFIXES[i];\n            prop = (prefix) ? prefix + camelProp : property;\n\n            if (prop in obj) {\n                return prop;\n            }\n            i++;\n        }\n        return undefined;\n    }\n\n    /**\n     * get a unique id\n     * @returns {number} uniqueId\n     */\n    var _uniqueId = 1;\n\n    function uniqueId() {\n        return _uniqueId++;\n    }\n\n    /**\n     * get the window object of an element\n     * @param {HTMLElement} element\n     * @returns {DocumentView|Window}\n     */\n    function getWindowForElement(element) {\n        var doc = element.ownerDocument || element;\n        return (doc.defaultView || doc.parentWindow || window);\n    }\n\n    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\n    var SUPPORT_TOUCH = ('ontouchstart' in window);\n    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\n    var INPUT_TYPE_TOUCH = 'touch';\n    var INPUT_TYPE_PEN = 'pen';\n    var INPUT_TYPE_MOUSE = 'mouse';\n    var INPUT_TYPE_KINECT = 'kinect';\n\n    var COMPUTE_INTERVAL = 25;\n\n    var INPUT_START = 1;\n    var INPUT_MOVE = 2;\n    var INPUT_END = 4;\n    var INPUT_CANCEL = 8;\n\n    var DIRECTION_NONE = 1;\n    var DIRECTION_LEFT = 2;\n    var DIRECTION_RIGHT = 4;\n    var DIRECTION_UP = 8;\n    var DIRECTION_DOWN = 16;\n\n    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\n    var PROPS_XY = ['x', 'y'];\n    var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n    /**\n     * create new input type manager\n     * @param {Manager} manager\n     * @param {Function} callback\n     * @returns {Input}\n     * @constructor\n     */\n    function Input(manager, callback) {\n        var self = this;\n        this.manager = manager;\n        this.callback = callback;\n        this.element = manager.element;\n        this.target = manager.options.inputTarget;\n\n        // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n        // so when disabled the input events are completely bypassed.\n        this.domHandler = function (ev) {\n            if (boolOrFn(manager.options.enable, [manager])) {\n                self.handler(ev);\n            }\n        };\n\n        this.init();\n\n    }\n\n    Input.prototype = {\n        /**\n         * should handle the inputEvent data and trigger the callback\n         * @virtual\n         */\n        handler: function () {\n        },\n\n        /**\n         * bind the events\n         */\n        init: function () {\n            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n        },\n\n        /**\n         * unbind the events\n         */\n        destroy: function () {\n            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n        }\n    };\n\n    /**\n     * create new input type manager\n     * called by the Manager constructor\n     * @param {Hammer} manager\n     * @returns {Input}\n     */\n    function createInputInstance(manager) {\n        var Type;\n        var inputClass = manager.options.inputClass;\n\n        if (inputClass) {\n            Type = inputClass;\n        } else if (SUPPORT_POINTER_EVENTS) {\n            Type = PointerEventInput;\n        } else if (SUPPORT_ONLY_TOUCH) {\n            Type = TouchInput;\n        } else if (!SUPPORT_TOUCH) {\n            Type = MouseInput;\n        } else {\n            Type = TouchMouseInput;\n        }\n        return new (Type)(manager, inputHandler);\n    }\n\n    /**\n     * handle input events\n     * @param {Manager} manager\n     * @param {String} eventType\n     * @param {Object} input\n     */\n    function inputHandler(manager, eventType, input) {\n        var pointersLen = input.pointers.length;\n        var changedPointersLen = input.changedPointers.length;\n        var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n        var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n        input.isFirst = !!isFirst;\n        input.isFinal = !!isFinal;\n\n        if (isFirst) {\n            manager.session = {};\n        }\n\n        // source event is the normalized value of the domEvents\n        // like 'touchstart, mouseup, pointerdown'\n        input.eventType = eventType;\n\n        // compute scale, rotation etc\n        computeInputData(manager, input);\n\n        // emit secret event\n        manager.emit('hammer.input', input);\n\n        manager.recognize(input);\n        manager.session.prevInput = input;\n    }\n\n    /**\n     * extend the data with some usable properties like scale, rotate, velocity etc\n     * @param {Object} manager\n     * @param {Object} input\n     */\n    function computeInputData(manager, input) {\n        var session = manager.session;\n        var pointers = input.pointers;\n        var pointersLength = pointers.length;\n\n        // store the first input to calculate the distance and direction\n        if (!session.firstInput) {\n            session.firstInput = simpleCloneInputData(input);\n        }\n\n        // to compute scale and rotation we need to store the multiple touches\n        if (pointersLength > 1 && !session.firstMultiple) {\n            session.firstMultiple = simpleCloneInputData(input);\n        } else if (pointersLength === 1) {\n            session.firstMultiple = false;\n        }\n\n        var firstInput = session.firstInput;\n        var firstMultiple = session.firstMultiple;\n        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n        var center = input.center = getCenter(pointers);\n        input.timeStamp = now();\n        input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n        input.angle = getAngle(offsetCenter, center);\n        input.distance = getDistance(offsetCenter, center);\n\n        computeDeltaXY(session, input);\n        input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n        input.overallVelocityX = overallVelocity.x;\n        input.overallVelocityY = overallVelocity.y;\n        input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n        input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n            session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n        computeIntervalInputData(session, input);\n\n        // find the correct target\n        var target = manager.element;\n        if (hasParent(input.srcEvent.target, target)) {\n            target = input.srcEvent.target;\n        }\n        input.target = target;\n    }\n\n    function computeDeltaXY(session, input) {\n        var center = input.center;\n        var offset = session.offsetDelta || {};\n        var prevDelta = session.prevDelta || {};\n        var prevInput = session.prevInput || {};\n\n        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n            prevDelta = session.prevDelta = {\n                x: prevInput.deltaX || 0,\n                y: prevInput.deltaY || 0\n            };\n\n            offset = session.offsetDelta = {\n                x: center.x,\n                y: center.y\n            };\n        }\n\n        input.deltaX = prevDelta.x + (center.x - offset.x);\n        input.deltaY = prevDelta.y + (center.y - offset.y);\n    }\n\n    /**\n     * velocity is calculated every x ms\n     * @param {Object} session\n     * @param {Object} input\n     */\n    function computeIntervalInputData(session, input) {\n        var last = session.lastInterval || input,\n            deltaTime = input.timeStamp - last.timeStamp,\n            velocity, velocityX, velocityY, direction;\n\n        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n            var deltaX = input.deltaX - last.deltaX;\n            var deltaY = input.deltaY - last.deltaY;\n\n            var v = getVelocity(deltaTime, deltaX, deltaY);\n            velocityX = v.x;\n            velocityY = v.y;\n            velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n            direction = getDirection(deltaX, deltaY);\n\n            session.lastInterval = input;\n        } else {\n            // use latest velocity info if it doesn't overtake a minimum period\n            velocity = last.velocity;\n            velocityX = last.velocityX;\n            velocityY = last.velocityY;\n            direction = last.direction;\n        }\n\n        input.velocity = velocity;\n        input.velocityX = velocityX;\n        input.velocityY = velocityY;\n        input.direction = direction;\n    }\n\n    /**\n     * create a simple clone from the input used for storage of firstInput and firstMultiple\n     * @param {Object} input\n     * @returns {Object} clonedInputData\n     */\n    function simpleCloneInputData(input) {\n        // make a simple copy of the pointers because we will get a reference if we don't\n        // we only need clientXY for the calculations\n        var pointers = [];\n        var i = 0;\n        while (i < input.pointers.length) {\n            pointers[i] = {\n                clientX: round(input.pointers[i].clientX),\n                clientY: round(input.pointers[i].clientY)\n            };\n            i++;\n        }\n\n        return {\n            timeStamp: now(),\n            pointers: pointers,\n            center: getCenter(pointers),\n            deltaX: input.deltaX,\n            deltaY: input.deltaY\n        };\n    }\n\n    /**\n     * get the center of all the pointers\n     * @param {Array} pointers\n     * @return {Object} center contains `x` and `y` properties\n     */\n    function getCenter(pointers) {\n        var pointersLength = pointers.length;\n\n        // no need to loop when only one touch\n        if (pointersLength === 1) {\n            return {\n                x: round(pointers[0].clientX),\n                y: round(pointers[0].clientY)\n            };\n        }\n\n        var x = 0, y = 0, i = 0;\n        while (i < pointersLength) {\n            x += pointers[i].clientX;\n            y += pointers[i].clientY;\n            i++;\n        }\n\n        return {\n            x: round(x / pointersLength),\n            y: round(y / pointersLength)\n        };\n    }\n\n    /**\n     * calculate the velocity between two points. unit is in px per ms.\n     * @param {Number} deltaTime\n     * @param {Number} x\n     * @param {Number} y\n     * @return {Object} velocity `x` and `y`\n     */\n    function getVelocity(deltaTime, x, y) {\n        return {\n            x: x / deltaTime || 0,\n            y: y / deltaTime || 0\n        };\n    }\n\n    /**\n     * get the direction between two points\n     * @param {Number} x\n     * @param {Number} y\n     * @return {Number} direction\n     */\n    function getDirection(x, y) {\n        if (x === y) {\n            return DIRECTION_NONE;\n        }\n\n        if (abs(x) >= abs(y)) {\n            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        }\n        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n    }\n\n    /**\n     * calculate the absolute distance between two points\n     * @param {Object} p1 {x, y}\n     * @param {Object} p2 {x, y}\n     * @param {Array} [props] containing x and y keys\n     * @return {Number} distance\n     */\n    function getDistance(p1, p2, props) {\n        if (!props) {\n            props = PROPS_XY;\n        }\n        var x = p2[props[0]] - p1[props[0]],\n            y = p2[props[1]] - p1[props[1]];\n\n        return Math.sqrt((x * x) + (y * y));\n    }\n\n    /**\n     * calculate the angle between two coordinates\n     * @param {Object} p1\n     * @param {Object} p2\n     * @param {Array} [props] containing x and y keys\n     * @return {Number} angle\n     */\n    function getAngle(p1, p2, props) {\n        if (!props) {\n            props = PROPS_XY;\n        }\n        var x = p2[props[0]] - p1[props[0]],\n            y = p2[props[1]] - p1[props[1]];\n        return Math.atan2(y, x) * 180 / Math.PI;\n    }\n\n    /**\n     * calculate the rotation degrees between two pointersets\n     * @param {Array} start array of pointers\n     * @param {Array} end array of pointers\n     * @return {Number} rotation\n     */\n    function getRotation(start, end) {\n        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n    }\n\n    /**\n     * calculate the scale factor between two pointersets\n     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n     * @param {Array} start array of pointers\n     * @param {Array} end array of pointers\n     * @return {Number} scale\n     */\n    function getScale(start, end) {\n        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n    }\n\n    var MOUSE_INPUT_MAP = {\n        mousedown: INPUT_START,\n        mousemove: INPUT_MOVE,\n        mouseup: INPUT_END\n    };\n\n    var MOUSE_ELEMENT_EVENTS = 'mousedown';\n    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n    /**\n     * Mouse events input\n     * @constructor\n     * @extends Input\n     */\n    function MouseInput() {\n        this.evEl = MOUSE_ELEMENT_EVENTS;\n        this.evWin = MOUSE_WINDOW_EVENTS;\n\n        this.pressed = false; // mousedown state\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(MouseInput, Input, {\n        /**\n         * handle mouse events\n         * @param {Object} ev\n         */\n        handler: function MEhandler(ev) {\n            var eventType = MOUSE_INPUT_MAP[ev.type];\n\n            // on start we want to have the left mouse button down\n            if (eventType & INPUT_START && ev.button === 0) {\n                this.pressed = true;\n            }\n\n            if (eventType & INPUT_MOVE && ev.which !== 1) {\n                eventType = INPUT_END;\n            }\n\n            // mouse must be down\n            if (!this.pressed) {\n                return;\n            }\n\n            if (eventType & INPUT_END) {\n                this.pressed = false;\n            }\n\n            this.callback(this.manager, eventType, {\n                pointers: [ev],\n                changedPointers: [ev],\n                pointerType: INPUT_TYPE_MOUSE,\n                srcEvent: ev\n            });\n        }\n    });\n\n    var POINTER_INPUT_MAP = {\n        pointerdown: INPUT_START,\n        pointermove: INPUT_MOVE,\n        pointerup: INPUT_END,\n        pointercancel: INPUT_CANCEL,\n        pointerout: INPUT_CANCEL\n    };\n\n// in IE10 the pointer types is defined as an enum\n    var IE10_POINTER_TYPE_ENUM = {\n        2: INPUT_TYPE_TOUCH,\n        3: INPUT_TYPE_PEN,\n        4: INPUT_TYPE_MOUSE,\n        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n    };\n\n    var POINTER_ELEMENT_EVENTS = 'pointerdown';\n    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\n    if (window.MSPointerEvent && !window.PointerEvent) {\n        POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n    }\n\n    /**\n     * Pointer events input\n     * @constructor\n     * @extends Input\n     */\n    function PointerEventInput() {\n        this.evEl = POINTER_ELEMENT_EVENTS;\n        this.evWin = POINTER_WINDOW_EVENTS;\n\n        Input.apply(this, arguments);\n\n        this.store = (this.manager.session.pointerEvents = []);\n    }\n\n    inherit(PointerEventInput, Input, {\n        /**\n         * handle mouse events\n         * @param {Object} ev\n         */\n        handler: function PEhandler(ev) {\n            var store = this.store;\n            var removePointer = false;\n\n            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n            var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n            // get index of the event in the store\n            var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n            // start and mouse must be down\n            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n                if (storeIndex < 0) {\n                    store.push(ev);\n                    storeIndex = store.length - 1;\n                }\n            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n                removePointer = true;\n            }\n\n            // it not found, so the pointer hasn't been down (so it's probably a hover)\n            if (storeIndex < 0) {\n                return;\n            }\n\n            // update the event in the store\n            store[storeIndex] = ev;\n\n            this.callback(this.manager, eventType, {\n                pointers: store,\n                changedPointers: [ev],\n                pointerType: pointerType,\n                srcEvent: ev\n            });\n\n            if (removePointer) {\n                // remove from the store\n                store.splice(storeIndex, 1);\n            }\n        }\n    });\n\n    var SINGLE_TOUCH_INPUT_MAP = {\n        touchstart: INPUT_START,\n        touchmove: INPUT_MOVE,\n        touchend: INPUT_END,\n        touchcancel: INPUT_CANCEL\n    };\n\n    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n    /**\n     * Touch events input\n     * @constructor\n     * @extends Input\n     */\n    function SingleTouchInput() {\n        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n        this.started = false;\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(SingleTouchInput, Input, {\n        handler: function TEhandler(ev) {\n            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n            // should we handle the touch events?\n            if (type === INPUT_START) {\n                this.started = true;\n            }\n\n            if (!this.started) {\n                return;\n            }\n\n            var touches = normalizeSingleTouches.call(this, ev, type);\n\n            // when done, reset the started state\n            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n                this.started = false;\n            }\n\n            this.callback(this.manager, type, {\n                pointers: touches[0],\n                changedPointers: touches[1],\n                pointerType: INPUT_TYPE_TOUCH,\n                srcEvent: ev\n            });\n        }\n    });\n\n    /**\n     * @this {TouchInput}\n     * @param {Object} ev\n     * @param {Number} type flag\n     * @returns {undefined|Array} [all, changed]\n     */\n    function normalizeSingleTouches(ev, type) {\n        var all = toArray(ev.touches);\n        var changed = toArray(ev.changedTouches);\n\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            all = uniqueArray(all.concat(changed), 'identifier', true);\n        }\n\n        return [all, changed];\n    }\n\n    var TOUCH_INPUT_MAP = {\n        touchstart: INPUT_START,\n        touchmove: INPUT_MOVE,\n        touchend: INPUT_END,\n        touchcancel: INPUT_CANCEL\n    };\n\n    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n    /**\n     * Multi-user touch events input\n     * @constructor\n     * @extends Input\n     */\n    function TouchInput() {\n        this.evTarget = TOUCH_TARGET_EVENTS;\n        this.targetIds = {};\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(TouchInput, Input, {\n        handler: function MTEhandler(ev) {\n            var type = TOUCH_INPUT_MAP[ev.type];\n            var touches = getTouches.call(this, ev, type);\n            if (!touches) {\n                return;\n            }\n\n            this.callback(this.manager, type, {\n                pointers: touches[0],\n                changedPointers: touches[1],\n                pointerType: INPUT_TYPE_TOUCH,\n                srcEvent: ev\n            });\n        }\n    });\n\n    /**\n     * @this {TouchInput}\n     * @param {Object} ev\n     * @param {Number} type flag\n     * @returns {undefined|Array} [all, changed]\n     */\n    function getTouches(ev, type) {\n        var allTouches = toArray(ev.touches);\n        var targetIds = this.targetIds;\n\n        // when there is only one touch, the process can be simplified\n        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n            targetIds[allTouches[0].identifier] = true;\n            return [allTouches, allTouches];\n        }\n\n        var i,\n            targetTouches,\n            changedTouches = toArray(ev.changedTouches),\n            changedTargetTouches = [],\n            target = this.target;\n\n        // get target touches from touches\n        targetTouches = allTouches.filter(function (touch) {\n            return hasParent(touch.target, target);\n        });\n\n        // collect touches\n        if (type === INPUT_START) {\n            i = 0;\n            while (i < targetTouches.length) {\n                targetIds[targetTouches[i].identifier] = true;\n                i++;\n            }\n        }\n\n        // filter changed touches to only contain touches that exist in the collected target ids\n        i = 0;\n        while (i < changedTouches.length) {\n            if (targetIds[changedTouches[i].identifier]) {\n                changedTargetTouches.push(changedTouches[i]);\n            }\n\n            // cleanup removed touches\n            if (type & (INPUT_END | INPUT_CANCEL)) {\n                delete targetIds[changedTouches[i].identifier];\n            }\n            i++;\n        }\n\n        if (!changedTargetTouches.length) {\n            return;\n        }\n\n        return [\n            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n            uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n            changedTargetTouches\n        ];\n    }\n\n    /**\n     * Combined touch and mouse input\n     *\n     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n     * This because touch devices also emit mouse events while doing a touch.\n     *\n     * @constructor\n     * @extends Input\n     */\n\n    var DEDUP_TIMEOUT = 2500;\n    var DEDUP_DISTANCE = 25;\n\n    function TouchMouseInput() {\n        Input.apply(this, arguments);\n\n        var handler = bindFn(this.handler, this);\n        this.touch = new TouchInput(this.manager, handler);\n        this.mouse = new MouseInput(this.manager, handler);\n\n        this.primaryTouch = null;\n        this.lastTouches = [];\n    }\n\n    inherit(TouchMouseInput, Input, {\n        /**\n         * handle mouse and touch events\n         * @param {Hammer} manager\n         * @param {String} inputEvent\n         * @param {Object} inputData\n         */\n        handler: function TMEhandler(manager, inputEvent, inputData) {\n            var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n                isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n                return;\n            }\n\n            // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n            if (isTouch) {\n                recordTouches.call(this, inputEvent, inputData);\n            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n                return;\n            }\n\n            this.callback(manager, inputEvent, inputData);\n        },\n\n        /**\n         * remove the event listeners\n         */\n        destroy: function destroy() {\n            this.touch.destroy();\n            this.mouse.destroy();\n        }\n    });\n\n    function recordTouches(eventType, eventData) {\n        if (eventType & INPUT_START) {\n            this.primaryTouch = eventData.changedPointers[0].identifier;\n            setLastTouch.call(this, eventData);\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            setLastTouch.call(this, eventData);\n        }\n    }\n\n    function setLastTouch(eventData) {\n        var touch = eventData.changedPointers[0];\n\n        if (touch.identifier === this.primaryTouch) {\n            var lastTouch = {x: touch.clientX, y: touch.clientY};\n            this.lastTouches.push(lastTouch);\n            var lts = this.lastTouches;\n            var removeLastTouch = function () {\n                var i = lts.indexOf(lastTouch);\n                if (i > -1) {\n                    lts.splice(i, 1);\n                }\n            };\n            setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n        }\n    }\n\n    function isSyntheticEvent(eventData) {\n        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n        for (var i = 0; i < this.lastTouches.length; i++) {\n            var t = this.lastTouches[i];\n            var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\n    var TOUCH_ACTION_COMPUTE = 'compute';\n    var TOUCH_ACTION_AUTO = 'auto';\n    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n    var TOUCH_ACTION_NONE = 'none';\n    var TOUCH_ACTION_PAN_X = 'pan-x';\n    var TOUCH_ACTION_PAN_Y = 'pan-y';\n    var TOUCH_ACTION_MAP = getTouchActionProps();\n\n    /**\n     * Touch Action\n     * sets the touchAction property or uses the js alternative\n     * @param {Manager} manager\n     * @param {String} value\n     * @constructor\n     */\n    function TouchAction(manager, value) {\n        this.manager = manager;\n        this.set(value);\n    }\n\n    TouchAction.prototype = {\n        /**\n         * set the touchAction value on the element or enable the polyfill\n         * @param {String} value\n         */\n        set: function (value) {\n            // find out the touch-action by the event handlers\n            if (value == TOUCH_ACTION_COMPUTE) {\n                value = this.compute();\n            }\n\n            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n            }\n            this.actions = value.toLowerCase().trim();\n        },\n\n        /**\n         * just re-set the touchAction value\n         */\n        update: function () {\n            this.set(this.manager.options.touchAction);\n        },\n\n        /**\n         * compute the value for the touchAction property based on the recognizer's settings\n         * @returns {String} value\n         */\n        compute: function () {\n            var actions = [];\n            each(this.manager.recognizers, function (recognizer) {\n                if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                    actions = actions.concat(recognizer.getTouchAction());\n                }\n            });\n            return cleanTouchActions(actions.join(' '));\n        },\n\n        /**\n         * this method is called on each input cycle and provides the preventing of the browser behavior\n         * @param {Object} input\n         */\n        preventDefaults: function (input) {\n            var srcEvent = input.srcEvent;\n            var direction = input.offsetDirection;\n\n            // if the touch action did prevented once this session\n            if (this.manager.session.prevented) {\n                srcEvent.preventDefault();\n                return;\n            }\n\n            var actions = this.actions;\n            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n            if (hasNone) {\n                //do not prevent defaults if this is a tap gesture\n\n                var isTapPointer = input.pointers.length === 1;\n                var isTapMovement = input.distance < 2;\n                var isTapTouchTime = input.deltaTime < 250;\n\n                if (isTapPointer && isTapMovement && isTapTouchTime) {\n                    return;\n                }\n            }\n\n            if (hasPanX && hasPanY) {\n                // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n                return;\n            }\n\n            if (hasNone ||\n                (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n                (hasPanX && direction & DIRECTION_VERTICAL)) {\n                return this.preventSrc(srcEvent);\n            }\n        },\n\n        /**\n         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n         * @param {Object} srcEvent\n         */\n        preventSrc: function (srcEvent) {\n            this.manager.session.prevented = true;\n            srcEvent.preventDefault();\n        }\n    };\n\n    /**\n     * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n     * @param {String} actions\n     * @returns {*}\n     */\n    function cleanTouchActions(actions) {\n        // none\n        if (inStr(actions, TOUCH_ACTION_NONE)) {\n            return TOUCH_ACTION_NONE;\n        }\n\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n        // if both pan-x and pan-y are set (different recognizers\n        // for different directions, e.g. horizontal pan but vertical swipe?)\n        // we need none (as otherwise with pan-x pan-y combined none of these\n        // recognizers will work, since the browser would handle all panning\n        if (hasPanX && hasPanY) {\n            return TOUCH_ACTION_NONE;\n        }\n\n        // pan-x OR pan-y\n        if (hasPanX || hasPanY) {\n            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n        }\n\n        // manipulation\n        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n            return TOUCH_ACTION_MANIPULATION;\n        }\n\n        return TOUCH_ACTION_AUTO;\n    }\n\n    function getTouchActionProps() {\n        if (!NATIVE_TOUCH_ACTION) {\n            return false;\n        }\n        var touchMap = {};\n        var cssSupports = window.CSS && window.CSS.supports;\n        ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n\n            // If css.supports is not supported but there is native touch-action assume it supports\n            // all values. This is the case for IE 10 and 11.\n            touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n        });\n        return touchMap;\n    }\n\n    /**\n     * Recognizer flow explained; *\n     * All recognizers have the initial state of POSSIBLE when a input session starts.\n     * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n     * Example session for mouse-input: mousedown -> mousemove -> mouseup\n     *\n     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n     * which determines with state it should be.\n     *\n     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n     * POSSIBLE to give it another change on the next cycle.\n     *\n     *               Possible\n     *                  |\n     *            +-----+---------------+\n     *            |                     |\n     *      +-----+-----+               |\n     *      |           |               |\n     *   Failed      Cancelled          |\n     *                          +-------+------+\n     *                          |              |\n     *                      Recognized       Began\n     *                                         |\n     *                                      Changed\n     *                                         |\n     *                                  Ended/Recognized\n     */\n    var STATE_POSSIBLE = 1;\n    var STATE_BEGAN = 2;\n    var STATE_CHANGED = 4;\n    var STATE_ENDED = 8;\n    var STATE_RECOGNIZED = STATE_ENDED;\n    var STATE_CANCELLED = 16;\n    var STATE_FAILED = 32;\n\n    /**\n     * Recognizer\n     * Every recognizer needs to extend from this class.\n     * @constructor\n     * @param {Object} options\n     */\n    function Recognizer(options) {\n        this.options = assign({}, this.defaults, options || {});\n\n        this.id = uniqueId();\n\n        this.manager = null;\n\n        // default is enable true\n        this.options.enable = ifUndefined(this.options.enable, true);\n\n        this.state = STATE_POSSIBLE;\n\n        this.simultaneous = {};\n        this.requireFail = [];\n    }\n\n    Recognizer.prototype = {\n        /**\n         * @virtual\n         * @type {Object}\n         */\n        defaults: {},\n\n        /**\n         * set options\n         * @param {Object} options\n         * @return {Recognizer}\n         */\n        set: function (options) {\n            assign(this.options, options);\n\n            // also update the touchAction, in case something changed about the directions/enabled state\n            this.manager && this.manager.touchAction.update();\n            return this;\n        },\n\n        /**\n         * recognize simultaneous with an other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        recognizeWith: function (otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n                return this;\n            }\n\n            var simultaneous = this.simultaneous;\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            if (!simultaneous[otherRecognizer.id]) {\n                simultaneous[otherRecognizer.id] = otherRecognizer;\n                otherRecognizer.recognizeWith(this);\n            }\n            return this;\n        },\n\n        /**\n         * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        dropRecognizeWith: function (otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n                return this;\n            }\n\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            delete this.simultaneous[otherRecognizer.id];\n            return this;\n        },\n\n        /**\n         * recognizer can only run when an other is failing\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        requireFailure: function (otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n                return this;\n            }\n\n            var requireFail = this.requireFail;\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            if (inArray(requireFail, otherRecognizer) === -1) {\n                requireFail.push(otherRecognizer);\n                otherRecognizer.requireFailure(this);\n            }\n            return this;\n        },\n\n        /**\n         * drop the requireFailure link. it does not remove the link on the other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        dropRequireFailure: function (otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n                return this;\n            }\n\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            var index = inArray(this.requireFail, otherRecognizer);\n            if (index > -1) {\n                this.requireFail.splice(index, 1);\n            }\n            return this;\n        },\n\n        /**\n         * has require failures boolean\n         * @returns {boolean}\n         */\n        hasRequireFailures: function () {\n            return this.requireFail.length > 0;\n        },\n\n        /**\n         * if the recognizer can recognize simultaneous with an other recognizer\n         * @param {Recognizer} otherRecognizer\n         * @returns {Boolean}\n         */\n        canRecognizeWith: function (otherRecognizer) {\n            return !!this.simultaneous[otherRecognizer.id];\n        },\n\n        /**\n         * You should use `tryEmit` instead of `emit` directly to check\n         * that all the needed recognizers has failed before emitting.\n         * @param {Object} input\n         */\n        emit: function (input) {\n            var self = this;\n            var state = this.state;\n\n            function emit(event) {\n                self.manager.emit(event, input);\n            }\n\n            // 'panstart' and 'panmove'\n            if (state < STATE_ENDED) {\n                emit(self.options.event + stateStr(state));\n            }\n\n            emit(self.options.event); // simple 'eventName' events\n\n            if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n                emit(input.additionalEvent);\n            }\n\n            // panend and pancancel\n            if (state >= STATE_ENDED) {\n                emit(self.options.event + stateStr(state));\n            }\n        },\n\n        /**\n         * Check that all the require failure recognizers has failed,\n         * if true, it emits a gesture event,\n         * otherwise, setup the state to FAILED.\n         * @param {Object} input\n         */\n        tryEmit: function (input) {\n            if (this.canEmit()) {\n                return this.emit(input);\n            }\n            // it's failing anyway\n            this.state = STATE_FAILED;\n        },\n\n        /**\n         * can we emit?\n         * @returns {boolean}\n         */\n        canEmit: function () {\n            var i = 0;\n            while (i < this.requireFail.length) {\n                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                    return false;\n                }\n                i++;\n            }\n            return true;\n        },\n\n        /**\n         * update the recognizer\n         * @param {Object} inputData\n         */\n        recognize: function (inputData) {\n            // make a new copy of the inputData\n            // so we can change the inputData without messing up the other recognizers\n            var inputDataClone = assign({}, inputData);\n\n            // is is enabled and allow recognizing?\n            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n                this.reset();\n                this.state = STATE_FAILED;\n                return;\n            }\n\n            // reset when we've reached the end\n            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n                this.state = STATE_POSSIBLE;\n            }\n\n            this.state = this.process(inputDataClone);\n\n            // the recognizer has recognized a gesture\n            // so trigger an event\n            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n                this.tryEmit(inputDataClone);\n            }\n        },\n\n        /**\n         * return the state of the recognizer\n         * the actual recognizing happens in this method\n         * @virtual\n         * @param {Object} inputData\n         * @returns {Const} STATE\n         */\n        process: function (inputData) {\n        }, // jshint ignore:line\n\n        /**\n         * return the preferred touch-action\n         * @virtual\n         * @returns {Array}\n         */\n        getTouchAction: function () {\n        },\n\n        /**\n         * called when the gesture isn't allowed to recognize\n         * like when another is being recognized or it is disabled\n         * @virtual\n         */\n        reset: function () {\n        }\n    };\n\n    /**\n     * get a usable string, used as event postfix\n     * @param {Const} state\n     * @returns {String} state\n     */\n    function stateStr(state) {\n        if (state & STATE_CANCELLED) {\n            return 'cancel';\n        } else if (state & STATE_ENDED) {\n            return 'end';\n        } else if (state & STATE_CHANGED) {\n            return 'move';\n        } else if (state & STATE_BEGAN) {\n            return 'start';\n        }\n        return '';\n    }\n\n    /**\n     * direction cons to string\n     * @param {Const} direction\n     * @returns {String}\n     */\n    function directionStr(direction) {\n        if (direction == DIRECTION_DOWN) {\n            return 'down';\n        } else if (direction == DIRECTION_UP) {\n            return 'up';\n        } else if (direction == DIRECTION_LEFT) {\n            return 'left';\n        } else if (direction == DIRECTION_RIGHT) {\n            return 'right';\n        }\n        return '';\n    }\n\n    /**\n     * get a recognizer by name if it is bound to a manager\n     * @param {Recognizer|String} otherRecognizer\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer}\n     */\n    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n        var manager = recognizer.manager;\n        if (manager) {\n            return manager.get(otherRecognizer);\n        }\n        return otherRecognizer;\n    }\n\n    /**\n     * This recognizer is just used as a base for the simple attribute recognizers.\n     * @constructor\n     * @extends Recognizer\n     */\n    function AttrRecognizer() {\n        Recognizer.apply(this, arguments);\n    }\n\n    inherit(AttrRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof AttrRecognizer\n         */\n        defaults: {\n            /**\n             * @type {Number}\n             * @default 1\n             */\n            pointers: 1\n        },\n\n        /**\n         * Used to check if it the recognizer receives valid input, like input.distance > 10.\n         * @memberof AttrRecognizer\n         * @param {Object} input\n         * @returns {Boolean} recognized\n         */\n        attrTest: function (input) {\n            var optionPointers = this.options.pointers;\n            return optionPointers === 0 || input.pointers.length === optionPointers;\n        },\n\n        /**\n         * Process the input and return the state for the recognizer\n         * @memberof AttrRecognizer\n         * @param {Object} input\n         * @returns {*} State\n         */\n        process: function (input) {\n            var state = this.state;\n            var eventType = input.eventType;\n\n            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n            var isValid = this.attrTest(input);\n\n            // on cancel input and we've recognized before, return STATE_CANCELLED\n            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n                return state | STATE_CANCELLED;\n            } else if (isRecognized || isValid) {\n                if (eventType & INPUT_END) {\n                    return state | STATE_ENDED;\n                } else if (!(state & STATE_BEGAN)) {\n                    return STATE_BEGAN;\n                }\n                return state | STATE_CHANGED;\n            }\n            return STATE_FAILED;\n        }\n    });\n\n    /**\n     * Pan\n     * Recognized when the pointer is down and moved in the allowed direction.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function PanRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n\n        this.pX = null;\n        this.pY = null;\n    }\n\n    inherit(PanRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof PanRecognizer\n         */\n        defaults: {\n            event: 'pan',\n            threshold: 10,\n            pointers: 1,\n            direction: DIRECTION_ALL\n        },\n\n        getTouchAction: function () {\n            var direction = this.options.direction;\n            var actions = [];\n            if (direction & DIRECTION_HORIZONTAL) {\n                actions.push(TOUCH_ACTION_PAN_Y);\n            }\n            if (direction & DIRECTION_VERTICAL) {\n                actions.push(TOUCH_ACTION_PAN_X);\n            }\n            return actions;\n        },\n\n        directionTest: function (input) {\n            var options = this.options;\n            var hasMoved = true;\n            var distance = input.distance;\n            var direction = input.direction;\n            var x = input.deltaX;\n            var y = input.deltaY;\n\n            // lock to axis?\n            if (!(direction & options.direction)) {\n                if (options.direction & DIRECTION_HORIZONTAL) {\n                    direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                    hasMoved = x != this.pX;\n                    distance = Math.abs(input.deltaX);\n                } else {\n                    direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                    hasMoved = y != this.pY;\n                    distance = Math.abs(input.deltaY);\n                }\n            }\n            input.direction = direction;\n            return hasMoved && distance > options.threshold && direction & options.direction;\n        },\n\n        attrTest: function (input) {\n            return AttrRecognizer.prototype.attrTest.call(this, input) &&\n                (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n        },\n\n        emit: function (input) {\n\n            this.pX = input.deltaX;\n            this.pY = input.deltaY;\n\n            var direction = directionStr(input.direction);\n\n            if (direction) {\n                input.additionalEvent = this.options.event + direction;\n            }\n            this._super.emit.call(this, input);\n        }\n    });\n\n    /**\n     * Pinch\n     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function PinchRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(PinchRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof PinchRecognizer\n         */\n        defaults: {\n            event: 'pinch',\n            threshold: 0,\n            pointers: 2\n        },\n\n        getTouchAction: function () {\n            return [TOUCH_ACTION_NONE];\n        },\n\n        attrTest: function (input) {\n            return this._super.attrTest.call(this, input) &&\n                (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n        },\n\n        emit: function (input) {\n            if (input.scale !== 1) {\n                var inOut = input.scale < 1 ? 'in' : 'out';\n                input.additionalEvent = this.options.event + inOut;\n            }\n            this._super.emit.call(this, input);\n        }\n    });\n\n    /**\n     * Press\n     * Recognized when the pointer is down for x ms without any movement.\n     * @constructor\n     * @extends Recognizer\n     */\n    function PressRecognizer() {\n        Recognizer.apply(this, arguments);\n\n        this._timer = null;\n        this._input = null;\n    }\n\n    inherit(PressRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof PressRecognizer\n         */\n        defaults: {\n            event: 'press',\n            pointers: 1,\n            time: 251, // minimal time of the pointer to be pressed\n            threshold: 9 // a minimal movement is ok, but keep it low\n        },\n\n        getTouchAction: function () {\n            return [TOUCH_ACTION_AUTO];\n        },\n\n        process: function (input) {\n            var options = this.options;\n            var validPointers = input.pointers.length === options.pointers;\n            var validMovement = input.distance < options.threshold;\n            var validTime = input.deltaTime > options.time;\n\n            this._input = input;\n\n            // we only allow little movement\n            // and we've reached an end event, so a tap is possible\n            if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n                this.reset();\n            } else if (input.eventType & INPUT_START) {\n                this.reset();\n                this._timer = setTimeoutContext(function () {\n                    this.state = STATE_RECOGNIZED;\n                    this.tryEmit();\n                }, options.time, this);\n            } else if (input.eventType & INPUT_END) {\n                return STATE_RECOGNIZED;\n            }\n            return STATE_FAILED;\n        },\n\n        reset: function () {\n            clearTimeout(this._timer);\n        },\n\n        emit: function (input) {\n            if (this.state !== STATE_RECOGNIZED) {\n                return;\n            }\n\n            if (input && (input.eventType & INPUT_END)) {\n                this.manager.emit(this.options.event + 'up', input);\n            } else {\n                this._input.timeStamp = now();\n                this.manager.emit(this.options.event, this._input);\n            }\n        }\n    });\n\n    /**\n     * Rotate\n     * Recognized when two or more pointer are moving in a circular motion.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function RotateRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(RotateRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof RotateRecognizer\n         */\n        defaults: {\n            event: 'rotate',\n            threshold: 0,\n            pointers: 2\n        },\n\n        getTouchAction: function () {\n            return [TOUCH_ACTION_NONE];\n        },\n\n        attrTest: function (input) {\n            return this._super.attrTest.call(this, input) &&\n                (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n        }\n    });\n\n    /**\n     * Swipe\n     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function SwipeRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(SwipeRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof SwipeRecognizer\n         */\n        defaults: {\n            event: 'swipe',\n            threshold: 10,\n            velocity: 0.3,\n            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n            pointers: 1\n        },\n\n        getTouchAction: function () {\n            return PanRecognizer.prototype.getTouchAction.call(this);\n        },\n\n        attrTest: function (input) {\n            var direction = this.options.direction;\n            var velocity;\n\n            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n                velocity = input.overallVelocity;\n            } else if (direction & DIRECTION_HORIZONTAL) {\n                velocity = input.overallVelocityX;\n            } else if (direction & DIRECTION_VERTICAL) {\n                velocity = input.overallVelocityY;\n            }\n\n            return this._super.attrTest.call(this, input) &&\n                direction & input.offsetDirection &&\n                input.distance > this.options.threshold &&\n                input.maxPointers == this.options.pointers &&\n                abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n        },\n\n        emit: function (input) {\n            var direction = directionStr(input.offsetDirection);\n            if (direction) {\n                this.manager.emit(this.options.event + direction, input);\n            }\n\n            this.manager.emit(this.options.event, input);\n        }\n    });\n\n    /**\n     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n     * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n     * a single tap.\n     *\n     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n     * multi-taps being recognized.\n     * @constructor\n     * @extends Recognizer\n     */\n    function TapRecognizer() {\n        Recognizer.apply(this, arguments);\n\n        // previous time and center,\n        // used for tap counting\n        this.pTime = false;\n        this.pCenter = false;\n\n        this._timer = null;\n        this._input = null;\n        this.count = 0;\n    }\n\n    inherit(TapRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof PinchRecognizer\n         */\n        defaults: {\n            event: 'tap',\n            pointers: 1,\n            taps: 1,\n            interval: 300, // max time between the multi-tap taps\n            time: 250, // max time of the pointer to be down (like finger on the screen)\n            threshold: 9, // a minimal movement is ok, but keep it low\n            posThreshold: 10 // a multi-tap can be a bit off the initial position\n        },\n\n        getTouchAction: function () {\n            return [TOUCH_ACTION_MANIPULATION];\n        },\n\n        process: function (input) {\n            var options = this.options;\n\n            var validPointers = input.pointers.length === options.pointers;\n            var validMovement = input.distance < options.threshold;\n            var validTouchTime = input.deltaTime < options.time;\n\n            this.reset();\n\n            if ((input.eventType & INPUT_START) && (this.count === 0)) {\n                return this.failTimeout();\n            }\n\n            // we only allow little movement\n            // and we've reached an end event, so a tap is possible\n            if (validMovement && validTouchTime && validPointers) {\n                if (input.eventType != INPUT_END) {\n                    return this.failTimeout();\n                }\n\n                var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n                this.pTime = input.timeStamp;\n                this.pCenter = input.center;\n\n                if (!validMultiTap || !validInterval) {\n                    this.count = 1;\n                } else {\n                    this.count += 1;\n                }\n\n                this._input = input;\n\n                // if tap count matches we have recognized it,\n                // else it has began recognizing...\n                var tapCount = this.count % options.taps;\n                if (tapCount === 0) {\n                    // no failing requirements, immediately trigger the tap event\n                    // or wait as long as the multitap interval to trigger\n                    if (!this.hasRequireFailures()) {\n                        return STATE_RECOGNIZED;\n                    } else {\n                        this._timer = setTimeoutContext(function () {\n                            this.state = STATE_RECOGNIZED;\n                            this.tryEmit();\n                        }, options.interval, this);\n                        return STATE_BEGAN;\n                    }\n                }\n            }\n            return STATE_FAILED;\n        },\n\n        failTimeout: function () {\n            this._timer = setTimeoutContext(function () {\n                this.state = STATE_FAILED;\n            }, this.options.interval, this);\n            return STATE_FAILED;\n        },\n\n        reset: function () {\n            clearTimeout(this._timer);\n        },\n\n        emit: function () {\n            if (this.state == STATE_RECOGNIZED) {\n                this._input.tapCount = this.count;\n                this.manager.emit(this.options.event, this._input);\n            }\n        }\n    });\n\n    /**\n     * Simple way to create a manager with a default set of recognizers.\n     * @param {HTMLElement} element\n     * @param {Object} [options]\n     * @constructor\n     */\n    function Hammer(element, options) {\n        options = options || {};\n        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n        return new Manager(element, options);\n    }\n\n    /**\n     * @const {string}\n     */\n    Hammer.VERSION = '2.0.8';\n\n    /**\n     * default settings\n     * @namespace\n     */\n    Hammer.defaults = {\n        /**\n         * set if DOM events are being triggered.\n         * But this is slower and unused by simple implementations, so disabled by default.\n         * @type {Boolean}\n         * @default false\n         */\n        domEvents: false,\n\n        /**\n         * The value for the touchAction property/fallback.\n         * When set to `compute` it will magically set the correct value based on the added recognizers.\n         * @type {String}\n         * @default compute\n         */\n        touchAction: TOUCH_ACTION_COMPUTE,\n\n        /**\n         * @type {Boolean}\n         * @default true\n         */\n        enable: true,\n\n        /**\n         * EXPERIMENTAL FEATURE -- can be removed/changed\n         * Change the parent input target element.\n         * If Null, then it is being set the to main element.\n         * @type {Null|EventTarget}\n         * @default null\n         */\n        inputTarget: null,\n\n        /**\n         * force an input class\n         * @type {Null|Function}\n         * @default null\n         */\n        inputClass: null,\n\n        /**\n         * Default recognizer setup when calling `Hammer()`\n         * When creating a new Manager these will be skipped.\n         * @type {Array}\n         */\n        preset: [\n            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n            [RotateRecognizer, {enable: false}],\n            [PinchRecognizer, {enable: false}, ['rotate']],\n            [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n            [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n            [TapRecognizer],\n            [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n            [PressRecognizer]\n        ],\n\n        /**\n         * Some CSS properties can be used to improve the working of Hammer.\n         * Add them to this method and they will be set when creating a new Manager.\n         * @namespace\n         */\n        cssProps: {\n            /**\n             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n             * @type {String}\n             * @default 'none'\n             */\n            userSelect: 'none',\n\n            /**\n             * Disable the Windows Phone grippers when pressing an element.\n             * @type {String}\n             * @default 'none'\n             */\n            touchSelect: 'none',\n\n            /**\n             * Disables the default callout shown when you touch and hold a touch target.\n             * On iOS, when you touch and hold a touch target such as a link, Safari displays\n             * a callout containing information about the link. This property allows you to disable that callout.\n             * @type {String}\n             * @default 'none'\n             */\n            touchCallout: 'none',\n\n            /**\n             * Specifies whether zooming is enabled. Used by IE10>\n             * @type {String}\n             * @default 'none'\n             */\n            contentZooming: 'none',\n\n            /**\n             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n             * @type {String}\n             * @default 'none'\n             */\n            userDrag: 'none',\n\n            /**\n             * Overrides the highlight color shown when the user taps a link or a JavaScript\n             * clickable element in iOS. This property obeys the alpha value, if specified.\n             * @type {String}\n             * @default 'rgba(0,0,0,0)'\n             */\n            tapHighlightColor: 'rgba(0,0,0,0)'\n        }\n    };\n\n    var STOP = 1;\n    var FORCED_STOP = 2;\n\n    /**\n     * Manager\n     * @param {HTMLElement} element\n     * @param {Object} [options]\n     * @constructor\n     */\n    function Manager(element, options) {\n        this.options = assign({}, Hammer.defaults, options || {});\n\n        this.options.inputTarget = this.options.inputTarget || element;\n\n        this.handlers = {};\n        this.session = {};\n        this.recognizers = [];\n        this.oldCssProps = {};\n\n        this.element = element;\n        this.input = createInputInstance(this);\n        this.touchAction = new TouchAction(this, this.options.touchAction);\n\n        toggleCssProps(this, true);\n\n        each(this.options.recognizers, function (item) {\n            var recognizer = this.add(new (item[0])(item[1]));\n            item[2] && recognizer.recognizeWith(item[2]);\n            item[3] && recognizer.requireFailure(item[3]);\n        }, this);\n    }\n\n    Manager.prototype = {\n        /**\n         * set options\n         * @param {Object} options\n         * @returns {Manager}\n         */\n        set: function (options) {\n            assign(this.options, options);\n\n            // Options that need a little more setup\n            if (options.touchAction) {\n                this.touchAction.update();\n            }\n            if (options.inputTarget) {\n                // Clean up existing event listeners and reinitialize\n                this.input.destroy();\n                this.input.target = options.inputTarget;\n                this.input.init();\n            }\n            return this;\n        },\n\n        /**\n         * stop recognizing for this session.\n         * This session will be discarded, when a new [input]start event is fired.\n         * When forced, the recognizer cycle is stopped immediately.\n         * @param {Boolean} [force]\n         */\n        stop: function (force) {\n            this.session.stopped = force ? FORCED_STOP : STOP;\n        },\n\n        /**\n         * run the recognizers!\n         * called by the inputHandler function on every movement of the pointers (touches)\n         * it walks through all the recognizers and tries to detect the gesture that is being made\n         * @param {Object} inputData\n         */\n        recognize: function (inputData) {\n            var session = this.session;\n            if (session.stopped) {\n                return;\n            }\n\n            // run the touch-action polyfill\n            this.touchAction.preventDefaults(inputData);\n\n            var recognizer;\n            var recognizers = this.recognizers;\n\n            // this holds the recognizer that is being recognized.\n            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n            // if no recognizer is detecting a thing, it is set to `null`\n            var curRecognizer = session.curRecognizer;\n\n            // reset when the last recognizer is recognized\n            // or when we're in a new session\n            if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n                curRecognizer = session.curRecognizer = null;\n            }\n\n            var i = 0;\n            while (i < recognizers.length) {\n                recognizer = recognizers[i];\n\n                // find out if we are allowed try to recognize the input for this one.\n                // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n                //      that is being recognized.\n                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n                //      this can be setup with the `recognizeWith()` method on the recognizer.\n                if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                    recognizer.recognize(inputData);\n                } else {\n                    recognizer.reset();\n                }\n\n                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n                // current active recognizer. but only if we don't already have an active recognizer\n                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                    curRecognizer = session.curRecognizer = recognizer;\n                }\n                i++;\n            }\n        },\n\n        /**\n         * get a recognizer by its event name.\n         * @param {Recognizer|String} recognizer\n         * @returns {Recognizer|Null}\n         */\n        get: function (recognizer) {\n            if (recognizer instanceof Recognizer) {\n                return recognizer;\n            }\n\n            var recognizers = this.recognizers;\n            for (var i = 0; i < recognizers.length; i++) {\n                if (recognizers[i].options.event == recognizer) {\n                    return recognizers[i];\n                }\n            }\n            return null;\n        },\n\n        /**\n         * add a recognizer to the manager\n         * existing recognizers with the same event name will be removed\n         * @param {Recognizer} recognizer\n         * @returns {Recognizer|Manager}\n         */\n        add: function (recognizer) {\n            if (invokeArrayArg(recognizer, 'add', this)) {\n                return this;\n            }\n\n            // remove existing\n            var existing = this.get(recognizer.options.event);\n            if (existing) {\n                this.remove(existing);\n            }\n\n            this.recognizers.push(recognizer);\n            recognizer.manager = this;\n\n            this.touchAction.update();\n            return recognizer;\n        },\n\n        /**\n         * remove a recognizer by name or instance\n         * @param {Recognizer|String} recognizer\n         * @returns {Manager}\n         */\n        remove: function (recognizer) {\n            if (invokeArrayArg(recognizer, 'remove', this)) {\n                return this;\n            }\n\n            recognizer = this.get(recognizer);\n\n            // let's make sure this recognizer exists\n            if (recognizer) {\n                var recognizers = this.recognizers;\n                var index = inArray(recognizers, recognizer);\n\n                if (index !== -1) {\n                    recognizers.splice(index, 1);\n                    this.touchAction.update();\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * bind event\n         * @param {String} events\n         * @param {Function} handler\n         * @returns {EventEmitter} this\n         */\n        on: function (events, handler) {\n            if (events === undefined) {\n                return;\n            }\n            if (handler === undefined) {\n                return;\n            }\n\n            var handlers = this.handlers;\n            each(splitStr(events), function (event) {\n                handlers[event] = handlers[event] || [];\n                handlers[event].push(handler);\n            });\n            return this;\n        },\n\n        /**\n         * unbind event, leave emit blank to remove all handlers\n         * @param {String} events\n         * @param {Function} [handler]\n         * @returns {EventEmitter} this\n         */\n        off: function (events, handler) {\n            if (events === undefined) {\n                return;\n            }\n\n            var handlers = this.handlers;\n            each(splitStr(events), function (event) {\n                if (!handler) {\n                    delete handlers[event];\n                } else {\n                    handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n                }\n            });\n            return this;\n        },\n\n        /**\n         * emit event to the listeners\n         * @param {String} event\n         * @param {Object} data\n         */\n        emit: function (event, data) {\n            // we also want to trigger dom events\n            if (this.options.domEvents) {\n                triggerDomEvent(event, data);\n            }\n\n            // no handlers, so skip it all\n            var handlers = this.handlers[event] && this.handlers[event].slice();\n            if (!handlers || !handlers.length) {\n                return;\n            }\n\n            data.type = event;\n            data.preventDefault = function () {\n                data.srcEvent.preventDefault();\n            };\n\n            var i = 0;\n            while (i < handlers.length) {\n                handlers[i](data);\n                i++;\n            }\n        },\n\n        /**\n         * destroy the manager and unbinds all events\n         * it doesn't unbind dom events, that is the user own responsibility\n         */\n        destroy: function () {\n            this.element && toggleCssProps(this, false);\n\n            this.handlers = {};\n            this.session = {};\n            this.input.destroy();\n            this.element = null;\n        }\n    };\n\n    /**\n     * add/remove the css properties as defined in manager.options.cssProps\n     * @param {Manager} manager\n     * @param {Boolean} add\n     */\n    function toggleCssProps(manager, add) {\n        var element = manager.element;\n        if (!element.style) {\n            return;\n        }\n        var prop;\n        each(manager.options.cssProps, function (value, name) {\n            prop = prefixed(element.style, name);\n            if (add) {\n                manager.oldCssProps[prop] = element.style[prop];\n                element.style[prop] = value;\n            } else {\n                element.style[prop] = manager.oldCssProps[prop] || '';\n            }\n        });\n        if (!add) {\n            manager.oldCssProps = {};\n        }\n    }\n\n    /**\n     * trigger dom event\n     * @param {String} event\n     * @param {Object} data\n     */\n    function triggerDomEvent(event, data) {\n        var gestureEvent = document.createEvent('Event');\n        gestureEvent.initEvent(event, true, true);\n        gestureEvent.gesture = data;\n        data.target.dispatchEvent(gestureEvent);\n    }\n\n    assign(Hammer, {\n        INPUT_START: INPUT_START,\n        INPUT_MOVE: INPUT_MOVE,\n        INPUT_END: INPUT_END,\n        INPUT_CANCEL: INPUT_CANCEL,\n\n        STATE_POSSIBLE: STATE_POSSIBLE,\n        STATE_BEGAN: STATE_BEGAN,\n        STATE_CHANGED: STATE_CHANGED,\n        STATE_ENDED: STATE_ENDED,\n        STATE_RECOGNIZED: STATE_RECOGNIZED,\n        STATE_CANCELLED: STATE_CANCELLED,\n        STATE_FAILED: STATE_FAILED,\n\n        DIRECTION_NONE: DIRECTION_NONE,\n        DIRECTION_LEFT: DIRECTION_LEFT,\n        DIRECTION_RIGHT: DIRECTION_RIGHT,\n        DIRECTION_UP: DIRECTION_UP,\n        DIRECTION_DOWN: DIRECTION_DOWN,\n        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n        DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n        DIRECTION_ALL: DIRECTION_ALL,\n\n        Manager: Manager,\n        Input: Input,\n        TouchAction: TouchAction,\n\n        TouchInput: TouchInput,\n        MouseInput: MouseInput,\n        PointerEventInput: PointerEventInput,\n        TouchMouseInput: TouchMouseInput,\n        SingleTouchInput: SingleTouchInput,\n\n        Recognizer: Recognizer,\n        AttrRecognizer: AttrRecognizer,\n        Tap: TapRecognizer,\n        Pan: PanRecognizer,\n        Swipe: SwipeRecognizer,\n        Pinch: PinchRecognizer,\n        Rotate: RotateRecognizer,\n        Press: PressRecognizer,\n\n        on: addEventListeners,\n        off: removeEventListeners,\n        each: each,\n        merge: merge,\n        extend: extend,\n        assign: assign,\n        inherit: inherit,\n        bindFn: bindFn,\n        prefixed: prefixed\n    });\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\n    var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\n    freeGlobal.Hammer = Hammer;\n\n    if (typeof define === 'function' && define.amd) {\n        define(function () {\n            return Hammer;\n        });\n    } else if (typeof module != 'undefined' && module.exports) {\n        module.exports = Hammer;\n    } else {\n        window[exportName] = Hammer;\n    }\n})(window, document, 'Hammer');\n\nexport default window.Hammer;\n\n\n// WEBPACK FOOTER //\n// ./src/lib/hammer.js","let transformProp = (function getTransformProperty() {\n    let props = ['transform', 'webkitTransform', 'MozTransform', 'oTransform', 'msTransform'];\n    let style = document.createElement('div').style, availProp = '';\n    props.forEach(function (prop) {\n        if (style[prop] !== undefined) {\n            availProp = prop;\n        }\n    });\n    return availProp;\n})();\n\nfunction query(selector, el) {\n    el = el || document;\n    return el.querySelectorAll(selector);\n}\n\nfunction removeElement(element) {\n    let parentElement = element.parentNode;\n    if (parentElement) {\n        parentElement.removeChild(element);\n    }\n}\n\nfunction setTranslateStyle(el, x, y) {\n    el.style[transformProp] = `translate3d(${x + 'px'},${y + 'px'},0)`;\n}\n\nfunction setScaleAndTranslateStyle(el, scale, x, y) {\n    el.style[transformProp] = `scale3d(${scale},${scale},1) translate3d(${x + 'px'},${y + 'px'},0)`;\n}\n\nexport {\n    query,\n    removeElement,\n    setTranslateStyle,\n    setScaleAndTranslateStyle\n};\n\n\n// WEBPACK FOOTER //\n// ./src/common/dom.js","let debug = (msg) => {\n    window.console.log('[ImageViewer]:' + msg);\n};\n\nexport {\n    debug\n};\n\n\n// WEBPACK FOOTER //\n// ./src/common/debug.js","const ITEM_ANIMATION_CLASS = 'viewer-animation';\nconst LOCK_NAME = 'STOP_SWIPE';\n\nexport {\n    LOCK_NAME,\n    ITEM_ANIMATION_CLASS\n};\n\n\n// WEBPACK FOOTER //\n// ./src/common/profile.js","class Lock {\n    constructor() {\n        this._locks = {};\n    }\n\n    createLock(name) {\n        this._locks[name] = false;\n    }\n\n    deleteLock(name) {\n        delete this._locks[name];\n    }\n\n    getLock(name) {\n        this._locks[name] = true;\n    }\n\n    releaseLock(name) {\n        this._locks[name] = false;\n    }\n\n    getLockState(name) {\n        return this._locks[name];\n    }\n}\n\nexport default new Lock();\n\n\n// WEBPACK FOOTER //\n// ./src/common/lock.js","class Event {\n    /**\n     * 构造器\n     * @param _enableMultiple 标记该事件实例是否允许同一事件挂载多个处理函数\n     */\n    constructor(_enableMultiple = true) {\n        this._enableMultiple = _enableMultiple;\n        this._handlers = {};\n    }\n\n    /**\n     * 绑定事件处理函数\n     * @param name 事件名字\n     * @param handler 对应的事件处理函数\n     * @param enableMultiple 标记该事件是否允许挂载多个处理函数\n     */\n    on(name, handler, enableMultiple) {\n        enableMultiple = enableMultiple === undefined ? this._enableMultiple : enableMultiple;\n        if (enableMultiple) {\n            if (!this._handlers[name]) {\n                this._handlers[name] = [];\n            }\n            this._handlers[name].push(handler);\n        } else {\n            this._handlers[name] = [handler];\n        }\n    }\n\n    /**\n     * 销毁对应的处理函数\n     * @param name 事件名\n     */\n    off(name) {\n        delete this._handlers[name];\n    }\n\n    /**\n     * 触发事件\n     * @param name 事件名\n     * @param args 参数数组，传递给各个事件处理函数\n     */\n    emit(name, ...args) {\n        let handlers = this._handlers[name] || [], event = {stop: false}, length = handlers.length;\n        //传递给事件处理函数的第一个参数为事件对象\n        //该对象拥有一些可能会有用的属性和函数（比如可以终止处理函数链的执行exit）\n        args = args.concat([{\n            name: name,//事件名\n            length: length,//事件处理函数的数量\n            /**\n             * 阻止继续执行函数处理链并退出\n             */\n            exit() {\n                event.stop = true;\n            }\n        }]);\n        if (length) {\n            //仅当存在处理函数时才执行\n            handlers.forEach((handler) => {\n                !event.stop && handler.apply(this, args);\n            });\n        }\n    }\n}\n\nexport default Event;\n\n\n// WEBPACK FOOTER //\n// ./src/common/event.js","import {\n    query,\n    setTranslateStyle,\n    setScaleAndTranslateStyle\n} from '../common/dom';\nimport {\n    ITEM_ANIMATION_CLASS,\n    LOCK_NAME\n} from '../common/profile';\nimport lock from '../common/lock';\nimport Event from '../common/event';\nimport Hammer from '../lib/hammer';\n\nclass Viewer {\n    constructor(imageViewer, el, width, height, index) {\n        this.event = new Event(false);\n        this.imageViewer = imageViewer;\n        this.el = el;             //.viewer类\n        this.panelEl = el.firstElementChild;//.panel类\n        this.imageEl = query('img', this.el)[0];\n        this.src = '';\n        this.index = index;        //viewer排序用，记录原始的数组位置\n        this.displayIndex = 0;\n        this.width = width;\n        this.height = height;\n        this.realWidth = 0;\n        this.realHeight = 0;\n        this.translateX = 0;\n        this.translateY = 0;\n        this.scale = 1;            //缩放比例\n        this.currentScale = 1;     //当前正在缩放的倍数(临时保存,当事件结束后,会赋值回scale)\n        this.translatePanelX = 0;  //最终图片面板所在的X轴坐标\n        this.translatePanelY = 0;  //最终图片面板所在的Y轴坐标\n        this.currentPanelX = 0;    //当前图片面板所在的X轴坐标（手指尚未离开屏幕）\n        this.currentPanelY = 0;    //当前图片面板所在的Y轴坐标（手指尚未离开屏幕）\n        this.allowDistanceX = 0;   //图片放大后，允许拖动的最大X轴距离\n        this.allowDistanceY = 0;   //图片放大后，允许拖动的最大Y轴距离\n        this.needResetX = false;   //拖动图片超出边界时，需要重置一下x轴的坐标\n        this.needResetY = false;   //拖动图片超出边界时，需要重置一下y轴的坐标\n        this.deltaX = 0;           //存储起始的X轴偏移量\n        this.deltaY = 0;           //存储起始的Y轴偏移量\n        this.EVENT_NAME = 'IMG_LOAD_COMPLETE';\n        this._bindEvent();\n    }\n\n    init(displayIndex = 0, resetScale, fn, needLoad = true, src) {\n        const _initImage = () => {\n            if (resetScale) {\n                this.scale = 1;\n                this.allowDistanceX = this.allowDistanceY = 0;\n            }\n            if (needLoad) {\n                this.imageEl.style.display = '';\n            }\n            this.translatePanelX = 0;\n            this.translatePanelY = 0;\n            this.currentPanelX = 0;\n            this.currentPanelY = 0;\n            this.realWidth = this.panelEl.clientWidth * this.scale;\n            this.realHeight = this.panelEl.clientHeight * this.scale;\n            this.translateX = this.displayIndex * this.width;\n            this.translateY = -this.el.clientHeight / 2;\n            this.needResetX = this.needResetY = false;\n            setScaleAndTranslateStyle(this.panelEl, this.scale, this.translatePanelX, this.translatePanelY);\n            setTranslateStyle(this.el, this.translateX, this.translateY);\n            fn && fn.apply(this);\n        };\n        this.displayIndex = displayIndex;\n\n        if (needLoad) {\n            this.src = src;\n            this.imageEl.src = this.src;\n            this.imageEl.style.display = 'none';\n            this.event.on(this.EVENT_NAME, () => {\n                _initImage();\n            });\n            setTranslateStyle(this.el, this.displayIndex * this.width, this.translateY);\n        } else {\n            _initImage();\n        }\n        return this;\n    }\n\n    _bindEvent() {\n        let mc = new Hammer.Manager(this.panelEl);\n        mc.add(new Hammer.Pan());\n        mc.on('panstart', (event) => {\n            this.removeAnimation();\n            if (lock.getLockState(LOCK_NAME)) {\n                this.deltaX = event.deltaX;\n                this.deltaY = event.deltaY;\n            }\n        });\n        mc.on('panmove', (event) => {\n            if (lock.getLockState(LOCK_NAME)) {\n                event.preventDefault();\n                this._translatePanel(event.deltaX - this.deltaX, event.deltaY - this.deltaY);\n            }\n        });\n        mc.on('panend', (event) => {\n            if (lock.getLockState(LOCK_NAME)) {\n                this._translatePanelEnd(event.deltaX - this.deltaX);\n            }\n        });\n\n        this.imageEl.addEventListener('load', () => {\n            this.event.emit(this.EVENT_NAME);\n        }, false);\n    }\n\n    _pinchStart() {\n        this.removeAnimation();\n        this.panelEl.style.willChange = 'transform';\n    }\n\n    _pinch(scale) {\n        let currentScale = scale * this.scale + this.scale;\n        if (currentScale > 0.5 && currentScale < 8) {\n            this.currentScale = currentScale;\n            setScaleAndTranslateStyle(this.panelEl, this.currentScale, this.translatePanelX, this.translatePanelY);\n        }\n        return this;\n    }\n\n    _pinchEnd(scale) {\n        this.scale = isNaN(scale) ? this.currentScale : scale;\n        this.realWidth = this.panelEl.clientWidth * this.scale;\n        this.realHeight = this.panelEl.clientHeight * this.scale;\n        this.allowDistanceX = (this.realWidth - this.width) / 2 / this.scale + 2;\n        this.allowDistanceY = (this.realHeight - this.height) / 2 / this.scale + 2;\n        if (this.realWidth < this.width || this.realHeight < this.height) {\n            this.init(this.displayIndex, false, null, false);\n        }\n        if (this.isScale()) {\n            lock.getLock(LOCK_NAME);\n        } else {\n            lock.releaseLock(LOCK_NAME);\n        }\n        this.panelEl.style.willChange = 'auto';\n        return this;\n    }\n\n    _calculate(a, b) {\n        return a > 0 ? (a - b) : (a + b);\n    }\n\n    _translatePanel(translatePanelX, translatePanelY) {\n        let tempX = 0;\n        if (this.realWidth <= this.width && translatePanelX) {\n            this.imageViewer._dealWithMoveAction({deltaX: translatePanelX}, true);\n        } else {\n            if (this.allowDistanceX > 0 && translatePanelX) {\n                this.currentPanelX = translatePanelX / this.scale + this.translatePanelX;\n                this.needResetX = !(-this.allowDistanceX < this.currentPanelX && this.currentPanelX < this.allowDistanceX);\n            }\n\n            if (this.needResetX) {\n                this.imageViewer._dealWithMoveAction({deltaX: this._calculate(this.currentPanelX, this.allowDistanceX)}, true);\n                tempX = this.currentPanelX > 0 ? this.allowDistanceX : -this.allowDistanceX;\n            } else {\n                this.imageViewer._dealWithMoveAction({deltaX: 0}, true);\n                tempX = this.currentPanelX;\n            }\n        }\n        if (this.allowDistanceY > 0 && translatePanelY) {\n            this.currentPanelY = translatePanelY / this.scale + this.translatePanelY;\n            this.needResetY = !(-this.allowDistanceY < this.currentPanelY && this.currentPanelY < this.allowDistanceY);\n        }\n        setScaleAndTranslateStyle(this.panelEl, this.scale, tempX, this.currentPanelY);\n        return this;\n    }\n\n    _translatePanelEnd(translatePanelX) {\n        let needSwipe = false;\n        if (this.realWidth <= this.width && translatePanelX) {\n            needSwipe = this.imageViewer._dealWithMoveActionEnd({deltaX: translatePanelX}, true);\n        } else if (this.needResetX) {\n            needSwipe = this.imageViewer._dealWithMoveActionEnd({deltaX: this._calculate(this.currentPanelX, this.allowDistanceX)}, true);\n        }\n        if (needSwipe) {\n            //滑动到下一张，重置当前图片的尺寸\n            this.init(this.displayIndex, true, null, false);\n            setTimeout(() => {\n                lock.releaseLock(LOCK_NAME);\n            }, 0);\n        } else {\n            if (this.needResetX) {\n                this.translatePanelX = this.currentPanelX > 0 ? this.allowDistanceX : -this.allowDistanceX;\n            } else {\n                this.translatePanelX = this.currentPanelX;\n            }\n            if (this.needResetY) {\n                this.translatePanelY = this.currentPanelY > 0 ? this.allowDistanceY : -this.allowDistanceY;\n            } else {\n                this.translatePanelY = this.currentPanelY;\n            }\n            if (this.needResetX || this.needResetY) {\n                this.addAnimation();\n                setScaleAndTranslateStyle(this.panelEl, this.scale, this.translatePanelX, this.translatePanelY);\n            }\n            this.needResetX = this.needResetY = false;\n        }\n        return this;\n    }\n\n    isScale() {\n        return Math.abs(this.scale - 1) > 0.01;\n    }\n\n    addAnimation() {\n        this.panelEl.classList.add(ITEM_ANIMATION_CLASS);\n        this.el.classList.add(ITEM_ANIMATION_CLASS);\n    }\n\n    removeAnimation() {\n        this.panelEl.classList.remove(ITEM_ANIMATION_CLASS);\n        this.el.classList.remove(ITEM_ANIMATION_CLASS);\n    }\n}\n\nexport default Viewer;\n\n\n// WEBPACK FOOTER //\n// ./src/core/viewer.js","import {\n    debug\n} from '../common/debug';\nimport {\n    query,\n    removeElement,\n    setTranslateStyle\n} from '../common/dom';\nimport {\n    LOCK_NAME,\n    ITEM_ANIMATION_CLASS\n} from '../common/profile';\nimport lock from '../common/lock';\nimport Hammer from '../lib/hammer';\nimport Viewer from './viewer';\n\nclass ImageViewer {\n    constructor(images = [], opt = {}) {\n        this.opt = opt;\n        this.el = null;\n        this.headerEl = null;\n        this.bodyEl = null;\n        this.footerEl = null;\n        this.currentNumberEl = null;\n        this.totalNumberEl = null;\n        this.images = images; //图片数据\n        this.imagesLength = images.length; //图片数据\n        this.container = opt.container || 'body';\n        this.enableScale = opt.enableScale === undefined ? true : opt.enableScale;//是否开启图片缩放功能\n        this.currentIndex = opt.startIndex || 0; //起始坐标，从0开始\n        this.viewers = [];\n        this.scaleStart = 1;\n        this.width = 0;\n        this.height = 0;\n        this.itemList = [];//各个图片容器元素的dom节点\n        this.hammer = null;\n        this.deltaX = 0;\n        this.translateX = 0;\n    }\n\n    _create() {\n        this.el = query('.image-viewer')[0];\n        this.destroy();\n        let imageViewerTemplate =\n            `<div class=\"image-viewer\">\n                <div class=\"image-header\"></div>\n                <div class=\"image-body\">\n                    <div class=\"viewer\"><div class=\"panel\"><img></div></div>\n                    <div class=\"viewer\"><div class=\"panel\"><img></div></div>\n                    <div class=\"viewer\"><div class=\"panel\"><img></div></div>\n                </div>\n                <div class=\"image-footer\"></div>\n            </div>`;\n\n        let divEl = document.createElement('div');\n        divEl.innerHTML = imageViewerTemplate;\n        this.el = divEl.firstElementChild;\n        query(this.container)[0].appendChild(this.el);\n        this.headerEl = query('.image-header', this.el)[0];\n        this.bodyEl = query('.image-body', this.el)[0];\n        this.footerEl = query('.image-footer', this.el)[0];\n        this.itemList = query('.image-body', this.el)[0].children;\n        this.width = this.el.clientWidth;\n        this.height = this.el.clientHeight;\n\n        if (this.opt.headerRender) {\n            this.headerEl.innerHTML = this.opt.headerRender();\n        }\n        if (this.opt.footerRender) {\n            this.footerEl.innerHTML = this.opt.footerRender();\n        }\n        this.currentNumberEl = query('.number-current', this.el)[0];//当前滑动所在的图片下标的元素节点\n        this.totalNumberEl = query('.number-total', this.el)[0];//图片总数的元素节点\n    }\n\n    _init() {\n        this.viewers = [];\n        for (let i = 0, length = this.itemList.length, item; i < length; i++) {\n            item = this.itemList[i];\n            this.viewers.push(new Viewer(this, item, this.width, this.height, i));\n        }\n        this.swipeInByIndex(this.currentIndex);\n        lock.createLock(LOCK_NAME);\n    }\n\n    _updateCountElement() {\n        if (this.currentNumberEl) {\n            this.currentNumberEl.innerText = this.currentIndex + 1;\n        }\n        if (this.totalNumberEl) {\n            this.totalNumberEl.innerText = this.imagesLength;\n        }\n    }\n\n    _bindEvent() {\n        let mc = new Hammer.Manager(this.el);\n        let hPinch = new Hammer.Pinch(),//前缀h代表hammer\n            hPan = new Hammer.Pan({direction: Hammer.DIRECTION_HORIZONTAL}),\n            hTap = new Hammer.Tap({taps: 2});\n        mc.add([hPinch, hPan, hTap]);\n        mc.on('panstart', this._dealWithMoveActionStart.bind(this));\n        mc.on('panmove', this._dealWithMoveAction.bind(this));\n        mc.on('panend', this._dealWithMoveActionEnd.bind(this));\n        if (this.enableScale) {\n            mc.on('tap', this.reset.bind(this));\n            mc.on('pinchstart', this._dealWithScaleActionStart.bind(this));\n            mc.on('pinch', this._dealWithScaleAction.bind(this));\n            mc.on('pinchend', this._dealWithScaleActionEnd.bind(this));\n        }\n        this.hammer = mc;\n    }\n\n    _dealWithMoveActionStart(event) {\n        if (lock.getLockState(LOCK_NAME))return;\n        this.bodyEl.classList.remove(ITEM_ANIMATION_CLASS);\n        this.opt.beforeSwipe && this.opt.beforeSwipe(this.currentIndex);\n        this.deltaX = event.deltaX;\n        this.bodyEl.style.willChange = 'transform';\n    }\n\n    _dealWithMoveAction(event, force) {\n        if (lock.getLockState(LOCK_NAME) && !force)return;\n        force && this.bodyEl.classList.remove(ITEM_ANIMATION_CLASS);\n        let distance = event.deltaX - this.deltaX;\n        setTranslateStyle(this.bodyEl, this.translateX + distance, 0);\n    }\n\n    _dealWithMoveActionEnd(event, force) {\n        if (lock.getLockState(LOCK_NAME) && !force)return;\n        let distance = event.deltaX - this.deltaX, needSwipe = false, needBreak = false;\n\n        if (this.currentIndex === 0 && distance > 0 && this.opt.swipeFirstRight) {\n            //当前图片是第一张，并且向右滑动\n            needBreak = this.opt.swipeFirstRight(this, Math.abs(distance));\n        } else if (this.currentIndex === (this.imagesLength - 1) && distance < 0 && this.opt.swipeLastLeft) {\n            //当前图片是最后一张，并且向左滑动\n            needBreak = this.opt.swipeLastLeft(this, Math.abs(distance));\n        }\n\n        if (!needBreak) {\n            distance !== 0 && this.bodyEl.classList.add(ITEM_ANIMATION_CLASS);\n            if (distance !== 0 && this._checkDistance(distance)) {\n                this.viewers.forEach((viewer) => {\n                    viewer.removeAnimation();\n                });\n                needSwipe = distance > 0 ? this.swipeToPrev() : this.swipeToNext();\n                this._updateCountElement();\n            } else {\n                setTranslateStyle(this.bodyEl, this.translateX, 0);\n            }\n            this.opt.afterSwipe && this.opt.afterSwipe(this.currentIndex);\n        }\n        this.deltaX = 0;\n        this.bodyEl.style.willChange = 'auto';\n        return needSwipe;\n    }\n\n    _dealWithScaleActionStart(event) {\n        this.scaleStart = event.scale;\n        this.viewers[1]._pinchStart();\n    }\n\n    _dealWithScaleAction(event) {\n        this.viewers[1]._pinch(event.scale - this.scaleStart);\n    }\n\n    _dealWithScaleActionEnd() {\n        this.viewers[1]._pinchEnd();\n    }\n\n    _checkDistance(distance = 0) {\n        return Math.abs(distance) > this.width / 5;\n    }\n\n    _getPrevImage() {\n        let minuend = this.currentIndex;\n        if (this.opt.loop && this.imagesLength > 2) {\n            minuend = this.currentIndex === 0 ? this.imagesLength : this.currentIndex;\n        }\n        return this.images[minuend - 1] || '';\n    }\n\n    _getCurrentImage() {\n        return this.images[this.currentIndex] || '';\n    }\n\n    _getNextImage() {\n        let addend = this.currentIndex;\n        if (this.opt.loop && this.imagesLength > 2) {\n            addend = this.currentIndex === this.imagesLength - 1 ? -1 : this.currentIndex;\n        }\n        return this.images[addend + 1] || '';\n    }\n\n    _getSpecificImage(index) {\n        return this.images[index] || '';\n    }\n\n    /**\n     * 重置当前图片的缩放\n     */\n    reset() {\n        let viewer = this.viewers[1];\n        viewer.init(viewer.displayIndex, true, null, false);\n        setTimeout(() => {\n            lock.releaseLock(LOCK_NAME);\n        }, 0);\n    }\n\n    /**\n     * 移动循环队列\n     * @param direction 方向，0：队首移动到队尾，1：队尾移动到队首\n     * @returns {*}\n     */\n    loopViewers(direction) {\n        let viewer = null;\n        if (direction === 0) {\n            viewer = this.viewers.shift();\n            this.viewers.push(viewer);\n        } else if (direction === 1) {\n            viewer = this.viewers.pop();\n            this.viewers = [viewer].concat(this.viewers);\n        }\n        return viewer;\n    }\n\n    /**\n     * 滑动到上一张\n     * @returns {boolean}\n     */\n    swipeToPrev() {\n        let prevImage = this._getPrevImage();\n        if (prevImage) {\n            this.currentIndex--;\n            this.translateX += this.width;\n            setTranslateStyle(this.bodyEl, this.translateX, 0);\n\n            let image = this._getSpecificImage(this.currentIndex - 1);\n            if (image || this.currentIndex === 0) {\n                let viewer = this.loopViewers(1);\n                viewer.init(viewer.displayIndex - 3, true, null, true, image);\n            }\n            return true;\n        } else {\n            setTranslateStyle(this.bodyEl, this.translateX, 0);\n            return false;\n        }\n    }\n\n    /**\n     * 滑动到下一张\n     * @returns {boolean}\n     */\n    swipeToNext() {\n        let nextImage = this._getNextImage();\n        if (nextImage) {\n            this.currentIndex++;\n            this.translateX -= this.width;\n            setTranslateStyle(this.bodyEl, this.translateX, 0);\n\n            let image = this._getSpecificImage(this.currentIndex + 1);\n            if (image || this.currentIndex === this.imagesLength - 1) {\n                let viewer = this.loopViewers(0);\n                viewer.init(viewer.displayIndex + 3, true, null, true, image);\n            }\n            return true;\n        } else {\n            setTranslateStyle(this.bodyEl, this.translateX, 0);\n            return false;\n        }\n    }\n\n    /**\n     * 根据给定的下标移动到指定图片处\n     * @param index 数组下标，从0开始\n     */\n    swipeInByIndex(index) {\n        if (!isNaN(index) && -1 < index && index < this.imagesLength) {\n            this.currentIndex = index;\n            this.translateX = 0;\n            setTranslateStyle(this.bodyEl, 0, 0);\n\n            this.viewers = this.viewers.sort(function (a, b) {\n                return a.index < b.index;\n            });\n            this.viewers[0].init(-1, true, null, true, this._getPrevImage());\n            this.viewers[1].init(0, true, null, true, this._getCurrentImage());\n            this.viewers[2].init(1, true, null, true, this._getNextImage());\n\n            this._updateCountElement();\n        } else {\n            debug('illegal index!');\n        }\n    }\n\n    setImageOption(images = [], startIndex = 0) {\n        if (!images.length) {\n            debug('images array can not be empty!')\n        }\n        this.images = images;\n        this.imagesLength = images.length;\n        this.currentIndex = startIndex;\n        this._init();\n    }\n\n    destroy() {\n        this.el && removeElement(this.el);\n    }\n\n    close() {\n        if (this.el) {\n            this.el.style.display = 'none';\n        }\n    }\n\n    open(index) {\n        this.currentIndex = index === undefined ? this.currentIndex : index;\n        if (!this.el) {\n            //仅仅实例化，但尚未初始化\n            this._create();\n            this._init();\n            this._bindEvent();\n        } else {\n            this.swipeInByIndex(this.currentIndex);\n        }\n        this.el.style.display = 'block';\n    }\n}\n\nexport default ImageViewer;\n\n\n// WEBPACK FOOTER //\n// ./src/core/imageViewer.js","import ImageViewer from './core/imageViewer';\nimport css from './css/index.css';\n\nwindow.ImageViewer = ImageViewer;\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","module.exports = function(originalModule) {\r\n\tif(!originalModule.webpackPolyfill) {\r\n\t\tvar module = Object.create(originalModule);\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"exports\", {\r\n\t\t\tenumerable: true,\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/harmony-module.js\n// module id = 2\n// module chunks = 0","/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/amd-options.js\n// module id = 3\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../node_modules/.0.28.4@css-loader/index.js!../../node_modules/.1.3.3@postcss-loader/index.js!./index.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!../../node_modules/.0.13.2@style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../node_modules/.0.28.4@css-loader/index.js!../../node_modules/.1.3.3@postcss-loader/index.js!./index.css\", function() {\n\t\t\tvar newContent = require(\"!!../../node_modules/.0.28.4@css-loader/index.js!../../node_modules/.1.3.3@postcss-loader/index.js!./index.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/css/index.css\n// module id = 4\n// module chunks = 0","exports = module.exports = require(\"../../node_modules/.0.28.4@css-loader/lib/css-base.js\")(undefined);\n// imports\n\n\n// module\nexports.push([module.id, \".viewer-animation {\\n    transition: -webkit-transform .3s;\\n    transition: transform .3s;\\n    transition: transform .3s, -webkit-transform .3s;\\n}\\n\\n.image-viewer {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    background-color: black;\\n    z-index: 10000;\\n    font-size: 0;\\n    -webkit-transform: translate3d(0, 0, 0);\\n            transform: translate3d(0, 0, 0);\\n    -webkit-backface-visibility: hidden;\\n            backface-visibility: hidden;\\n    overflow: hidden;\\n}\\n\\n.image-viewer .viewer {\\n    display: inline-block;\\n    position: absolute;\\n    top: 50%;\\n    width: 100%;\\n    text-align: center;\\n    -webkit-transform: translate3d(0, -50%, 0);\\n            transform: translate3d(0, -50%, 0);\\n    -webkit-backface-visibility: hidden;\\n            backface-visibility: hidden;\\n}\\n\\n.image-viewer .image-header {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    color: #fff;\\n    font-size: 12px;\\n    z-index: 11;\\n}\\n\\n.image-viewer .image-body {\\n    width: 100%;\\n    height: 100%;\\n    font-size: 0;\\n    z-index: 10;\\n}\\n\\n.image-viewer .image-body .panel img {\\n    max-width: 100%;\\n    max-height: 100%;\\n}\\n\\n.image-viewer .image-footer {\\n    position: absolute;\\n    left: 0;\\n    bottom: 0;\\n    width: 100%;\\n    color: #fff;\\n    font-size: 12px;\\n    z-index: 11;\\n}\\n\\n.image-viewer .panel {\\n    display: inline-block;\\n    overflow: hidden;\\n}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/.0.28.4@css-loader!./node_modules/.1.3.3@postcss-loader!./src/css/index.css\n// module id = 5\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/.0.28.4@css-loader/lib/css-base.js\n// module id = 6\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\tlinkElement.rel = \"stylesheet\";\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/.0.13.2@style-loader/addStyles.js\n// module id = 7\n// module chunks = 0"],"sourceRoot":""}